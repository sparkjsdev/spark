{"version":3,"file":"spark.cjs.min.js","sources":["../node_modules/three/examples/jsm/postprocessing/Pass.js","../node_modules/fflate/esm/browser.js","../rust/spark-internal-rs/pkg/spark_internal_rs.js","../src/defines.ts","../src/dyno/types.ts","../src/dyno/value.ts","../src/dyno/base.ts","../src/dyno/splats.ts","../src/dyno/output.ts","../src/dyno/uniforms.ts","../src/utils.ts","../src/dyno/program.ts","../src/dyno/mathTypes.ts","../src/dyno/math.ts","../src/dyno/logic.ts","../src/dyno/convert.ts","../src/dyno/vecmat.ts","../src/dyno/util.ts","../src/dyno/transform.ts","../src/dyno/control.ts","../src/dyno/texture.ts","../src/dyno/trig.ts","../src/shaders/computeVec4.glsl","../src/Readback.ts","../src/RgbaArray.ts","../src/SplatEdit.ts","../src/SplatGenerator.ts","../src/SplatMesh.ts","../src/ply.ts","../src/splatWorker.ts","../src/SplatLoader.ts","../src/shaders/computeUvec4.glsl","../src/PackedSplats.ts","../src/SplatGeometry.ts","../src/SparkViewpoint.ts","../src/SplatAccumulator.ts","../src/shaders/splatDefines.glsl","../src/shaders/splatFragment.glsl","../src/shaders/splatVertex.glsl","../src/shaders.ts","../src/SparkRenderer.ts","../src/antisplat.ts","../src/ksplat.ts","../src/spz.ts","../src/SplatSkinning.ts","../src/splatConstructors.ts","../src/generators/static.ts","../src/generators/snow.ts","../src/modifiers/normalColor.ts","../src/modifiers/depthColor.ts","../src/vrButton.ts","../src/hands.ts","../src/controls.ts"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\n/**\n * Abstract base class for all post processing passes.\n *\n * This module is only relevant for post processing with {@link WebGLRenderer}.\n *\n * @abstract\n * @three_import import { Pass } from 'three/addons/postprocessing/Pass.js';\n */\nclass Pass {\n\n\t/**\n\t * Constructs a new pass.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPass = true;\n\n\t\t/**\n\t\t * If set to `true`, the pass is processed by the composer.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enabled = true;\n\n\t\t/**\n\t\t * If set to `true`, the pass indicates to swap read and write buffer after rendering.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.needsSwap = true;\n\n\t\t/**\n\t\t * If set to `true`, the pass clears its buffer before rendering\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clear = false;\n\n\t\t/**\n\t\t * If set to `true`, the result of the pass is rendered to screen. The last pass in the composers\n\t\t * pass chain gets automatically rendered to screen, no matter how this property is configured.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @abstract\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( /* width, height */ ) {}\n\n\t/**\n\t * This method holds the render logic of a pass. It must be implemented in all derived classes.\n\t *\n\t * @abstract\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t *\n\t * @abstract\n\t */\n\tdispose() {}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nclass FullscreenTriangleGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\n\t}\n\n}\n\nconst _geometry = new FullscreenTriangleGeometry();\n\n\n/**\n * This module is a helper for passes which need to render a full\n * screen effect which is quite common in context of post processing.\n *\n * The intended usage is to reuse a single full screen quad for rendering\n * subsequent passes by just reassigning the `material` reference.\n *\n * This module can only be used with {@link WebGLRenderer}.\n *\n * @augments Mesh\n * @three_import import { FullScreenQuad } from 'three/addons/postprocessing/Pass.js';\n */\nclass FullScreenQuad {\n\n\t/**\n\t * Constructs a new full screen quad.\n\t *\n\t * @param {?Material} material - The material to render te full screen quad with.\n\t */\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\t/**\n\t * Renders the full screen quad.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t */\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\t/**\n\t * The quad's material.\n\t *\n\t * @type {?Material}\n\t */\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return { b: b, r: r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 1; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n        return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (resize)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\n        if (resize)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (resize)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                if (bt < dt) {\n                    var shift = dl - dt, dend = Math.min(dt, end);\n                    if (shift + bt < 0)\n                        err(3);\n                    for (; bt < dend; ++bt)\n                        buf[bt] = dict[shift + bt];\n                }\n                for (; bt < end; ++bt)\n                    buf[bt] = buf[bt - dt];\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return { t: et, l: 0 };\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return { t: v, l: 1 };\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return { t: new u8(tr), l: mbt };\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return { c: cl.subarray(0, cli), n: s };\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        ++lcfreq[lclt[i] & 31];\n    for (var i = 0; i < lcdt.length; ++i)\n        ++lcfreq[lcdt[i] & 31];\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        var sym = syms[i];\n        if (sym > 255) {\n            var len = (sym >> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (sym >> 23) & 31), p += fleb[len];\n            var dst = sym & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[sym]), p += ll[sym];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n        if (pos)\n            w[0] = st.r >> 3;\n        var opt = deo[lvl - 1];\n        var n = opt >> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new i32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n        for (; i + 2 < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = i - dif + j & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one int32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        for (i = Math.max(i, wi); i < s; ++i) {\n            syms[li++] = dat[i];\n            ++lf[dat[i]];\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        if (!lst) {\n            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;\n            // shft(pos) now 1 less if pos & 7 != 0\n            pos -= 7;\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\n        }\n    }\n    else {\n        for (var i = st.w || 0; i < s + lst; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[(pos / 8) | 0] = lst;\n                e = s;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n        st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Adler32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    if (!st) {\n        st = { l: 1 };\n        if (opt.dictionary) {\n            var dict = opt.dictionary.subarray(-32768);\n            var newDat = new u8(dict.length + dat.length);\n            newDat.set(dict);\n            newDat.set(dat, dict.length);\n            dat = newDat;\n            st.w = dict.length;\n        }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return fnStr;\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            fnStr = wcln(fns[i], fnStr, td_1);\n        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td = mrg({}, ch[id].e);\n    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt]; };\nvar bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zls]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get opts\nvar gopt = function (o) { return o && {\n    out: o.size && new u8(o.size),\n    dictionary: o.dictionary\n}; };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) {\n        if (ev.data.length) {\n            strm.push(ev.data[0], ev.data[1]);\n            postMessage([ev.data[0].length]);\n        }\n        else\n            strm.flush();\n    };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id, flush, ext) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else if (!Array.isArray(dat))\n            ext(dat);\n        else if (dat.length == 1) {\n            strm.queuedSize -= dat[0];\n            if (strm.ondrain)\n                strm.ondrain(dat[0]);\n        }\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.queuedSize = 0;\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        strm.queuedSize += d.length;\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n    if (flush) {\n        strm.flush = function () { w.postMessage([]); };\n    }\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);\n    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;\n    if (o.dictionary) {\n        var h = adler();\n        h.p(o.dictionary);\n        wbytes(c, 2, h.d());\n    }\n};\n// zlib start\nvar zls = function (d, dict) {\n    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if ((d[1] >> 5 & 1) == +!dict)\n        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');\n    return (d[1] >> 3 & 4) + 2;\n};\nfunction StrmOpt(opts, cb) {\n    if (typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\n        this.b = new u8(98304);\n        if (this.o.dictionary) {\n            var dict = this.o.dictionary.subarray(-32768);\n            this.b.set(dict, 32768 - dict.length);\n            this.s.i = 32768 - dict.length;\n        }\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        var endLen = chunk.length + this.s.z;\n        if (endLen > this.b.length) {\n            if (endLen > 2 * this.b.length - 32768) {\n                var newBuf = new u8(endLen & -32768);\n                newBuf.set(this.b.subarray(0, this.s.z));\n                this.b = newBuf;\n            }\n            var split = this.b.length - this.s.z;\n            this.b.set(chunk.subarray(0, split), this.s.z);\n            this.s.z = this.b.length;\n            this.p(this.b, false);\n            this.b.set(this.b.subarray(-32768));\n            this.b.set(chunk.subarray(split), 32768);\n            this.s.z = chunk.length - split + 32768;\n            this.s.i = 32766, this.s.w = 32768;\n        }\n        else {\n            this.b.set(chunk, this.s.z);\n            this.s.z += chunk.length;\n        }\n        this.s.l = final & 1;\n        if (this.s.z > this.s.w + 8191 || final) {\n            this.p(this.b, final || false);\n            this.s.w = this.s.i, this.s.i -= 2;\n        }\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * deflated output for small inputs.\n     */\n    Deflate.prototype.flush = function () {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        this.p(this.b, false);\n        this.s.w = this.s.i, this.s.i -= 2;\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6, 1);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    function Inflate(opts, cb) {\n        // no StrmOpt here to avoid adding to workerizer\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n        this.s = { i: 0, b: dict ? dict.length : 0 };\n        this.o = new u8(32768);\n        this.p = new u8(0);\n        if (dict)\n            this.o.set(dict);\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        if (!this.p.length)\n            this.p = c;\n        else if (c.length) {\n            var n = new u8(this.p.length + c.length);\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\n        }\n    };\n    Inflate.prototype.c = function (final) {\n        this.s.i = +(this.d = final || false);\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.s, this.o);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    function AsyncInflate(opts, cb) {\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Inflate(ev.data);\n            onmessage = astrm(strm);\n        }, 7, 0);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gopt(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        this.l += chunk.length;\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * GZIPped output for small inputs.\n     */\n    Gzip.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8, 1);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming single or multi-member GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    function Gunzip(opts, cb) {\n        this.v = 1;\n        this.r = 0;\n        Inflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        this.r += chunk.length;\n        if (this.v) {\n            var p = this.p.subarray(this.v - 1);\n            var s = p.length > 3 ? gzs(p) : 4;\n            if (s > p.length) {\n                if (!final)\n                    return;\n            }\n            else if (this.v > 1 && this.onmember) {\n                this.onmember(this.r - p.length);\n            }\n            this.p = p.subarray(s), this.v = 0;\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n        // process concatenated GZIP\n        if (this.s.f && !this.s.l && !final) {\n            this.v = shft(this.s.p) + 9;\n            this.s = { i: 0 };\n            this.o = new u8(0);\n            this.push(new u8(0), final);\n        }\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming single or multi-member GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    function AsyncGunzip(opts, cb) {\n        var _this = this;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gunzip(ev.data);\n            strm.onmember = function (offset) { return postMessage(offset); };\n            onmessage = astrm(strm);\n        }, 9, 0, function (offset) { return _this.onmember && _this.onmember(offset); });\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0], ev.data[1])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, opts) {\n    var st = gzs(data);\n    if (st + 8 > data.length)\n        err(6, 'invalid gzip data');\n    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * zlibbed output for small inputs.\n     */\n    Zlib.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10, 1);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    function Unzlib(opts, cb) {\n        Inflate.call(this, opts, cb);\n        this.v = opts && opts.dictionary ? 2 : 1;\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 6 && !final)\n                return;\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    function AsyncUnzlib(opts, cb) {\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Unzlib(ev.data);\n            onmessage = astrm(strm);\n        }, 11, 0);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gopt(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, opts) {\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    function Decompress(opts, cb) {\n        this.o = StrmOpt.call(this, opts, cb) || {};\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n    }\n    // init substream\n    // overriden by AsyncDecompress\n    Decompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (dat, final) {\n            _this.ondata(dat, final);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(this.o)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(this.o)\n                        : new this.Z(this.o);\n                this.i();\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    function AsyncDecompress(opts, cb) {\n        Decompress.call(this, opts, cb);\n        this.queuedSize = 0;\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n    }\n    AsyncDecompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        };\n        this.s.ondrain = function (size) {\n            _this.queuedSize -= size;\n            if (_this.ondrain)\n                _this.ondrain(size);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        this.queuedSize += chunk.length;\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, opts) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, opts)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, opts)\n            : unzlibSync(data, opts);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return { s: r, r: slc(d, i - 1) };\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (final) {\n            if (r.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = r;\n        this.ondata(s, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td) {\n        return td.decode(dat);\n    }\n    else {\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (r.length)\n            err(8);\n        return s;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this.ondata(err, dat, final);\n                    _this.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this.d & 1))\n                        return;\n                    _this.u.splice(-1, 1);\n                    _this.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this = this;\n        this.i = new Inflate(function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this.k[0] == chks_3 && _this.c)\n                                        _this.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    // Synchronously decompress under 512KB, or barely-compressed data\n                    if (su < 524288 || sc > 0.8 * su) {\n                        try {\n                            cbl(null, inflateSync(infl, { out: new u8(su) }));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","let wasm;\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n/**\n * @param {number} num_splats\n * @param {Uint32Array} readback\n * @param {Uint32Array} ordering\n * @returns {number}\n */\nexport function sort32_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort32_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n}\n\n/**\n * @param {number} origin_x\n * @param {number} origin_y\n * @param {number} origin_z\n * @param {number} dir_x\n * @param {number} dir_y\n * @param {number} dir_z\n * @param {number} near\n * @param {number} far\n * @param {number} num_splats\n * @param {Uint32Array} packed_splats\n * @param {boolean} raycast_ellipsoid\n * @param {number} ln_scale_min\n * @param {number} ln_scale_max\n * @returns {Float32Array}\n */\nexport function raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid, ln_scale_min, ln_scale_max) {\n    const ret = wasm.raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid, ln_scale_min, ln_scale_max);\n    return ret;\n}\n\n/**\n * @param {number} num_splats\n * @param {Uint16Array} readback\n * @param {Uint32Array} ordering\n * @returns {number}\n */\nexport function sort_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n        const ret = arg0.buffer;\n        return ret;\n    };\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n        const ret = arg0.length;\n        return ret;\n    };\n    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\n        const ret = arg0.length;\n        return ret;\n    };\n    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\n        const ret = arg0.length;\n        return ret;\n    };\n    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\n        const ret = new Uint16Array(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\n        const ret = new Uint32Array(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\n        const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n        return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {\n        const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n        return ret;\n    };\n    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n        const ret = new Float32Array(arg0 >>> 0);\n        return ret;\n    };\n    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n        arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\n        arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\n        arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\n        const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n        return ret;\n    };\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\n        const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n        return ret;\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_0;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return ret;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedUint8ArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('spark_internal_rs_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","// LN_SCALE_MIN..LN_SCALE_MAX define the internal scale range of for Gsplats,\r\n// covering approx 0.0001..8000 in range with discrete steps 7% apart.\r\n// The value \"0\" is reserved for truly flat scales, indicating a 2DGS.\r\n// If these values are changed, the corresponding values in splatDefines.glsl\r\n// must also be updated to match.\r\n\r\nexport const LN_SCALE_MIN = -12.0;\r\nexport const LN_SCALE_MAX = 9.0;\r\nexport const SCALE_MIN = Math.exp(LN_SCALE_MIN);\r\nexport const SCALE_MAX = Math.exp(LN_SCALE_MAX);\r\n\r\nexport const LN_SCALE_ZERO = -30.0;\r\nexport const SCALE_ZERO = Math.exp(LN_SCALE_ZERO);\r\n\r\n// Gsplats are stored in textures that are 2^11 x 2^11 x up to 2^11\r\n// Most WebGL2 implementations support 2D textures up to 2^12 x 2^12 (max 16M Gsplats)\r\n// 2D array textures and 3D textures up to 2^11 x 2^11 x 2^11 (max 8G Gsplats),\r\n// so we use 2D array textures for our representation for higher limits.\r\n\r\nexport const SPLAT_TEX_WIDTH_BITS = 11;\r\nexport const SPLAT_TEX_HEIGHT_BITS = 11;\r\nexport const SPLAT_TEX_DEPTH_BITS = 11;\r\nexport const SPLAT_TEX_LAYER_BITS =\r\n  SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\r\n\r\nexport const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS; // 2048\r\nexport const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS; // 2048\r\nexport const SPLAT_TEX_DEPTH = 1 << SPLAT_TEX_DEPTH_BITS; // 2048\r\nexport const SPLAT_TEX_MIN_HEIGHT = 1;\r\n\r\nexport const SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1;\r\nexport const SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1;\r\nexport const SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1;\r\n\r\n// Enable/disable Gsplat sorting via Rust WASM code. In testing the sorting\r\n// time between pure JS and WASM are minimal and don't make a big difference.\r\n\r\nexport const WASM_SPLAT_SORT = true;\r\n\r\n// Enable/disable compiling a dedicated parse function per element type\r\n// in the plyReader.\r\n\r\nexport const USE_COMPILED_PARSER_FUNCTION = true;\r\n","import type * as THREE from \"three\";\r\n\r\nexport type BoolTypes = \"bool\" | \"bvec2\" | \"bvec3\" | \"bvec4\";\r\nexport type IntTypes = \"int\" | \"ivec2\" | \"ivec3\" | \"ivec4\";\r\nexport type UintTypes = \"uint\" | \"uvec2\" | \"uvec3\" | \"uvec4\";\r\nexport type AllIntTypes = IntTypes | UintTypes;\r\nexport type FloatTypes = \"float\" | \"vec2\" | \"vec3\" | \"vec4\";\r\nexport type ScalarTypes = \"uint\" | \"int\" | \"float\";\r\nexport type Vector2Types = \"vec2\" | \"ivec2\" | \"uvec2\";\r\nexport type Vector3Types = \"vec3\" | \"ivec3\" | \"uvec3\";\r\nexport type Vector4Types = \"vec4\" | \"ivec4\" | \"uvec4\";\r\nexport type VectorTypes = Vector2Types | Vector3Types | Vector4Types;\r\nexport type MatFloatTypes =\r\n  | \"mat2\"\r\n  | \"mat2x2\"\r\n  | \"mat2x3\"\r\n  | \"mat2x4\"\r\n  | \"mat3\"\r\n  | \"mat3x2\"\r\n  | \"mat3x3\"\r\n  | \"mat3x4\"\r\n  | \"mat4\"\r\n  | \"mat4x2\"\r\n  | \"mat4x3\"\r\n  | \"mat4x4\";\r\nexport type SquareMatTypes =\r\n  | \"mat2\"\r\n  | \"mat3\"\r\n  | \"mat4\"\r\n  | \"mat2x2\"\r\n  | \"mat3x3\"\r\n  | \"mat4x4\";\r\nexport type AllFloatTypes = FloatTypes | MatFloatTypes;\r\nexport type SignedTypes = IntTypes | FloatTypes;\r\nexport type AllSignedTypes = SignedTypes | MatFloatTypes;\r\nexport type ValueTypes = FloatTypes | IntTypes | UintTypes;\r\nexport type AllValueTypes = AllFloatTypes | IntTypes | UintTypes;\r\nexport type SimpleTypes = BoolTypes | AllValueTypes;\r\n\r\nexport type VectorElementType<A extends VectorTypes> = A extends FloatTypes\r\n  ? \"float\"\r\n  : A extends IntTypes\r\n    ? \"int\"\r\n    : A extends UintTypes\r\n      ? \"uint\"\r\n      : never;\r\n\r\nexport type SameSizeVec<T extends ValueTypes> = T extends ScalarTypes\r\n  ? \"float\"\r\n  : T extends \"vec2\" | \"ivec2\" | \"uvec2\"\r\n    ? \"vec2\"\r\n    : T extends \"vec3\" | \"ivec3\" | \"uvec3\"\r\n      ? \"vec3\"\r\n      : T extends \"vec4\" | \"ivec4\" | \"uvec4\"\r\n        ? \"vec4\"\r\n        : never;\r\n\r\nexport type SameSizeUvec<T extends ValueTypes> = T extends ScalarTypes\r\n  ? \"uint\"\r\n  : T extends \"vec2\" | \"ivec2\" | \"uvec2\"\r\n    ? \"uvec2\"\r\n    : T extends \"vec3\" | \"ivec3\" | \"uvec3\"\r\n      ? \"uvec3\"\r\n      : T extends \"vec4\" | \"ivec4\" | \"uvec4\"\r\n        ? \"uvec4\"\r\n        : never;\r\n\r\nexport type SameSizeIvec<T extends ValueTypes> = T extends ScalarTypes\r\n  ? \"int\"\r\n  : T extends \"vec2\" | \"ivec2\" | \"uvec2\"\r\n    ? \"ivec2\"\r\n    : T extends \"vec3\" | \"ivec3\" | \"uvec3\"\r\n      ? \"ivec3\"\r\n      : T extends \"vec4\" | \"ivec4\" | \"uvec4\"\r\n        ? \"ivec4\"\r\n        : never;\r\n\r\nexport type SamplerTypes =\r\n  | \"sampler2D\"\r\n  | \"sampler2DArray\"\r\n  | \"sampler3D\"\r\n  | \"samplerCube\";\r\nexport type UsamplerTypes =\r\n  | \"usampler2D\"\r\n  | \"usampler2DArray\"\r\n  | \"usampler3D\"\r\n  | \"usamplerCube\";\r\nexport type IsamplerTypes =\r\n  | \"isampler2D\"\r\n  | \"isampler2DArray\"\r\n  | \"isampler3D\"\r\n  | \"isamplerCube\";\r\nexport type NormalSamplerTypes = SamplerTypes | UsamplerTypes | IsamplerTypes;\r\nexport type SamplerShadowTypes =\r\n  | \"sampler2DShadow\"\r\n  | \"sampler2DArrayShadow\"\r\n  | \"samplerCubeShadow\";\r\nexport type AllSamplerTypes = NormalSamplerTypes | SamplerShadowTypes;\r\nexport type Sampler2DTypes =\r\n  | \"sampler2D\"\r\n  | \"usampler2D\"\r\n  | \"isampler2D\"\r\n  | \"sampler2DShadow\";\r\nexport type Sampler2DArrayTypes =\r\n  | \"sampler2DArray\"\r\n  | \"usampler2DArray\"\r\n  | \"isampler2DArray\"\r\n  | \"sampler2DArrayShadow\";\r\nexport type Sampler3DTypes = \"sampler3D\" | \"usampler3D\" | \"isampler3D\";\r\nexport type SamplerCubeTypes =\r\n  | \"samplerCube\"\r\n  | \"usamplerCube\"\r\n  | \"isamplerCube\"\r\n  | \"samplerCubeShadow\";\r\n\r\nexport function isBoolType(type: DynoType): boolean {\r\n  return (\r\n    type === \"bool\" || type === \"bvec2\" || type === \"bvec3\" || type === \"bvec4\"\r\n  );\r\n}\r\n\r\nexport function isScalarType(type: DynoType): boolean {\r\n  return type === \"int\" || type === \"uint\" || type === \"float\";\r\n}\r\n\r\nexport function isIntType(type: DynoType): boolean {\r\n  return (\r\n    type === \"int\" || type === \"ivec2\" || type === \"ivec3\" || type === \"ivec4\"\r\n  );\r\n}\r\n\r\nexport function isUintType(type: DynoType): boolean {\r\n  return (\r\n    type === \"uint\" || type === \"uvec2\" || type === \"uvec3\" || type === \"uvec4\"\r\n  );\r\n}\r\n\r\nexport function isFloatType(type: DynoType): boolean {\r\n  return (\r\n    type === \"float\" || type === \"vec2\" || type === \"vec3\" || type === \"vec4\"\r\n  );\r\n}\r\n\r\nexport function isMatFloatType(type: DynoType): boolean {\r\n  return (\r\n    type === \"mat2\" ||\r\n    type === \"mat2x2\" ||\r\n    type === \"mat2x3\" ||\r\n    type === \"mat2x4\" ||\r\n    type === \"mat3\" ||\r\n    type === \"mat3x2\" ||\r\n    type === \"mat3x3\" ||\r\n    type === \"mat3x4\" ||\r\n    type === \"mat4\" ||\r\n    type === \"mat4x2\" ||\r\n    type === \"mat4x3\" ||\r\n    type === \"mat4x4\"\r\n  );\r\n}\r\n\r\nexport function isAllFloatType(type: DynoType): boolean {\r\n  return isFloatType(type) || isMatFloatType(type);\r\n}\r\n\r\nexport function isVector2Type(type: DynoType): boolean {\r\n  return type === \"vec2\" || type === \"ivec2\" || type === \"uvec2\";\r\n}\r\n\r\nexport function isVector3Type(type: DynoType): boolean {\r\n  return type === \"vec3\" || type === \"ivec3\" || type === \"uvec3\";\r\n}\r\n\r\nexport function isVector4Type(type: DynoType): boolean {\r\n  return type === \"vec4\" || type === \"ivec4\" || type === \"uvec4\";\r\n}\r\n\r\nexport function isVectorType(type: DynoType): boolean {\r\n  return isVector2Type(type) || isVector3Type(type) || isVector4Type(type);\r\n}\r\n\r\nexport function isMat2(type: DynoType): boolean {\r\n  return type === \"mat2\" || type === \"mat2x2\";\r\n}\r\nexport function isMat3(type: DynoType): boolean {\r\n  return type === \"mat3\" || type === \"mat3x3\";\r\n}\r\nexport function isMat4(type: DynoType): boolean {\r\n  return type === \"mat4\" || type === \"mat4x4\";\r\n}\r\n\r\nexport function vectorElementType<A extends VectorTypes>(\r\n  type: A,\r\n): VectorElementType<A> {\r\n  switch (type) {\r\n    case \"vec2\":\r\n      return \"float\" as VectorElementType<A>;\r\n    case \"vec3\":\r\n      return \"float\" as VectorElementType<A>;\r\n    case \"vec4\":\r\n      return \"float\" as VectorElementType<A>;\r\n    case \"ivec2\":\r\n      return \"int\" as VectorElementType<A>;\r\n    case \"ivec3\":\r\n      return \"int\" as VectorElementType<A>;\r\n    case \"ivec4\":\r\n      return \"int\" as VectorElementType<A>;\r\n    case \"uvec2\":\r\n      return \"uint\" as VectorElementType<A>;\r\n    case \"uvec3\":\r\n      return \"uint\" as VectorElementType<A>;\r\n    case \"uvec4\":\r\n      return \"uint\" as VectorElementType<A>;\r\n    default:\r\n      throw new Error(`Invalid vector type: ${type}`);\r\n  }\r\n}\r\n\r\nexport function vectorDim<A extends VectorTypes>(type: A): number {\r\n  switch (type) {\r\n    case \"vec2\":\r\n    case \"ivec2\":\r\n    case \"uvec2\":\r\n      return 2;\r\n    case \"vec3\":\r\n    case \"ivec3\":\r\n    case \"uvec3\":\r\n      return 3;\r\n    case \"vec4\":\r\n    case \"ivec4\":\r\n    case \"uvec4\":\r\n      return 4;\r\n    default:\r\n      throw new Error(`Invalid vector type: ${type}`);\r\n  }\r\n}\r\n\r\nexport function sameSizeVec<T extends ValueTypes>(type: T): SameSizeVec<T> {\r\n  if (isScalarType(type)) {\r\n    return \"float\" as SameSizeVec<T>;\r\n  }\r\n  if (isVector2Type(type)) {\r\n    return \"vec2\" as SameSizeVec<T>;\r\n  }\r\n  if (isVector3Type(type)) {\r\n    return \"vec3\" as SameSizeVec<T>;\r\n  }\r\n  if (isVector4Type(type)) {\r\n    return \"vec4\" as SameSizeVec<T>;\r\n  }\r\n  throw new Error(`Invalid vector type: ${type}`);\r\n}\r\n\r\nexport function sameSizeUvec<T extends ValueTypes>(type: T): SameSizeUvec<T> {\r\n  if (isScalarType(type)) {\r\n    return \"uint\" as SameSizeUvec<T>;\r\n  }\r\n  if (isVector2Type(type)) {\r\n    return \"uvec2\" as SameSizeUvec<T>;\r\n  }\r\n  if (isVector3Type(type)) {\r\n    return \"uvec3\" as SameSizeUvec<T>;\r\n  }\r\n  if (isVector4Type(type)) {\r\n    return \"uvec4\" as SameSizeUvec<T>;\r\n  }\r\n  throw new Error(`Invalid vector type: ${type}`);\r\n}\r\n\r\nexport function sameSizeIvec<T extends ValueTypes>(type: T): SameSizeIvec<T> {\r\n  if (isScalarType(type)) {\r\n    return \"int\" as SameSizeIvec<T>;\r\n  }\r\n  if (isVector2Type(type)) {\r\n    return \"ivec2\" as SameSizeIvec<T>;\r\n  }\r\n  if (isVector3Type(type)) {\r\n    return \"ivec3\" as SameSizeIvec<T>;\r\n  }\r\n  if (isVector4Type(type)) {\r\n    return \"ivec4\" as SameSizeIvec<T>;\r\n  }\r\n  throw new Error(`Invalid vector type: ${type}`);\r\n}\r\n\r\nexport type BaseType = SimpleTypes | AllSamplerTypes;\r\nexport type UserType = { type: string };\r\nexport type DynoType = BaseType | UserType;\r\n\r\nexport type DynoJsType<T extends DynoType> = T extends \"bool\"\r\n  ? boolean\r\n  : T extends \"uint\"\r\n    ? number\r\n    : T extends \"int\"\r\n      ? number\r\n      : T extends \"float\"\r\n        ? number\r\n        : T extends \"bvec2\"\r\n          ? [boolean, boolean]\r\n          : T extends \"uvec2\"\r\n            ? THREE.Vector2 | [number, number] | Uint32Array\r\n            : T extends \"ivec2\"\r\n              ? THREE.Vector2 | [number, number] | Int32Array\r\n              : T extends \"vec2\"\r\n                ? THREE.Vector2 | [number, number] | Float32Array\r\n                : T extends \"bvec3\"\r\n                  ? [boolean, boolean, boolean]\r\n                  : T extends \"uvec3\"\r\n                    ? THREE.Vector3 | [number, number, number] | Uint32Array\r\n                    : T extends \"ivec3\"\r\n                      ? THREE.Vector3 | [number, number, number] | Int32Array\r\n                      : T extends \"vec3\"\r\n                        ?\r\n                            | THREE.Vector3\r\n                            | THREE.Color\r\n                            | [number, number, number]\r\n                            | Float32Array\r\n                        : T extends \"bvec4\"\r\n                          ? [boolean, boolean, boolean, boolean]\r\n                          : T extends \"uvec4\"\r\n                            ?\r\n                                | THREE.Vector4\r\n                                | [number, number, number, number]\r\n                                | Uint32Array\r\n                            : T extends \"ivec4\"\r\n                              ?\r\n                                  | THREE.Vector4\r\n                                  | [number, number, number, number]\r\n                                  | Int32Array\r\n                              : T extends \"vec4\"\r\n                                ?\r\n                                    | THREE.Vector4\r\n                                    | THREE.Quaternion\r\n                                    | [number, number, number, number]\r\n                                    | Float32Array\r\n                                : T extends \"mat2\"\r\n                                  ? THREE.Matrix2 | Float32Array\r\n                                  : T extends \"mat2x2\"\r\n                                    ? THREE.Matrix2 | Float32Array\r\n                                    : T extends \"mat2x3\"\r\n                                      ? Float32Array\r\n                                      : T extends \"mat2x4\"\r\n                                        ? Float32Array\r\n                                        : T extends \"mat3\"\r\n                                          ? THREE.Matrix3 | Float32Array\r\n                                          : T extends \"mat3x2\"\r\n                                            ? Float32Array\r\n                                            : T extends \"mat3x3\"\r\n                                              ? THREE.Matrix3 | Float32Array\r\n                                              : T extends \"mat3x4\"\r\n                                                ? Float32Array\r\n                                                : T extends \"mat4\"\r\n                                                  ? THREE.Matrix4 | Float32Array\r\n                                                  : T extends \"mat4x2\"\r\n                                                    ? Float32Array\r\n                                                    : T extends \"mat4x3\"\r\n                                                      ? Float32Array\r\n                                                      : T extends \"mat4x4\"\r\n                                                        ?\r\n                                                            | THREE.Matrix4\r\n                                                            | Float32Array\r\n                                                        : T extends \"usampler2D\"\r\n                                                          ? THREE.Texture\r\n                                                          : T extends \"isampler2D\"\r\n                                                            ? THREE.Texture\r\n                                                            : T extends \"sampler2D\"\r\n                                                              ? THREE.Texture\r\n                                                              : T extends \"sampler2DShadow\"\r\n                                                                ? THREE.Texture\r\n                                                                : T extends \"usampler2DArray\"\r\n                                                                  ? THREE.DataArrayTexture\r\n                                                                  : T extends \"isampler2DArray\"\r\n                                                                    ? THREE.DataArrayTexture\r\n                                                                    : T extends \"sampler2DArray\"\r\n                                                                      ? THREE.DataArrayTexture\r\n                                                                      : T extends \"sampler2DArrayShadow\"\r\n                                                                        ? THREE.Texture\r\n                                                                        : T extends \"usampler3D\"\r\n                                                                          ? THREE.DataArrayTexture\r\n                                                                          : T extends \"isampler3D\"\r\n                                                                            ? THREE.DataArrayTexture\r\n                                                                            : T extends \"sampler3D\"\r\n                                                                              ? THREE.DataArrayTexture\r\n                                                                              : T extends \"usamplerCube\"\r\n                                                                                ? THREE.DataArrayTexture\r\n                                                                                : T extends \"isamplerCube\"\r\n                                                                                  ? THREE.DataArrayTexture\r\n                                                                                  : T extends \"samplerCube\"\r\n                                                                                    ? THREE.DataArrayTexture\r\n                                                                                    : T extends \"samplerCubeShadow\"\r\n                                                                                      ? THREE.Texture\r\n                                                                                      : unknown;\r\n\r\nexport function typeLiteral(type: DynoType): string {\r\n  if (typeof type === \"string\") {\r\n    return type;\r\n  }\r\n  if (typeof type === \"object\" && type.type) {\r\n    return type.type;\r\n  }\r\n  throw new Error(`Invalid DynoType: ${String(type)}`);\r\n}\r\n\r\nexport function numberAsInt(value: number): string {\r\n  return Math.trunc(value).toString();\r\n}\r\n\r\nexport function numberAsUint(value: number): string {\r\n  const v = Math.max(0, Math.trunc(value));\r\n  return `${v.toString()}u`;\r\n}\r\n\r\nexport function numberAsFloat(value: number): string {\r\n  return value === Number.POSITIVE_INFINITY\r\n    ? \"INFINITY\"\r\n    : value === Number.NEGATIVE_INFINITY\r\n      ? \"-INFINITY\"\r\n      : Number.isInteger(value)\r\n        ? value.toFixed(1)\r\n        : value.toString();\r\n}\r\n","import * as THREE from \"three\";\r\n\r\nimport type { Dyno, IOTypes } from \"./base\";\r\nimport {\r\n  type DynoJsType,\r\n  type DynoType,\r\n  type SimpleTypes,\r\n  isAllFloatType,\r\n  isBoolType,\r\n  isIntType,\r\n  isUintType,\r\n  numberAsFloat,\r\n  numberAsInt,\r\n  numberAsUint,\r\n} from \"./types\";\r\n\r\nexport type DynoVal<T extends DynoType> = DynoValue<T> | HasDynoOut<T>;\r\n\r\nexport function valType<T extends DynoType>(val: DynoVal<T>): T {\r\n  if (val instanceof DynoValue) {\r\n    return val.type;\r\n  }\r\n  const value = val.dynoOut();\r\n  return value.type;\r\n}\r\n\r\nexport interface HasDynoOut<T extends DynoType> {\r\n  dynoOut(): DynoValue<T>;\r\n}\r\n\r\nexport class DynoValue<T extends DynoType> {\r\n  type: T;\r\n  // This field prevents TypeScript structural matching on objects with a \"type\" field\r\n  private __isDynoValue = true;\r\n\r\n  constructor(type: T) {\r\n    this.type = type;\r\n  }\r\n}\r\n\r\nexport class DynoOutput<\r\n  T extends DynoType,\r\n  InTypes extends IOTypes,\r\n  OutTypes extends IOTypes,\r\n> extends DynoValue<T> {\r\n  dyno: Dyno<InTypes, OutTypes>;\r\n  key: string;\r\n\r\n  constructor(dyno: Dyno<InTypes, OutTypes>, key: string) {\r\n    super(dyno.outTypes[key] as T);\r\n    this.dyno = dyno;\r\n    this.key = key;\r\n  }\r\n}\r\n\r\nexport class DynoLiteral<T extends DynoType> extends DynoValue<T> {\r\n  literal: string;\r\n\r\n  constructor(type: T, literal: string) {\r\n    super(type);\r\n    this.literal = literal;\r\n  }\r\n\r\n  getLiteral(): string {\r\n    return this.literal;\r\n  }\r\n}\r\n\r\nexport function dynoLiteral<T extends DynoType>(\r\n  type: T,\r\n  literal: string,\r\n): DynoLiteral<T> {\r\n  return new DynoLiteral(type, literal);\r\n}\r\n\r\nexport class DynoConst<T extends DynoType> extends DynoLiteral<T> {\r\n  value: DynoJsType<T>;\r\n\r\n  constructor(type: T, value: DynoJsType<T>) {\r\n    super(type, \"\");\r\n    this.value = value;\r\n  }\r\n\r\n  getLiteral(): string {\r\n    const { type, value } = this;\r\n    switch (type) {\r\n      case \"bool\":\r\n        return value ? \"true\" : \"false\";\r\n      case \"uint\":\r\n        return numberAsUint(value as number);\r\n      case \"int\":\r\n        return numberAsInt(value as number);\r\n      case \"float\":\r\n        return numberAsFloat(value as number);\r\n      case \"bvec2\": {\r\n        const v = value as [boolean, boolean];\r\n        return `bvec2(${v[0]}, ${v[1]})`;\r\n      }\r\n      case \"uvec2\": {\r\n        if (value instanceof THREE.Vector2) {\r\n          return `uvec2(${numberAsUint(value.x)}, ${numberAsUint(value.y)})`;\r\n        }\r\n        const v = value as [number, number] | Uint32Array;\r\n        return `uvec2(${numberAsUint(v[0])}, ${numberAsUint(v[1])})`;\r\n      }\r\n      case \"ivec2\": {\r\n        if (value instanceof THREE.Vector2) {\r\n          return `ivec2(${numberAsInt(value.x)}, ${numberAsInt(value.y)})`;\r\n        }\r\n        const v = value as [number, number] | Int32Array;\r\n        return `ivec2(${numberAsInt(v[0])}, ${numberAsInt(v[1])})`;\r\n      }\r\n      case \"vec2\": {\r\n        if (value instanceof THREE.Vector2) {\r\n          return `vec2(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)})`;\r\n        }\r\n        const v = value as [number, number] | Float32Array;\r\n        return `vec2(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])})`;\r\n      }\r\n      case \"bvec3\": {\r\n        const v = value as [boolean, boolean, boolean];\r\n        return `bvec3(${v[0]}, ${v[1]}, ${v[2]})`;\r\n      }\r\n      case \"uvec3\": {\r\n        if (value instanceof THREE.Vector3) {\r\n          return `uvec3(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)})`;\r\n        }\r\n        const v = value as [number, number, number] | Uint32Array;\r\n        return `uvec3(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])})`;\r\n      }\r\n      case \"ivec3\": {\r\n        if (value instanceof THREE.Vector3) {\r\n          return `ivec3(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)})`;\r\n        }\r\n        const v = value as [number, number, number] | Int32Array;\r\n        return `ivec3(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])})`;\r\n      }\r\n      case \"vec3\": {\r\n        if (value instanceof THREE.Vector3) {\r\n          return `vec3(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)})`;\r\n        }\r\n        const v = value as [number, number, number] | Float32Array;\r\n        return `vec3(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])})`;\r\n      }\r\n      case \"bvec4\": {\r\n        const v = value as [boolean, boolean, boolean, boolean];\r\n        return `bvec4(${v[0]}, ${v[1]}, ${v[2]}, ${v[3]})`;\r\n      }\r\n      case \"uvec4\": {\r\n        if (value instanceof THREE.Vector4) {\r\n          return `uvec4(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)}, ${numberAsUint(value.w)})`;\r\n        }\r\n        const v = value as [number, number, number, number] | Uint32Array;\r\n        return `uvec4(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])}, ${numberAsUint(v[3])})`;\r\n      }\r\n      case \"ivec4\": {\r\n        if (value instanceof THREE.Vector4) {\r\n          return `ivec4(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)}, ${numberAsInt(value.w)})`;\r\n        }\r\n        const v = value as [number, number, number, number] | Int32Array;\r\n        return `ivec4(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])}, ${numberAsInt(v[3])})`;\r\n      }\r\n      case \"vec4\": {\r\n        if (value instanceof THREE.Vector4) {\r\n          return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\r\n        }\r\n        if (value instanceof THREE.Quaternion) {\r\n          return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\r\n        }\r\n        const v = value as [number, number, number, number] | Float32Array;\r\n        return `vec4(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])}, ${numberAsFloat(v[3])})`;\r\n      }\r\n      case \"mat2\":\r\n      case \"mat2x2\": {\r\n        const m = value as DynoJsType<\"mat2\">;\r\n        const e =\r\n          m instanceof THREE.Matrix2 ? m.elements : (value as Float32Array);\r\n        const arg = new Array(4).fill(0).map((_, i) => numberAsFloat(e[i]));\r\n        return `${type as string}(${arg.join(\", \")})`;\r\n      }\r\n      case \"mat2x3\": {\r\n        const e = value as DynoJsType<\"mat2x3\">;\r\n        const arg = new Array(6).fill(0).map((_, i) => numberAsFloat(e[i]));\r\n        return `${type as string}(${arg.join(\", \")})`;\r\n      }\r\n      case \"mat2x4\": {\r\n        const e = value as DynoJsType<\"mat2x4\">;\r\n        const arg = new Array(8).fill(0).map((_, i) => numberAsFloat(e[i]));\r\n        return `${type as string}(${arg.join(\", \")})`;\r\n      }\r\n      case \"mat3\":\r\n      case \"mat3x3\": {\r\n        const m = value as DynoJsType<\"mat3\">;\r\n        const e =\r\n          m instanceof THREE.Matrix3 ? m.elements : (value as Float32Array);\r\n        const arg = new Array(9).fill(0).map((_, i) => numberAsFloat(e[i]));\r\n        return `${type as string}(${arg.join(\", \")})`;\r\n      }\r\n      case \"mat3x2\": {\r\n        const e = value as DynoJsType<\"mat3x2\">;\r\n        const arg = new Array(6).fill(0).map((_, i) => numberAsFloat(e[i]));\r\n        return `${type as string}(${arg.join(\", \")})`;\r\n      }\r\n      case \"mat3x4\": {\r\n        const e = value as DynoJsType<\"mat3x4\">;\r\n        const arg = new Array(12).fill(0).map((_, i) => numberAsFloat(e[i]));\r\n        return `${type as string}(${arg.join(\", \")})`;\r\n      }\r\n      case \"mat4\":\r\n      case \"mat4x4\": {\r\n        const m = value as DynoJsType<\"mat4\">;\r\n        const e =\r\n          m instanceof THREE.Matrix4 ? m.elements : (value as Float32Array);\r\n        const arg = new Array(16).fill(0).map((_, i) => numberAsFloat(e[i]));\r\n        return `${type as string}(${arg.join(\", \")})`;\r\n      }\r\n      case \"mat4x2\": {\r\n        const e = value as DynoJsType<\"mat4x2\">;\r\n        const arg = new Array(8).fill(0).map((_, i) => numberAsFloat(e[i]));\r\n        return `${type as string}(${arg.join(\", \")})`;\r\n      }\r\n      case \"mat4x3\": {\r\n        const e = value as DynoJsType<\"mat4x3\">;\r\n        const arg = new Array(12).fill(0).map((_, i) => numberAsFloat(e[i]));\r\n        return `${type as string}(${arg.join(\", \")})`;\r\n      }\r\n      default:\r\n        throw new Error(`Type not implemented: ${String(type)}`);\r\n    }\r\n  }\r\n}\r\n\r\nexport function dynoConst<T extends DynoType>(\r\n  type: T,\r\n  value: DynoJsType<T>,\r\n): DynoConst<T> {\r\n  return new DynoConst(type, value);\r\n}\r\n\r\nexport function literalZero(type: SimpleTypes): string {\r\n  const typeString = String(type);\r\n  if (isBoolType(type)) {\r\n    return `${typeString}(false)`;\r\n  }\r\n  if (isAllFloatType(type)) {\r\n    return `${typeString}(0.0)`;\r\n  }\r\n  if (isIntType(type)) {\r\n    return `${typeString}(0)`;\r\n  }\r\n  if (isUintType(type)) {\r\n    return `${typeString}(0u)`;\r\n  }\r\n  throw new Error(`Type not implemented: ${typeString}`);\r\n}\r\n\r\nexport function literalOne(type: SimpleTypes): string {\r\n  const typeString = String(type);\r\n  if (isBoolType(type)) {\r\n    return `${typeString}(true)`;\r\n  }\r\n  if (isAllFloatType(type)) {\r\n    return `${typeString}(1.0)`;\r\n  }\r\n  if (isIntType(type)) {\r\n    return `${typeString}(1)`;\r\n  }\r\n  if (isUintType(type)) {\r\n    return `${typeString}(1u)`;\r\n  }\r\n  throw new Error(`Type not implemented: ${typeString}`);\r\n}\r\n\r\nexport function literalNegOne(type: SimpleTypes): string {\r\n  const typeString = String(type);\r\n  if (isBoolType(type)) {\r\n    return `${typeString}(true)`;\r\n  }\r\n  if (isAllFloatType(type)) {\r\n    return `${typeString}(-1.0)`;\r\n  }\r\n  if (isIntType(type)) {\r\n    return `${typeString}(-1)`;\r\n  }\r\n  if (isUintType(type)) {\r\n    return `${typeString}(0xFFFFFFFFu)`;\r\n  }\r\n  throw new Error(`Type not implemented: ${typeString}`);\r\n}\r\n","import type { IUniform } from \"three\";\r\nimport type { DynoType } from \"./types\";\r\nimport {\r\n  DynoLiteral,\r\n  DynoOutput,\r\n  type DynoVal,\r\n  DynoValue,\r\n  type HasDynoOut,\r\n  valType,\r\n} from \"./value\";\r\n\r\nconst DEFAULT_INDENT = \"    \";\r\n\r\nexport class Compilation {\r\n  globals: Set<string> = new Set();\r\n  statements: string[] = [];\r\n  uniforms: Record<string, IUniform> = {};\r\n  declares: Set<string> = new Set();\r\n  updaters: (() => void)[] = [];\r\n  sequence = 0;\r\n  indent: string = DEFAULT_INDENT;\r\n\r\n  constructor({ indent }: { indent?: string } = {}) {\r\n    this.indent = indent ?? DEFAULT_INDENT;\r\n  }\r\n\r\n  nextSequence() {\r\n    return this.sequence++;\r\n  }\r\n}\r\n\r\nexport type IOTypes = Record<string, DynoType>;\r\ntype GenerateContext<InTypes extends IOTypes, OutTypes extends IOTypes> = {\r\n  inputs: { [K in keyof InTypes]?: string };\r\n  outputs: { [K in keyof OutTypes]?: string };\r\n  compile: Compilation;\r\n};\r\n\r\nexport class Dyno<InTypes extends IOTypes, OutTypes extends IOTypes> {\r\n  inTypes: InTypes;\r\n  outTypes: OutTypes;\r\n\r\n  inputs: { [K in keyof InTypes]?: DynoVal<InTypes[K]> };\r\n  update?: () => void;\r\n  globals?: ({\r\n    inputs,\r\n    outputs,\r\n    compile,\r\n  }: GenerateContext<InTypes, OutTypes>) => string[];\r\n  statements?: ({\r\n    inputs,\r\n    outputs,\r\n    compile,\r\n  }: GenerateContext<InTypes, OutTypes>) => string[];\r\n  generate: ({\r\n    inputs,\r\n    outputs,\r\n    compile,\r\n  }: GenerateContext<InTypes, OutTypes>) => {\r\n    globals?: string[];\r\n    statements?: string[];\r\n    uniforms?: Record<string, IUniform>;\r\n  };\r\n\r\n  constructor({\r\n    inTypes,\r\n    outTypes,\r\n    inputs,\r\n    update,\r\n    globals,\r\n    statements,\r\n    generate,\r\n  }: {\r\n    inTypes?: InTypes;\r\n    outTypes?: OutTypes;\r\n    inputs?: { [K in keyof InTypes]?: DynoVal<InTypes[K]> };\r\n    update?: () => void;\r\n    globals?: ({\r\n      inputs,\r\n      outputs,\r\n      compile,\r\n    }: GenerateContext<InTypes, OutTypes>) => string[];\r\n    statements?: ({\r\n      inputs,\r\n      outputs,\r\n      compile,\r\n    }: GenerateContext<InTypes, OutTypes>) => string[];\r\n    generate?: ({\r\n      inputs,\r\n      outputs,\r\n      compile,\r\n    }: GenerateContext<InTypes, OutTypes>) => {\r\n      globals?: string[];\r\n      statements?: string[];\r\n      uniforms?: Record<string, IUniform>;\r\n    };\r\n  }) {\r\n    this.inTypes = inTypes ?? ({} as InTypes);\r\n    this.outTypes = outTypes ?? ({} as OutTypes);\r\n    this.inputs = inputs ?? {};\r\n    this.update = update;\r\n\r\n    this.globals = globals;\r\n    this.statements = statements;\r\n    this.generate =\r\n      generate ??\r\n      (({ inputs, outputs, compile }) => {\r\n        return {\r\n          globals: this.globals?.({ inputs, outputs, compile }),\r\n          statements: this.statements?.({ inputs, outputs, compile }),\r\n        };\r\n      });\r\n  }\r\n\r\n  get outputs(): { [K in keyof OutTypes]: DynoVal<OutTypes[K]> } {\r\n    const outputs = {} as { [K in keyof OutTypes]: DynoVal<OutTypes[K]> };\r\n    for (const key in this.outTypes) {\r\n      outputs[key] = new DynoOutput(this, key);\r\n    }\r\n    return outputs;\r\n  }\r\n\r\n  apply(inputs: { [K in keyof InTypes]?: DynoVal<InTypes[K]> }): {\r\n    [K in keyof OutTypes]: DynoVal<OutTypes[K]>;\r\n  } {\r\n    Object.assign(this.inputs, inputs);\r\n    return this.outputs;\r\n  }\r\n\r\n  compile({\r\n    inputs,\r\n    outputs,\r\n    compile,\r\n  }: {\r\n    inputs: { [K in keyof InTypes]?: string };\r\n    outputs: { [K in keyof OutTypes]?: string };\r\n    compile: Compilation;\r\n  }): string[] {\r\n    const result = [\r\n      `// ${this.constructor.name}(${Object.values(inputs).join(\", \")}) => (${Object.values(outputs).join(\", \")})`,\r\n    ];\r\n\r\n    const declares: (keyof OutTypes)[] = [];\r\n    for (const key in outputs) {\r\n      const name = outputs[key];\r\n      if (name && !compile.declares.has(name)) {\r\n        compile.declares.add(name);\r\n        declares.push(key);\r\n      }\r\n    }\r\n\r\n    const { globals, statements, uniforms } = this.generate({\r\n      inputs,\r\n      outputs,\r\n      compile,\r\n    });\r\n    for (const global of globals ?? []) {\r\n      compile.globals.add(global);\r\n    }\r\n    for (const key in uniforms) {\r\n      compile.uniforms[key] = uniforms[key];\r\n    }\r\n    if (this.update) {\r\n      compile.updaters.push(this.update);\r\n    }\r\n\r\n    for (const key of declares) {\r\n      const name = outputs[key];\r\n      if (name) {\r\n        if (!compile.uniforms[name]) {\r\n          result.push(`${dynoDeclare(name, this.outTypes[key])};`);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (statements?.length) {\r\n      result.push(\"{\");\r\n      result.push(...statements.map((line) => compile.indent + line));\r\n      result.push(\"}\");\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\nexport type DynoBlockType<InTypes extends IOTypes, OutTypes extends IOTypes> = (\r\n  inputs: { [K in keyof InTypes]?: DynoVal<InTypes[K]> },\r\n  outputs: { [K in keyof OutTypes]?: DynoVal<OutTypes[K]> },\r\n  { roots }: { roots: Dyno<InTypes, OutTypes>[] },\r\n) => { [K in keyof OutTypes]?: DynoVal<OutTypes[K]> } | undefined;\r\n\r\nexport class DynoBlock<\r\n  InTypes extends IOTypes,\r\n  OutTypes extends IOTypes,\r\n> extends Dyno<InTypes, OutTypes> {\r\n  construct: DynoBlockType<InTypes, OutTypes>;\r\n\r\n  constructor({\r\n    inTypes,\r\n    outTypes,\r\n    inputs,\r\n    update,\r\n    globals,\r\n    construct,\r\n  }: {\r\n    inTypes?: InTypes;\r\n    outTypes?: OutTypes;\r\n    inputs?: { [K in keyof InTypes]?: DynoVal<InTypes[K]> };\r\n    update?: () => void;\r\n    globals?: ({\r\n      inputs,\r\n      outputs,\r\n      compile,\r\n    }: GenerateContext<InTypes, OutTypes>) => string[];\r\n    construct: DynoBlockType<InTypes, OutTypes>;\r\n  }) {\r\n    super({\r\n      inTypes,\r\n      outTypes,\r\n      inputs,\r\n      update,\r\n      globals,\r\n      generate: (args) => this.generateBlock(args),\r\n    });\r\n    this.construct = construct;\r\n  }\r\n\r\n  generateBlock({\r\n    inputs,\r\n    outputs,\r\n    compile,\r\n  }: {\r\n    inputs: { [K in keyof InTypes]?: string };\r\n    outputs: { [K in keyof OutTypes]?: string };\r\n    compile: Compilation;\r\n  }) {\r\n    const blockInputs: { [K in keyof InTypes]?: DynoVal<InTypes[K]> } = {};\r\n    const blockOutputs: { [K in keyof OutTypes]?: DynoVal<OutTypes[K]> } = {};\r\n\r\n    for (const key in inputs) {\r\n      if (inputs[key] != null) {\r\n        blockInputs[key] = new DynoLiteral(this.inTypes[key], inputs[key]);\r\n      }\r\n    }\r\n    for (const key in outputs) {\r\n      if (outputs[key] != null) {\r\n        blockOutputs[key] = new DynoValue(this.outTypes[key]);\r\n      }\r\n    }\r\n\r\n    const options = { roots: [] };\r\n    const returned = this.construct(blockInputs, blockOutputs, options);\r\n\r\n    for (const global of this.globals?.({ inputs, outputs, compile }) ?? []) {\r\n      compile.globals.add(global);\r\n    }\r\n\r\n    const ordering: Dyno<IOTypes, IOTypes>[] = [];\r\n    const nodeOuts = new Map<\r\n      Dyno<IOTypes, IOTypes>,\r\n      { sequence: number; outNames: Map<string, string>; newOuts: Set<string> }\r\n    >();\r\n\r\n    function visit(\r\n      node: Dyno<IOTypes, IOTypes>,\r\n      outKey?: string,\r\n      outName?: string,\r\n    ) {\r\n      let outs = nodeOuts.get(node);\r\n      if (!outs) {\r\n        // First time visiting this node\r\n        outs = {\r\n          sequence: compile.nextSequence(),\r\n          outNames: new Map(),\r\n          newOuts: new Set(),\r\n        };\r\n        nodeOuts.set(node, outs);\r\n\r\n        for (const key in node.inputs) {\r\n          let input = node.inputs[key];\r\n          while (input) {\r\n            if (input instanceof DynoValue) {\r\n              if (input instanceof DynoOutput) {\r\n                visit(input.dyno, input.key);\r\n              }\r\n              break;\r\n            }\r\n            // Must be as HasDynoOut<T>\r\n            input = input.dynoOut();\r\n          }\r\n        }\r\n        ordering.push(node);\r\n      }\r\n      if (outKey) {\r\n        if (!outName) {\r\n          outs.newOuts.add(outKey);\r\n        }\r\n        outs.outNames.set(outKey, outName ?? `${outKey}_${outs.sequence}`);\r\n      }\r\n    }\r\n\r\n    for (const root of options.roots) {\r\n      visit(root);\r\n    }\r\n\r\n    for (const key in blockOutputs) {\r\n      let value = returned?.[key] ?? blockOutputs[key];\r\n      while (value) {\r\n        if (value instanceof DynoValue) {\r\n          if (value instanceof DynoOutput) {\r\n            visit(value.dyno, value.key, outputs[key]);\r\n          }\r\n          break;\r\n        }\r\n        // Must be as HasDynoOut<T>\r\n        value = value.dynoOut();\r\n      }\r\n      blockOutputs[key] = value;\r\n    }\r\n\r\n    const steps = [];\r\n\r\n    for (const dyno of ordering) {\r\n      // compile.statements.push(`// ${dyno.constructor.name}(${Object.values(inputs).join(\", \")}) => (${Object.values(outputs).join(\", \")})`);\r\n\r\n      const inputs: Record<string, string> = {};\r\n      const outputs: Record<string, string> = {};\r\n\r\n      for (const key in dyno.inputs) {\r\n        let value = dyno.inputs[key];\r\n        while (value) {\r\n          if (value instanceof DynoValue) {\r\n            if (value instanceof DynoLiteral) {\r\n              inputs[key] = value.getLiteral();\r\n            } else if (value instanceof DynoOutput) {\r\n              const source = nodeOuts.get(value.dyno)?.outNames.get(value.key);\r\n              if (!source) {\r\n                throw new Error(\r\n                  `Source not found for ${value.dyno.constructor.name}.${value.key}`,\r\n                );\r\n              }\r\n              inputs[key] = source;\r\n            }\r\n            break;\r\n          }\r\n          // Must be as HasDynOut<T>\r\n          value = value.dynoOut();\r\n        }\r\n      }\r\n\r\n      const outs = nodeOuts.get(dyno) ?? { outNames: new Map() };\r\n      for (const [key, name] of outs.outNames.entries()) {\r\n        outputs[key] = name;\r\n      }\r\n\r\n      const newSteps = dyno.compile({ inputs, outputs, compile });\r\n      steps.push(newSteps);\r\n    }\r\n\r\n    const literalOutputs = [];\r\n    for (const key in outputs) {\r\n      if (blockOutputs[key] instanceof DynoLiteral) {\r\n        literalOutputs.push(\r\n          `${outputs[key]} = ${blockOutputs[key].getLiteral()};`,\r\n        );\r\n      }\r\n    }\r\n    if (literalOutputs.length > 0) {\r\n      steps.push(literalOutputs);\r\n    }\r\n\r\n    const statements = steps.flatMap((step, index) => {\r\n      // Add a blank line between steps\r\n      return index === 0 ? step : [\"\", ...step];\r\n    });\r\n    return { statements };\r\n  }\r\n}\r\n\r\nexport function dynoBlock<\r\n  InTypes extends Record<string, DynoType>,\r\n  OutTypes extends Record<string, DynoType>,\r\n>(\r\n  inTypes: InTypes,\r\n  outTypes: OutTypes,\r\n  construct: DynoBlockType<InTypes, OutTypes>,\r\n  { update, globals }: { update?: () => void; globals?: () => string[] } = {},\r\n) {\r\n  return new DynoBlock({ inTypes, outTypes, construct, update, globals });\r\n}\r\n\r\nexport function dyno<\r\n  InTypes extends Record<string, DynoType>,\r\n  OutTypes extends Record<string, DynoType>,\r\n>({\r\n  inTypes,\r\n  outTypes,\r\n  inputs,\r\n  update,\r\n  globals,\r\n  statements,\r\n  generate,\r\n}: {\r\n  inTypes: InTypes;\r\n  outTypes: OutTypes;\r\n  inputs?: { [K in keyof InTypes]?: DynoVal<InTypes[K]> };\r\n  update?: () => void;\r\n  globals?: ({\r\n    inputs,\r\n    outputs,\r\n    compile,\r\n  }: GenerateContext<InTypes, OutTypes>) => string[];\r\n  statements?: ({\r\n    inputs,\r\n    outputs,\r\n    compile,\r\n  }: GenerateContext<InTypes, OutTypes>) => string[];\r\n  generate?: ({\r\n    inputs,\r\n    outputs,\r\n    compile,\r\n  }: GenerateContext<InTypes, OutTypes>) => {\r\n    globals?: string[];\r\n    statements?: string[];\r\n    uniforms?: Record<string, IUniform>;\r\n  };\r\n}) {\r\n  return new Dyno({\r\n    inTypes,\r\n    outTypes,\r\n    inputs,\r\n    update,\r\n    globals,\r\n    statements,\r\n    generate,\r\n  });\r\n}\r\n\r\nexport function dynoDeclare(name: string, type: DynoType, count?: number) {\r\n  const typeStr = typeof type === \"string\" ? type : type.type;\r\n  if (!typeStr) {\r\n    throw new Error(`Invalid DynoType: ${String(type)}`);\r\n  }\r\n  return `${typeStr} ${name}${count != null ? `[${count}]` : \"\"}`;\r\n}\r\n\r\nexport function unindentLines(s: string): string[] {\r\n  let seenNonEmpty = false;\r\n  const lines = s\r\n    .split(\"\\n\")\r\n    .map((line) => {\r\n      const trimmedLine = line.trimEnd();\r\n      if (seenNonEmpty) {\r\n        return trimmedLine;\r\n      }\r\n      if (trimmedLine.length > 0) {\r\n        seenNonEmpty = true;\r\n        return trimmedLine;\r\n      }\r\n      return null;\r\n    })\r\n    .filter((line) => line != null);\r\n  while (lines.length > 0 && lines[lines.length - 1].length === 0) {\r\n    lines.pop();\r\n  }\r\n  if (lines.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  const indent = lines[0].match(/^\\s*/)?.[0];\r\n  if (!indent) {\r\n    return lines; // No indent, return as is\r\n  }\r\n  // Remove indent from the beginning of each line\r\n  const regex = new RegExp(`^${indent}`);\r\n  return lines.map((line) => line.replace(regex, \"\"));\r\n}\r\n\r\nexport function unindent(s: string): string {\r\n  return unindentLines(s).join(\"\\n\");\r\n}\r\n\r\nexport class UnaryOp<\r\n    A extends DynoType,\r\n    OutType extends DynoType,\r\n    OutKey extends string,\r\n  >\r\n  extends Dyno<{ a: A }, { [key in OutKey]: OutType }>\r\n  implements HasDynoOut<OutType>\r\n{\r\n  constructor({\r\n    a,\r\n    outKey,\r\n    outTypeFunc,\r\n  }: { a: DynoVal<A>; outKey: OutKey; outTypeFunc: (aType: A) => OutType }) {\r\n    const inTypes = { a: valType(a) };\r\n    const outType = outTypeFunc(valType(a));\r\n    const outTypes = { [outKey]: outType } as { [key in OutKey]: OutType };\r\n    super({ inTypes, outTypes, inputs: { a } });\r\n    this.outKey = outKey;\r\n  }\r\n\r\n  outKey: OutKey;\r\n  dynoOut(): DynoValue<OutType> {\r\n    return new DynoOutput(this, this.outKey);\r\n  }\r\n}\r\n\r\nexport class BinaryOp<\r\n    A extends DynoType,\r\n    B extends DynoType,\r\n    OutType extends DynoType,\r\n    OutKey extends string,\r\n  >\r\n  extends Dyno<{ a: A; b: B }, { [key in OutKey]: OutType }>\r\n  implements HasDynoOut<OutType>\r\n{\r\n  constructor({\r\n    a,\r\n    b,\r\n    outKey,\r\n    outTypeFunc,\r\n  }: {\r\n    a: DynoVal<A>;\r\n    b: DynoVal<B>;\r\n    outKey: OutKey;\r\n    outTypeFunc: (aType: A, bType: B) => OutType;\r\n  }) {\r\n    const inTypes = { a: valType(a), b: valType(b) };\r\n    const outType = outTypeFunc(valType(a), valType(b));\r\n    const outTypes = { [outKey]: outType } as { [key in OutKey]: OutType };\r\n    super({ inTypes, outTypes, inputs: { a, b } });\r\n    this.outKey = outKey;\r\n  }\r\n\r\n  outKey: OutKey;\r\n  dynoOut(): DynoValue<OutType> {\r\n    return new DynoOutput(this, this.outKey);\r\n  }\r\n}\r\n\r\nexport class TrinaryOp<\r\n    A extends DynoType,\r\n    B extends DynoType,\r\n    C extends DynoType,\r\n    OutType extends DynoType,\r\n    OutKey extends string,\r\n  >\r\n  extends Dyno<{ a: A; b: B; c: C }, { [key in OutKey]: OutType }>\r\n  implements HasDynoOut<OutType>\r\n{\r\n  constructor({\r\n    a,\r\n    b,\r\n    c,\r\n    outKey,\r\n    outTypeFunc,\r\n  }: {\r\n    a: DynoVal<A>;\r\n    b: DynoVal<B>;\r\n    c: DynoVal<C>;\r\n    outKey: OutKey;\r\n    outTypeFunc: (aType: A, bType: B, cType: C) => OutType;\r\n  }) {\r\n    const inTypes = { a: valType(a), b: valType(b), c: valType(c) };\r\n    const outType = outTypeFunc(valType(a), valType(b), valType(c));\r\n    const outTypes = { [outKey]: outType } as { [key in OutKey]: OutType };\r\n    super({ inTypes, outTypes, inputs: { a, b, c } });\r\n    this.outKey = outKey;\r\n  }\r\n\r\n  outKey: OutKey;\r\n  dynoOut(): DynoValue<OutType> {\r\n    return new DynoOutput(this, this.outKey);\r\n  }\r\n}\r\n","import { Dyno, UnaryOp, unindent, unindentLines } from \"./base\";\r\nimport {\r\n  DynoOutput,\r\n  type DynoVal,\r\n  type DynoValue,\r\n  type HasDynoOut,\r\n} from \"./value\";\r\n\r\nexport const Gsplat = { type: \"Gsplat\" } as { type: \"Gsplat\" };\r\nexport const TPackedSplats = { type: \"PackedSplats\" } as {\r\n  type: \"PackedSplats\";\r\n};\r\n\r\nexport const numPackedSplats = (\r\n  packedSplats: DynoVal<typeof TPackedSplats>,\r\n): DynoVal<\"int\"> => new NumPackedSplats({ packedSplats });\r\nexport const readPackedSplat = (\r\n  packedSplats: DynoVal<typeof TPackedSplats>,\r\n  index: DynoVal<\"int\">,\r\n): DynoVal<typeof Gsplat> => new ReadPackedSplat({ packedSplats, index });\r\nexport const readPackedSplatRange = (\r\n  packedSplats: DynoVal<typeof TPackedSplats>,\r\n  index: DynoVal<\"int\">,\r\n  base: DynoVal<\"int\">,\r\n  count: DynoVal<\"int\">,\r\n): DynoVal<typeof Gsplat> =>\r\n  new ReadPackedSplatRange({ packedSplats, index, base, count });\r\nexport const splitGsplat = (gsplat: DynoVal<typeof Gsplat>) =>\r\n  new SplitGsplat({ gsplat });\r\nexport const combineGsplat = ({\r\n  gsplat,\r\n  flags,\r\n  index,\r\n  center,\r\n  scales,\r\n  quaternion,\r\n  rgba,\r\n  rgb,\r\n  opacity,\r\n  x,\r\n  y,\r\n  z,\r\n  r,\r\n  g,\r\n  b,\r\n}: {\r\n  gsplat?: DynoVal<typeof Gsplat>;\r\n  flags?: DynoVal<\"uint\">;\r\n  index?: DynoVal<\"int\">;\r\n  center?: DynoVal<\"vec3\">;\r\n  scales?: DynoVal<\"vec3\">;\r\n  quaternion?: DynoVal<\"vec4\">;\r\n  rgba?: DynoVal<\"vec4\">;\r\n  rgb?: DynoVal<\"vec3\">;\r\n  opacity?: DynoVal<\"float\">;\r\n  x?: DynoVal<\"float\">;\r\n  y?: DynoVal<\"float\">;\r\n  z?: DynoVal<\"float\">;\r\n  r?: DynoVal<\"float\">;\r\n  g?: DynoVal<\"float\">;\r\n  b?: DynoVal<\"float\">;\r\n}): DynoVal<typeof Gsplat> => {\r\n  return new CombineGsplat({\r\n    gsplat,\r\n    flags,\r\n    index,\r\n    center,\r\n    scales,\r\n    quaternion,\r\n    rgba,\r\n    rgb,\r\n    opacity,\r\n    x,\r\n    y,\r\n    z,\r\n    r,\r\n    g,\r\n    b,\r\n  });\r\n};\r\nexport const gsplatNormal = (gsplat: DynoVal<typeof Gsplat>): DynoVal<\"vec3\"> =>\r\n  new GsplatNormal({ gsplat });\r\n\r\nexport const transformGsplat = (\r\n  gsplat: DynoVal<typeof Gsplat>,\r\n  {\r\n    scale,\r\n    rotate,\r\n    translate,\r\n    recolor,\r\n  }: {\r\n    scale?: DynoVal<\"float\">;\r\n    rotate?: DynoVal<\"vec4\">;\r\n    translate?: DynoVal<\"vec3\">;\r\n    recolor?: DynoVal<\"vec4\">;\r\n  },\r\n): DynoVal<typeof Gsplat> => {\r\n  return new TransformGsplat({ gsplat, scale, rotate, translate, recolor });\r\n};\r\n\r\nexport const defineGsplat = unindent(`\r\n  struct Gsplat {\r\n    vec3 center;\r\n    uint flags;\r\n    vec3 scales;\r\n    int index;\r\n    vec4 quaternion;\r\n    vec4 rgba;\r\n  };\r\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\r\n\r\n  bool isGsplatActive(uint flags) {\r\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\r\n  }\r\n`);\r\n\r\nexport const definePackedSplats = unindent(`\r\n  struct PackedSplats {\r\n    usampler2DArray texture;\r\n    int numSplats;\r\n    vec4 rgbMinMaxLnScaleMinMax;\r\n  };\r\n`);\r\n\r\nexport class NumPackedSplats extends UnaryOp<\r\n  typeof TPackedSplats,\r\n  \"int\",\r\n  \"numSplats\"\r\n> {\r\n  constructor({\r\n    packedSplats,\r\n  }: { packedSplats: DynoVal<typeof TPackedSplats> }) {\r\n    super({ a: packedSplats, outKey: \"numSplats\", outTypeFunc: () => \"int\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.numSplats} = ${inputs.a}.numSplats;`,\r\n    ];\r\n  }\r\n}\r\n\r\nconst defineReadPackedSplat = unindent(`\r\n  bool readPackedSplat(usampler2DArray texture, int numSplats, vec4 rgbMinMaxLnScaleMinMax, int index, out Gsplat gsplat) {\r\n    if ((index >= 0) && (index < numSplats)) {\r\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\r\n      unpackSplatEncoding(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba, rgbMinMaxLnScaleMinMax);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n`);\r\n\r\nexport class ReadPackedSplat\r\n  extends Dyno<\r\n    { packedSplats: typeof TPackedSplats; index: \"int\" },\r\n    { gsplat: typeof Gsplat }\r\n  >\r\n  implements HasDynoOut<typeof Gsplat>\r\n{\r\n  constructor({\r\n    packedSplats,\r\n    index,\r\n  }: { packedSplats?: DynoVal<typeof TPackedSplats>; index?: DynoVal<\"int\"> }) {\r\n    super({\r\n      inTypes: { packedSplats: TPackedSplats, index: \"int\" },\r\n      outTypes: { gsplat: Gsplat },\r\n      inputs: { packedSplats, index },\r\n      globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\r\n      statements: ({ inputs, outputs }) => {\r\n        const { gsplat } = outputs;\r\n        if (!gsplat) {\r\n          return [];\r\n        }\r\n        const { packedSplats, index } = inputs;\r\n        let statements: string[];\r\n        if (packedSplats && index) {\r\n          statements = unindentLines(`\r\n            if (readPackedSplat(${packedSplats}.texture, ${packedSplats}.numSplats, ${packedSplats}.rgbMinMaxLnScaleMinMax, ${index}, ${gsplat})) {\r\n              bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\r\n              ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\r\n            } else {\r\n              ${gsplat}.flags = 0u;\r\n            }\r\n          `);\r\n        } else {\r\n          statements = [`${gsplat}.flags = 0u;`];\r\n        }\r\n        statements.push(`${gsplat}.index = ${index ?? \"0\"};`);\r\n        return statements;\r\n      },\r\n    });\r\n  }\r\n\r\n  dynoOut(): DynoValue<typeof Gsplat> {\r\n    return new DynoOutput(this, \"gsplat\");\r\n  }\r\n}\r\n\r\nexport class ReadPackedSplatRange\r\n  extends Dyno<\r\n    {\r\n      packedSplats: typeof TPackedSplats;\r\n      index: \"int\";\r\n      base: \"int\";\r\n      count: \"int\";\r\n    },\r\n    { gsplat: typeof Gsplat }\r\n  >\r\n  implements HasDynoOut<typeof Gsplat>\r\n{\r\n  constructor({\r\n    packedSplats,\r\n    index,\r\n    base,\r\n    count,\r\n  }: {\r\n    packedSplats?: DynoVal<typeof TPackedSplats>;\r\n    index?: DynoVal<\"int\">;\r\n    base?: DynoVal<\"int\">;\r\n    count?: DynoVal<\"int\">;\r\n  }) {\r\n    super({\r\n      inTypes: {\r\n        packedSplats: TPackedSplats,\r\n        index: \"int\",\r\n        base: \"int\",\r\n        count: \"int\",\r\n      },\r\n      outTypes: { gsplat: Gsplat },\r\n      inputs: { packedSplats, index, base, count },\r\n      globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\r\n      statements: ({ inputs, outputs }) => {\r\n        const { gsplat } = outputs;\r\n        if (!gsplat) {\r\n          return [];\r\n        }\r\n        const { packedSplats, index, base, count } = inputs;\r\n        let statements: string[];\r\n        if (packedSplats && index && base && count) {\r\n          statements = unindentLines(`\r\n            ${gsplat}.flags = 0u;\r\n            if ((${index} >= ${base}) && (${index} < (${base} + ${count}))) {\r\n              if (readPackedSplat(${packedSplats}.texture, ${packedSplats}.numSplats, ${packedSplats}.rgbMinMaxLnScaleMinMax, ${index}, ${gsplat})) {\r\n                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\r\n                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\r\n              }\r\n            }\r\n          `);\r\n        } else {\r\n          statements = [`${gsplat}.flags = 0u;`];\r\n        }\r\n        statements.push(`${gsplat}.index = ${index ?? \"0\"};`);\r\n        return statements;\r\n      },\r\n    });\r\n  }\r\n\r\n  dynoOut(): DynoValue<typeof Gsplat> {\r\n    return new DynoOutput(this, \"gsplat\");\r\n  }\r\n}\r\n\r\nexport class SplitGsplat extends Dyno<\r\n  { gsplat: typeof Gsplat },\r\n  {\r\n    flags: \"uint\";\r\n    active: \"bool\";\r\n    index: \"int\";\r\n    center: \"vec3\";\r\n    scales: \"vec3\";\r\n    quaternion: \"vec4\";\r\n    rgba: \"vec4\";\r\n    rgb: \"vec3\";\r\n    opacity: \"float\";\r\n    x: \"float\";\r\n    y: \"float\";\r\n    z: \"float\";\r\n    r: \"float\";\r\n    g: \"float\";\r\n    b: \"float\";\r\n  }\r\n> {\r\n  constructor({ gsplat }: { gsplat?: DynoVal<typeof Gsplat> }) {\r\n    super({\r\n      inTypes: { gsplat: Gsplat },\r\n      outTypes: {\r\n        flags: \"uint\",\r\n        active: \"bool\",\r\n        index: \"int\",\r\n        center: \"vec3\",\r\n        scales: \"vec3\",\r\n        quaternion: \"vec4\",\r\n        rgba: \"vec4\",\r\n        rgb: \"vec3\",\r\n        opacity: \"float\",\r\n        x: \"float\",\r\n        y: \"float\",\r\n        z: \"float\",\r\n        r: \"float\",\r\n        g: \"float\",\r\n        b: \"float\",\r\n      },\r\n      inputs: { gsplat },\r\n      globals: () => [defineGsplat],\r\n      statements: ({ inputs, outputs }) => {\r\n        const { gsplat } = inputs;\r\n        const {\r\n          flags,\r\n          active,\r\n          index,\r\n          center,\r\n          scales,\r\n          quaternion,\r\n          rgba,\r\n          rgb,\r\n          opacity,\r\n          x,\r\n          y,\r\n          z,\r\n          r,\r\n          g,\r\n          b,\r\n        } = outputs;\r\n        return [\r\n          !flags ? null : `${flags} = ${gsplat ? `${gsplat}.flags` : \"0u\"};`,\r\n          !active\r\n            ? null\r\n            : `${active} = isGsplatActive(${gsplat ? `${gsplat}.flags` : \"0u\"});`,\r\n          !index ? null : `${index} = ${gsplat ? `${gsplat}.index` : \"0\"};`,\r\n          !center\r\n            ? null\r\n            : `${center} = ${gsplat ? `${gsplat}.center` : \"vec3(0.0, 0.0, 0.0)\"};`,\r\n          !scales\r\n            ? null\r\n            : `${scales} = ${gsplat ? `${gsplat}.scales` : \"vec3(0.0, 0.0, 0.0)\"};`,\r\n          !quaternion\r\n            ? null\r\n            : `${quaternion} = ${gsplat ? `${gsplat}.quaternion` : \"vec4(0.0, 0.0, 0.0, 1.0)\"};`,\r\n          !rgba\r\n            ? null\r\n            : `${rgba} = ${gsplat ? `${gsplat}.rgba` : \"vec4(0.0, 0.0, 0.0, 0.0)\"};`,\r\n          !rgb\r\n            ? null\r\n            : `${rgb} = ${gsplat ? `${gsplat}.rgba.rgb` : \"vec3(0.0, 0.0, 0.0)\"};`,\r\n          !opacity\r\n            ? null\r\n            : `${opacity} = ${gsplat ? `${gsplat}.rgba.a` : \"0.0\"};`,\r\n          !x ? null : `${x} = ${gsplat ? `${gsplat}.center.x` : \"0.0\"};`,\r\n          !y ? null : `${y} = ${gsplat ? `${gsplat}.center.y` : \"0.0\"};`,\r\n          !z ? null : `${z} = ${gsplat ? `${gsplat}.center.z` : \"0.0\"};`,\r\n          !r ? null : `${r} = ${gsplat ? `${gsplat}.rgba.r` : \"0.0\"};`,\r\n          !g ? null : `${g} = ${gsplat ? `${gsplat}.rgba.g` : \"0.0\"};`,\r\n          !b ? null : `${b} = ${gsplat ? `${gsplat}.rgba.b` : \"0.0\"};`,\r\n        ].filter(Boolean) as string[];\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport class CombineGsplat\r\n  extends Dyno<\r\n    {\r\n      gsplat: typeof Gsplat;\r\n      flags: \"uint\";\r\n      index: \"int\";\r\n      center: \"vec3\";\r\n      scales: \"vec3\";\r\n      quaternion: \"vec4\";\r\n      rgba: \"vec4\";\r\n      rgb: \"vec3\";\r\n      opacity: \"float\";\r\n      x: \"float\";\r\n      y: \"float\";\r\n      z: \"float\";\r\n      r: \"float\";\r\n      g: \"float\";\r\n      b: \"float\";\r\n    },\r\n    { gsplat: typeof Gsplat }\r\n  >\r\n  implements HasDynoOut<typeof Gsplat>\r\n{\r\n  constructor({\r\n    gsplat,\r\n    flags,\r\n    index,\r\n    center,\r\n    scales,\r\n    quaternion,\r\n    rgba,\r\n    rgb,\r\n    opacity,\r\n    x,\r\n    y,\r\n    z,\r\n    r,\r\n    g,\r\n    b,\r\n  }: {\r\n    gsplat?: DynoVal<typeof Gsplat>;\r\n    flags?: DynoVal<\"uint\">;\r\n    index?: DynoVal<\"int\">;\r\n    center?: DynoVal<\"vec3\">;\r\n    scales?: DynoVal<\"vec3\">;\r\n    quaternion?: DynoVal<\"vec4\">;\r\n    rgba?: DynoVal<\"vec4\">;\r\n    rgb?: DynoVal<\"vec3\">;\r\n    opacity?: DynoVal<\"float\">;\r\n    x?: DynoVal<\"float\">;\r\n    y?: DynoVal<\"float\">;\r\n    z?: DynoVal<\"float\">;\r\n    r?: DynoVal<\"float\">;\r\n    g?: DynoVal<\"float\">;\r\n    b?: DynoVal<\"float\">;\r\n  }) {\r\n    super({\r\n      inTypes: {\r\n        gsplat: Gsplat,\r\n        flags: \"uint\",\r\n        index: \"int\",\r\n        center: \"vec3\",\r\n        scales: \"vec3\",\r\n        quaternion: \"vec4\",\r\n        rgba: \"vec4\",\r\n        rgb: \"vec3\",\r\n        opacity: \"float\",\r\n        x: \"float\",\r\n        y: \"float\",\r\n        z: \"float\",\r\n        r: \"float\",\r\n        g: \"float\",\r\n        b: \"float\",\r\n      },\r\n      outTypes: { gsplat: Gsplat },\r\n      inputs: {\r\n        gsplat,\r\n        flags,\r\n        index,\r\n        center,\r\n        scales,\r\n        quaternion,\r\n        rgba,\r\n        rgb,\r\n        opacity,\r\n        x,\r\n        y,\r\n        z,\r\n        r,\r\n        g,\r\n        b,\r\n      },\r\n      globals: () => [defineGsplat],\r\n      statements: ({ inputs, outputs }) => {\r\n        const { gsplat: outGsplat } = outputs;\r\n        if (!outGsplat) {\r\n          return [];\r\n        }\r\n        const {\r\n          gsplat,\r\n          flags,\r\n          index,\r\n          center,\r\n          scales,\r\n          quaternion,\r\n          rgba,\r\n          rgb,\r\n          opacity,\r\n          x,\r\n          y,\r\n          z,\r\n          r,\r\n          g,\r\n          b,\r\n        } = inputs;\r\n        return [\r\n          `${outGsplat}.flags = ${flags ?? (gsplat ? `${gsplat}.flags` : \"0u\")};`,\r\n          `${outGsplat}.index = ${index ?? (gsplat ? `${gsplat}.index` : \"0\")};`,\r\n          `${outGsplat}.center = ${center ?? (gsplat ? `${gsplat}.center` : \"vec3(0.0, 0.0, 0.0)\")};`,\r\n          `${outGsplat}.scales = ${scales ?? (gsplat ? `${gsplat}.scales` : \"vec3(0.0, 0.0, 0.0)\")};`,\r\n          `${outGsplat}.quaternion = ${quaternion ?? (gsplat ? `${gsplat}.quaternion` : \"vec4(0.0, 0.0, 0.0, 1.0)\")};`,\r\n          `${outGsplat}.rgba = ${rgba ?? (gsplat ? `${gsplat}.rgba` : \"vec4(0.0, 0.0, 0.0, 0.0)\")};`,\r\n          !rgb ? null : `${outGsplat}.rgba.rgb = ${rgb};`,\r\n          !opacity ? null : `${outGsplat}.rgba.a = ${opacity};`,\r\n          !x ? null : `${outGsplat}.center.x = ${x};`,\r\n          !y ? null : `${outGsplat}.center.y = ${y};`,\r\n          !z ? null : `${outGsplat}.center.z = ${z};`,\r\n          !r ? null : `${outGsplat}.rgba.r = ${r};`,\r\n          !g ? null : `${outGsplat}.rgba.g = ${g};`,\r\n          !b ? null : `${outGsplat}.rgba.b = ${b};`,\r\n        ].filter(Boolean) as string[];\r\n      },\r\n    });\r\n  }\r\n\r\n  dynoOut(): DynoValue<typeof Gsplat> {\r\n    return new DynoOutput(this, \"gsplat\");\r\n  }\r\n}\r\n\r\nexport const defineGsplatNormal = unindent(`\r\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\r\n    float minScale = min(scales.x, min(scales.y, scales.z));\r\n    vec3 normal;\r\n    if (scales.z == minScale) {\r\n      normal = vec3(0.0, 0.0, 1.0);\r\n    } else if (scales.y == minScale) {\r\n      normal = vec3(0.0, 1.0, 0.0);\r\n    } else {\r\n      normal = vec3(1.0, 0.0, 0.0);\r\n    }\r\n    return quatVec(quaternion, normal);\r\n  }\r\n`);\r\n\r\nexport class GsplatNormal extends UnaryOp<typeof Gsplat, \"vec3\", \"normal\"> {\r\n  constructor({ gsplat }: { gsplat: DynoVal<typeof Gsplat> }) {\r\n    super({ a: gsplat, outKey: \"normal\", outTypeFunc: () => \"vec3\" });\r\n    this.globals = () => [defineGsplat, defineGsplatNormal];\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.normal} = gsplatNormal(${inputs.a}.scales, ${inputs.a}.quaternion);`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class TransformGsplat\r\n  extends Dyno<\r\n    {\r\n      gsplat: typeof Gsplat;\r\n      scale: \"float\";\r\n      rotate: \"vec4\";\r\n      translate: \"vec3\";\r\n      recolor: \"vec4\";\r\n    },\r\n    { gsplat: typeof Gsplat }\r\n  >\r\n  implements HasDynoOut<typeof Gsplat>\r\n{\r\n  constructor({\r\n    gsplat,\r\n    scale,\r\n    rotate,\r\n    translate,\r\n    recolor,\r\n  }: {\r\n    gsplat?: DynoVal<typeof Gsplat>;\r\n    scale?: DynoVal<\"float\">;\r\n    rotate?: DynoVal<\"vec4\">;\r\n    translate?: DynoVal<\"vec3\">;\r\n    recolor?: DynoVal<\"vec4\">;\r\n  }) {\r\n    super({\r\n      inTypes: {\r\n        gsplat: Gsplat,\r\n        scale: \"float\",\r\n        rotate: \"vec4\",\r\n        translate: \"vec3\",\r\n        recolor: \"vec4\",\r\n      },\r\n      outTypes: { gsplat: Gsplat },\r\n      inputs: { gsplat, scale, rotate, translate, recolor },\r\n      globals: () => [defineGsplat],\r\n      statements: ({ inputs, outputs, compile }) => {\r\n        const { gsplat } = outputs;\r\n        if (!gsplat || !inputs.gsplat) {\r\n          return [];\r\n        }\r\n        const { scale, rotate, translate, recolor } = inputs;\r\n        const indent = compile.indent;\r\n        const statements = [\r\n          `${gsplat} = ${inputs.gsplat};`,\r\n          `if (isGsplatActive(${gsplat}.flags)) {`,\r\n\r\n          scale ? `${indent}${gsplat}.center *= ${scale};` : null,\r\n          rotate\r\n            ? `${indent}${gsplat}.center = quatVec(${rotate}, ${gsplat}.center);`\r\n            : null,\r\n          translate ? `${indent}${gsplat}.center += ${translate};` : null,\r\n\r\n          scale ? `${indent}${gsplat}.scales *= ${scale};` : null,\r\n\r\n          rotate\r\n            ? `${indent}${gsplat}.quaternion = quatQuat(${rotate}, ${gsplat}.quaternion);`\r\n            : null,\r\n          recolor ? `${indent}${gsplat}.rgba *= ${recolor};` : null,\r\n          \"}\",\r\n        ].filter(Boolean) as string[];\r\n        return statements;\r\n      },\r\n    });\r\n  }\r\n\r\n  dynoOut(): DynoValue<typeof Gsplat> {\r\n    return new DynoOutput(this, \"gsplat\");\r\n  }\r\n}\r\n","import * as THREE from \"three\";\r\nimport { Dyno, unindentLines } from \"./base\";\r\nimport { Gsplat, defineGsplat } from \"./splats\";\r\nimport {\r\n  DynoOutput,\r\n  type DynoVal,\r\n  type DynoValue,\r\n  type HasDynoOut,\r\n} from \"./value\";\r\n\r\nexport const outputPackedSplat = (\r\n  gsplat: DynoVal<typeof Gsplat>,\r\n  rgbMinMaxLnScaleMinMax: DynoVal<\"vec4\">,\r\n) => new OutputPackedSplat({ gsplat, rgbMinMaxLnScaleMinMax });\r\nexport const outputRgba8 = (rgba8: DynoVal<\"vec4\">) =>\r\n  new OutputRgba8({ rgba8 });\r\n\r\nexport class OutputPackedSplat\r\n  extends Dyno<\r\n    { gsplat: typeof Gsplat; rgbMinMaxLnScaleMinMax: \"vec4\" },\r\n    { output: \"uvec4\" }\r\n  >\r\n  implements HasDynoOut<\"uvec4\">\r\n{\r\n  constructor({\r\n    gsplat,\r\n    rgbMinMaxLnScaleMinMax,\r\n  }: {\r\n    gsplat?: DynoVal<typeof Gsplat>;\r\n    rgbMinMaxLnScaleMinMax?: DynoVal<\"vec4\">;\r\n  }) {\r\n    super({\r\n      inTypes: { gsplat: Gsplat, rgbMinMaxLnScaleMinMax: \"vec4\" },\r\n      inputs: { gsplat, rgbMinMaxLnScaleMinMax },\r\n      globals: () => [defineGsplat],\r\n      statements: ({ inputs, outputs }) => {\r\n        const { output } = outputs;\r\n        if (!output) {\r\n          return [];\r\n        }\r\n        const { gsplat, rgbMinMaxLnScaleMinMax } = inputs;\r\n        if (gsplat) {\r\n          return unindentLines(`\r\n            if (isGsplatActive(${gsplat}.flags)) {\r\n              ${output} = packSplatEncoding(${gsplat}.center, ${gsplat}.scales, ${gsplat}.quaternion, ${gsplat}.rgba, ${rgbMinMaxLnScaleMinMax});\r\n            } else {\r\n              ${output} = uvec4(0u, 0u, 0u, 0u);\r\n            }\r\n          `);\r\n        }\r\n        return [`${output} = uvec4(0u, 0u, 0u, 0u);`];\r\n      },\r\n    });\r\n  }\r\n\r\n  dynoOut(): DynoValue<\"uvec4\"> {\r\n    return new DynoOutput(this, \"output\");\r\n  }\r\n}\r\n\r\nexport class OutputRgba8\r\n  extends Dyno<{ rgba8: \"vec4\" }, { rgba8: \"vec4\" }>\r\n  implements HasDynoOut<\"vec4\">\r\n{\r\n  constructor({ rgba8 }: { rgba8?: DynoVal<\"vec4\"> }) {\r\n    super({\r\n      inTypes: { rgba8: \"vec4\" },\r\n      inputs: { rgba8 },\r\n      statements: ({ inputs, outputs }) => [\r\n        `target = ${inputs.rgba8 ?? \"vec4(0.0, 0.0, 0.0, 0.0)\"};`,\r\n      ],\r\n    });\r\n  }\r\n\r\n  dynoOut(): DynoValue<\"vec4\"> {\r\n    return new DynoOutput(this, \"rgba8\");\r\n  }\r\n}\r\n","import type { IUniform } from \"three\";\r\nimport { Dyno, dynoDeclare } from \"./base\";\r\nimport type { DynoJsType, DynoType } from \"./types\";\r\nimport { DynoOutput, type DynoValue, type HasDynoOut } from \"./value\";\r\n\r\nexport const uniform = <V extends DynoJsType<DynoType>>(\r\n  key: string,\r\n  type: DynoType,\r\n  value: V,\r\n) => new DynoUniform({ key, type, value });\r\nexport const dynoBool = (value = false, key?: string) =>\r\n  new DynoBool({ key, value });\r\nexport const dynoUint = (value = 0, key?: string) =>\r\n  new DynoUint({ key, value });\r\nexport const dynoInt = (value = 0, key?: string) => new DynoInt({ key, value });\r\nexport const dynoFloat = (value = 0.0, key?: string) =>\r\n  new DynoFloat({ key, value });\r\n\r\nexport const dynoBvec2 = <V extends DynoJsType<\"bvec2\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoBvec2({ key, value });\r\nexport const dynoUvec2 = <V extends DynoJsType<\"uvec2\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoUvec2({ key, value });\r\nexport const dynoIvec2 = <V extends DynoJsType<\"ivec2\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoIvec2({ key, value });\r\nexport const dynoVec2 = <V extends DynoJsType<\"vec2\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoVec2({ key, value });\r\n\r\nexport const dynoBvec3 = <V extends DynoJsType<\"bvec3\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoBvec3({ key, value });\r\nexport const dynoUvec3 = <V extends DynoJsType<\"uvec3\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoUvec3({ key, value });\r\nexport const dynoIvec3 = <V extends DynoJsType<\"ivec3\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoIvec3({ key, value });\r\nexport const dynoVec3 = <V extends DynoJsType<\"vec3\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoVec3({ key, value });\r\n\r\nexport const dynoBvec4 = <V extends DynoJsType<\"bvec4\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoBvec4({ key, value });\r\nexport const dynoUvec4 = <V extends DynoJsType<\"uvec4\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoUvec4({ key, value });\r\nexport const dynoIvec4 = <V extends DynoJsType<\"ivec4\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoIvec4({ key, value });\r\nexport const dynoVec4 = <V extends DynoJsType<\"vec4\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoVec4({ key, value });\r\n\r\nexport const dynoMat2 = <V extends DynoJsType<\"mat2\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoMat2({ key, value });\r\nexport const dynoMat2x2 = <V extends DynoJsType<\"mat2x2\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoMat2x2({ key, value });\r\nexport const dynoMat2x3 = <V extends DynoJsType<\"mat2x3\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoMat2x3({ key, value });\r\nexport const dynoMat2x4 = <V extends DynoJsType<\"mat2x4\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoMat2x4({ key, value });\r\n\r\nexport const dynoMat3 = <V extends DynoJsType<\"mat3\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoMat3({ key, value });\r\nexport const dynoMat3x2 = <V extends DynoJsType<\"mat3x2\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoMat3x2({ key, value });\r\nexport const dynoMat3x3 = <V extends DynoJsType<\"mat3x3\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoMat3x3({ key, value });\r\nexport const dynoMat3x4 = <V extends DynoJsType<\"mat3x4\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoMat3x4({ key, value });\r\n\r\nexport const dynoMat4 = <V extends DynoJsType<\"mat4\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoMat4({ key, value });\r\nexport const dynoMat4x2 = <V extends DynoJsType<\"mat4x2\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoMat4x2({ key, value });\r\nexport const dynoMat4x3 = <V extends DynoJsType<\"mat4x3\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoMat4x3({ key, value });\r\nexport const dynoMat4x4 = <V extends DynoJsType<\"mat4x4\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoMat4x4({ key, value });\r\n\r\nexport const dynoUsampler2D = <V extends DynoJsType<\"usampler2D\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoUsampler2D({ key, value });\r\nexport const dynoIsampler2D = <V extends DynoJsType<\"isampler2D\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoIsampler2D({ key, value });\r\nexport const dynoSampler2D = <V extends DynoJsType<\"sampler2D\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoSampler2D({ key, value });\r\n\r\nexport const dynoUsampler2DArray = <V extends DynoJsType<\"usampler2DArray\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoUsampler2DArray({ key, value });\r\nexport const dynoIsampler2DArray = <V extends DynoJsType<\"isampler2DArray\">>(\r\n  key: string,\r\n  value: V,\r\n) => new DynoIsampler2DArray({ key, value });\r\nexport const dynoSampler2DArray = <V extends DynoJsType<\"sampler2DArray\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoSampler2DArray({ key, value });\r\n\r\nexport const dynoUsampler3D = <V extends DynoJsType<\"usampler3D\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoUsampler3D({ key, value });\r\nexport const dynoIsampler3D = <V extends DynoJsType<\"isampler3D\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoIsampler3D({ key, value });\r\nexport const dynoSampler3D = <V extends DynoJsType<\"sampler3D\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoSampler3D({ key, value });\r\n\r\nexport const dynoUsamplerCube = <V extends DynoJsType<\"usamplerCube\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoUsamplerCube({ key, value });\r\nexport const dynoIsamplerCube = <V extends DynoJsType<\"isamplerCube\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoIsamplerCube({ key, value });\r\nexport const dynoSamplerCube = <V extends DynoJsType<\"samplerCube\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoSamplerCube({ key, value });\r\n\r\nexport const dynoSampler2DShadow = <V extends DynoJsType<\"sampler2DShadow\">>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoSampler2DShadow({ key, value });\r\nexport const dynoSampler2DArrayShadow = <\r\n  V extends DynoJsType<\"sampler2DArrayShadow\">,\r\n>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoSampler2DArrayShadow({ key, value });\r\nexport const dynoSamplerCubeShadow = <\r\n  V extends DynoJsType<\"samplerCubeShadow\">,\r\n>(\r\n  value: V,\r\n  key?: string,\r\n) => new DynoSamplerCubeShadow({ key, value });\r\n\r\nexport class DynoUniform<\r\n    T extends DynoType,\r\n    K extends string = \"value\",\r\n    V extends DynoJsType<T> = DynoJsType<T>,\r\n  >\r\n  extends Dyno<Record<string, never>, { [key in K]: T }>\r\n  implements HasDynoOut<T>\r\n{\r\n  public type: T;\r\n  public count?: number;\r\n  public outKey: K;\r\n  public value: V;\r\n  public uniform: { value: V; type?: string };\r\n\r\n  constructor({\r\n    key,\r\n    type,\r\n    count,\r\n    value,\r\n    update,\r\n    globals,\r\n  }: {\r\n    key?: K;\r\n    type: T;\r\n    count?: number;\r\n    value: V;\r\n    update?: (value: V) => V | undefined;\r\n    globals?: ({\r\n      inputs,\r\n      outputs,\r\n    }: { inputs: unknown; outputs: { [key in K]?: string } }) => string[];\r\n  }) {\r\n    key = (key ?? \"value\") as K;\r\n    super({\r\n      outTypes: { [key]: type } as { [key in K]: T },\r\n      update: () => {\r\n        if (update) {\r\n          const value = update(this.value);\r\n          if (value !== undefined) {\r\n            this.value = value;\r\n          }\r\n        }\r\n        this.uniform.value = this.value;\r\n      },\r\n      generate: ({ inputs, outputs }) => {\r\n        const allGlobals = globals?.({ inputs, outputs }) ?? [];\r\n        const uniforms: Record<string, IUniform> = {};\r\n        const name = outputs[key];\r\n        if (name) {\r\n          allGlobals.push(`uniform ${dynoDeclare(name, type, count)};`);\r\n          uniforms[name] = this.uniform;\r\n        }\r\n        return { globals: allGlobals, uniforms };\r\n      },\r\n    });\r\n    this.type = type;\r\n    this.count = count;\r\n    this.value = value;\r\n    this.uniform = { value };\r\n    this.outKey = key;\r\n  }\r\n\r\n  dynoOut(): DynoValue<T> {\r\n    return new DynoOutput(this, this.outKey);\r\n  }\r\n}\r\n\r\nexport class DynoBool<K extends string> extends DynoUniform<\r\n  \"bool\",\r\n  K,\r\n  boolean\r\n> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: {\r\n    key?: K;\r\n    value: boolean;\r\n    update?: (value: boolean) => boolean | undefined;\r\n  }) {\r\n    super({ key, type: \"bool\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoUint<K extends string> extends DynoUniform<\"uint\", K, number> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: {\r\n    key?: K;\r\n    value: number;\r\n    update?: (value: number) => number | undefined;\r\n  }) {\r\n    super({ key, type: \"uint\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoInt<K extends string> extends DynoUniform<\"int\", K, number> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: {\r\n    key?: K;\r\n    value: number;\r\n    update?: (value: number) => number | undefined;\r\n  }) {\r\n    super({ key, type: \"int\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoFloat<K extends string = \"value\"> extends DynoUniform<\r\n  \"float\",\r\n  K,\r\n  number\r\n> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: {\r\n    key?: K;\r\n    value: number;\r\n    update?: (value: number) => number | undefined;\r\n  }) {\r\n    super({ key, type: \"float\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoBvec2<\r\n  K extends string,\r\n  V extends DynoJsType<\"bvec2\">,\r\n> extends DynoUniform<\"bvec2\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"bvec2\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoUvec2<\r\n  K extends string,\r\n  V extends DynoJsType<\"uvec2\">,\r\n> extends DynoUniform<\"uvec2\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"uvec2\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoIvec2<\r\n  K extends string,\r\n  V extends DynoJsType<\"ivec2\">,\r\n> extends DynoUniform<\"ivec2\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"ivec2\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoVec2<\r\n  K extends string,\r\n  V extends DynoJsType<\"vec2\">,\r\n> extends DynoUniform<\"vec2\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"vec2\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoBvec3<\r\n  K extends string,\r\n  V extends DynoJsType<\"bvec3\">,\r\n> extends DynoUniform<\"bvec3\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"bvec3\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoUvec3<\r\n  V extends DynoJsType<\"uvec3\">,\r\n  K extends string = \"value\",\r\n> extends DynoUniform<\"uvec3\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"uvec3\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoIvec3<\r\n  V extends DynoJsType<\"ivec3\">,\r\n  K extends string = \"value\",\r\n> extends DynoUniform<\"ivec3\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"ivec3\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoVec3<\r\n  V extends DynoJsType<\"vec3\">,\r\n  K extends string = \"value\",\r\n> extends DynoUniform<\"vec3\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"vec3\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoBvec4<\r\n  K extends string,\r\n  V extends DynoJsType<\"bvec4\">,\r\n> extends DynoUniform<\"bvec4\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"bvec4\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoUvec4<\r\n  K extends string,\r\n  V extends DynoJsType<\"uvec4\">,\r\n> extends DynoUniform<\"uvec4\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"uvec4\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoIvec4<\r\n  K extends string,\r\n  V extends DynoJsType<\"ivec4\">,\r\n> extends DynoUniform<\"ivec4\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"ivec4\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoVec4<\r\n  V extends DynoJsType<\"vec4\">,\r\n  K extends string = \"value\",\r\n> extends DynoUniform<\"vec4\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"vec4\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoMat2<\r\n  K extends string,\r\n  V extends DynoJsType<\"mat2\">,\r\n> extends DynoUniform<\"mat2\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"mat2\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoMat2x2<\r\n  K extends string,\r\n  V extends DynoJsType<\"mat2x2\">,\r\n> extends DynoUniform<\"mat2x2\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"mat2x2\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoMat2x3<\r\n  K extends string,\r\n  V extends DynoJsType<\"mat2x3\">,\r\n> extends DynoUniform<\"mat2x3\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"mat2x3\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoMat2x4<\r\n  K extends string,\r\n  V extends DynoJsType<\"mat2x4\">,\r\n> extends DynoUniform<\"mat2x4\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"mat2x4\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoMat3<\r\n  K extends string,\r\n  V extends DynoJsType<\"mat3\">,\r\n> extends DynoUniform<\"mat3\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"mat3\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoMat3x2<\r\n  K extends string,\r\n  V extends DynoJsType<\"mat3x2\">,\r\n> extends DynoUniform<\"mat3x2\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"mat3x2\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoMat3x3<\r\n  K extends string,\r\n  V extends DynoJsType<\"mat3x3\">,\r\n> extends DynoUniform<\"mat3x3\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"mat3x3\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoMat3x4<\r\n  K extends string,\r\n  V extends DynoJsType<\"mat3x4\">,\r\n> extends DynoUniform<\"mat3x4\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"mat3x4\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoMat4<\r\n  K extends string,\r\n  V extends DynoJsType<\"mat4\">,\r\n> extends DynoUniform<\"mat4\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"mat4\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoMat4x2<\r\n  K extends string,\r\n  V extends DynoJsType<\"mat4x2\">,\r\n> extends DynoUniform<\"mat4x2\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"mat4x2\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoMat4x3<\r\n  K extends string,\r\n  V extends DynoJsType<\"mat4x3\">,\r\n> extends DynoUniform<\"mat4x3\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"mat4x3\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoMat4x4<\r\n  K extends string,\r\n  V extends DynoJsType<\"mat4x4\">,\r\n> extends DynoUniform<\"mat4x4\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"mat4x4\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoUsampler2D<\r\n  K extends string,\r\n  V extends DynoJsType<\"usampler2D\">,\r\n> extends DynoUniform<\"usampler2D\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"usampler2D\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoIsampler2D<\r\n  K extends string,\r\n  V extends DynoJsType<\"isampler2D\">,\r\n> extends DynoUniform<\"isampler2D\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"isampler2D\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoSampler2D<\r\n  K extends string,\r\n  V extends DynoJsType<\"sampler2D\">,\r\n> extends DynoUniform<\"sampler2D\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"sampler2D\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoUsampler2DArray<\r\n  K extends string,\r\n  V extends DynoJsType<\"usampler2DArray\">,\r\n> extends DynoUniform<\"usampler2DArray\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"usampler2DArray\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoIsampler2DArray<\r\n  K extends string,\r\n  V extends DynoJsType<\"isampler2DArray\">,\r\n> extends DynoUniform<\"isampler2DArray\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"isampler2DArray\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoSampler2DArray<\r\n  K extends string,\r\n  V extends DynoJsType<\"sampler2DArray\">,\r\n> extends DynoUniform<\"sampler2DArray\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"sampler2DArray\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoUsampler3D<\r\n  K extends string,\r\n  V extends DynoJsType<\"usampler3D\">,\r\n> extends DynoUniform<\"usampler3D\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"usampler3D\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoIsampler3D<\r\n  K extends string,\r\n  V extends DynoJsType<\"isampler3D\">,\r\n> extends DynoUniform<\"isampler3D\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"isampler3D\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoSampler3D<\r\n  K extends string,\r\n  V extends DynoJsType<\"sampler3D\">,\r\n> extends DynoUniform<\"sampler3D\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"sampler3D\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoUsamplerCube<\r\n  K extends string,\r\n  V extends DynoJsType<\"usamplerCube\">,\r\n> extends DynoUniform<\"usamplerCube\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"usamplerCube\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoIsamplerCube<\r\n  K extends string,\r\n  V extends DynoJsType<\"isamplerCube\">,\r\n> extends DynoUniform<\"isamplerCube\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"isamplerCube\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoSamplerCube<\r\n  K extends string,\r\n  V extends DynoJsType<\"samplerCube\">,\r\n> extends DynoUniform<\"samplerCube\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"samplerCube\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoSampler2DShadow<\r\n  K extends string,\r\n  V extends DynoJsType<\"sampler2DShadow\">,\r\n> extends DynoUniform<\"sampler2DShadow\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"sampler2DShadow\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoSampler2DArrayShadow<\r\n  K extends string,\r\n  V extends DynoJsType<\"sampler2DArrayShadow\">,\r\n> extends DynoUniform<\"sampler2DArrayShadow\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"sampler2DArrayShadow\", value, update });\r\n  }\r\n}\r\n\r\nexport class DynoSamplerCubeShadow<\r\n  K extends string,\r\n  V extends DynoJsType<\"samplerCubeShadow\">,\r\n> extends DynoUniform<\"samplerCubeShadow\", K, V> {\r\n  constructor({\r\n    key,\r\n    value,\r\n    update,\r\n  }: { key?: K; value: V; update?: (value: V) => V | undefined }) {\r\n    super({ key, type: \"samplerCubeShadow\", value, update });\r\n  }\r\n}\r\n","import { Gunzip } from \"fflate\";\r\nimport * as THREE from \"three\";\r\n\r\n// Miscellaneous utility functions for Spark\r\n\r\nimport {\r\n  LN_SCALE_MAX,\r\n  LN_SCALE_MIN,\r\n  SCALE_ZERO,\r\n  SPLAT_TEX_HEIGHT,\r\n  SPLAT_TEX_MIN_HEIGHT,\r\n  SPLAT_TEX_WIDTH,\r\n} from \"./defines.js\";\r\nimport { unindent } from \"./dyno/base.js\";\r\n\r\nconst f32buffer = new Float32Array(1);\r\nconst u32buffer = new Uint32Array(f32buffer.buffer);\r\nconst supportsFloat16Array = \"Float16Array\" in globalThis;\r\nconst f16buffer = supportsFloat16Array\r\n  ? new globalThis[\"Float16Array\" as keyof typeof globalThis](1)\r\n  : null;\r\nconst u16buffer = new Uint16Array(f16buffer?.buffer);\r\n\r\n// Returns a normalized array of numbers\r\nexport function normalize(vec: number[]) {\r\n  const norm = Math.sqrt(vec.reduce((acc, v) => acc + v * v, 0));\r\n  return vec.map((v) => v / norm);\r\n}\r\n\r\n// Reinterpret the bits of a float32 as a uint32\r\nexport function floatBitsToUint(f: number): number {\r\n  f32buffer[0] = f;\r\n  return u32buffer[0];\r\n}\r\n\r\n// Reinterpret the bits of a uint32 as a float32\r\nexport function uintBitsToFloat(u: number): number {\r\n  u32buffer[0] = u;\r\n  return f32buffer[0];\r\n}\r\n\r\nexport const toHalf = supportsFloat16Array ? toHalfNative : toHalfJS;\r\nexport const fromHalf = supportsFloat16Array ? fromHalfNative : fromHalfJS;\r\n\r\n// Encode a number as a float16, stored as a uint16 number.\r\nfunction toHalfNative(f: number): number {\r\n  f16buffer[0] = f;\r\n  return u16buffer[0];\r\n}\r\n\r\n// Encode a number as a float16, stored as a uint16 number.\r\nfunction toHalfJS(f: number): number {\r\n  // Store the value into the shared Float32 array.\r\n  f32buffer[0] = f;\r\n  const bits = u32buffer[0];\r\n\r\n  // Extract sign (1 bit), exponent (8 bits), and fraction (23 bits)\r\n  const sign = (bits >> 31) & 0x1;\r\n  const exp = (bits >> 23) & 0xff;\r\n  const frac = bits & 0x7fffff;\r\n  const halfSign = sign << 15;\r\n\r\n  // Handle special cases: NaN and Infinity\r\n  if (exp === 0xff) {\r\n    // NaN: set all exponent bits to 1 and some nonzero fraction bits.\r\n    if (frac !== 0) {\r\n      return halfSign | 0x7fff;\r\n    }\r\n    // Infinity\r\n    return halfSign | 0x7c00;\r\n  }\r\n\r\n  // Adjust the exponent from float32 bias (127) to float16 bias (15)\r\n  const newExp = exp - 127 + 15;\r\n\r\n  // Handle overflow: too large to represent in half precision.\r\n  if (newExp >= 0x1f) {\r\n    return halfSign | 0x7c00; // Infinity\r\n  }\r\n  if (newExp <= 0) {\r\n    // Handle subnormals and underflow.\r\n    if (newExp < -10) {\r\n      // Too small: underflows to zero.\r\n      return halfSign;\r\n    }\r\n    // Convert to subnormal: add the implicit leading 1 to the fraction,\r\n    // then shift to align with the half-precision's 10 fraction bits.\r\n    const subFrac = (frac | 0x800000) >> (1 - newExp + 13);\r\n    return halfSign | subFrac;\r\n  }\r\n\r\n  // Normalized half-precision number: shift fraction to fit into 10 bits.\r\n  const halfFrac = frac >> 13;\r\n  return halfSign | (newExp << 10) | halfFrac;\r\n}\r\n\r\n// Convert a float16 stored as a uint16 number back to a float32.\r\nfunction fromHalfNative(u: number): number {\r\n  u16buffer[0] = u;\r\n  return f16buffer[0];\r\n}\r\n\r\n// Convert a float16 stored as a uint16 number back to a float32.\r\nfunction fromHalfJS(h: number): number {\r\n  // Extract the sign (1 bit), exponent (5 bits), and fraction (10 bits)\r\n  const sign = (h >> 15) & 0x1;\r\n  const exp = (h >> 10) & 0x1f;\r\n  const frac = h & 0x3ff;\r\n\r\n  let f32bits: number;\r\n\r\n  if (exp === 0) {\r\n    if (frac === 0) {\r\n      // Zero (positive or negative)\r\n      f32bits = sign << 31;\r\n    } else {\r\n      // Subnormal half-precision number.\r\n      // Normalize the subnormal number:\r\n      let mant = frac;\r\n      let e = -14; // For half, the exponent for subnormals is fixed at -14.\r\n      // Shift left until the implicit leading 1 is in place.\r\n      while ((mant & 0x400) === 0) {\r\n        // 0x400 === 1 << 10\r\n        mant <<= 1;\r\n        e--;\r\n      }\r\n      // Remove the leading 1 (which is now implicit)\r\n      mant &= 0x3ff;\r\n      // Convert the half exponent (e) to the 32-bit float exponent:\r\n      const newExp = e + 127; // 32-bit float bias is 127.\r\n      const newFrac = mant << 13; // Align to 23-bit fraction (23 - 10 = 13)\r\n      f32bits = (sign << 31) | (newExp << 23) | newFrac;\r\n    }\r\n  } else if (exp === 0x1f) {\r\n    // Handle special cases for Infinity and NaN.\r\n    if (frac === 0) {\r\n      // Infinity\r\n      f32bits = (sign << 31) | 0x7f800000;\r\n    } else {\r\n      // NaN (we choose a quiet NaN)\r\n      f32bits = (sign << 31) | 0x7fc00000;\r\n    }\r\n  } else {\r\n    // Normalized half-precision number.\r\n    // Adjust exponent from half (bias 15) to float32 (bias 127)\r\n    const newExp = exp - 15 + 127;\r\n    const newFrac = frac << 13;\r\n    f32bits = (sign << 31) | (newExp << 23) | newFrac;\r\n  }\r\n\r\n  // Write the 32-bit bit pattern to the shared buffer,\r\n  // then read it as a float32 to return a JavaScript number.\r\n  u32buffer[0] = f32bits;\r\n  return f32buffer[0];\r\n}\r\n\r\n// Convert a number 0..1 to a 0..255 uint\r\nexport function floatToUint8(v: number): number {\r\n  // Converts from 0..1 float to 0..255 uint8\r\n  return Math.max(0, Math.min(255, Math.round(v * 255)));\r\n}\r\n\r\n// Convert a number -1..1 to a -127..127 int\r\nexport function floatToSint8(v: number): number {\r\n  // Converts from -1..1 float to -127..127 int8\r\n  return Math.max(-127, Math.min(127, Math.round(v * 127)));\r\n}\r\n\r\n// Convert a 0..255 uint to a 0..1 float\r\nexport function Uint8ToFloat(v: number): number {\r\n  // Converts from 0..255 uint8 to 0..1 float\r\n  return v / 255;\r\n}\r\n\r\n// Convert a -127..127 int to a -1..1 float\r\nexport function Sint8ToFloat(v: number): number {\r\n  // Converts from -127..127 int8 to -1..1 float\r\n  return v / 127;\r\n}\r\n\r\n// A simple utility class for caching a fixed number of items\r\nexport class DataCache {\r\n  // Maximum number of items to cache\r\n  maxItems: number;\r\n\r\n  // Function to fetch data for a key\r\n  asyncFetch: (key: string) => Promise<unknown>;\r\n\r\n  // Array of cached items\r\n  items: { key: string; data: unknown }[];\r\n\r\n  // Create a DataCache with a given function that fetches data not in the cache.\r\n  constructor({\r\n    asyncFetch,\r\n    maxItems = 5,\r\n  }: { asyncFetch: (key: string) => Promise<unknown>; maxItems?: number }) {\r\n    this.asyncFetch = asyncFetch;\r\n    this.maxItems = maxItems;\r\n    this.items = [];\r\n  }\r\n\r\n  // Fetch data for the key, returning cached data if available.\r\n  async getFetch(key: string): Promise<unknown> {\r\n    // Fetches data for a key and caches it, returns cached data if available.\r\n    const index = this.items.findIndex((item) => item.key === key);\r\n    if (index >= 0) {\r\n      // Data exists in our cache, move it to the end of the array\r\n      const item = this.items.splice(index, 1)[0];\r\n      this.items.push(item);\r\n      // Return the cached data\r\n      return item.data;\r\n    }\r\n\r\n    // Fetch the data from the asyncFetch function\r\n    const data = await this.asyncFetch(key);\r\n    // Add the data to the cache\r\n    this.items.push({ key, data });\r\n    // If the cache is too large, remove the oldest accessed item\r\n    while (this.items.length > this.maxItems) {\r\n      this.items.shift();\r\n    }\r\n    // Return the fetched data\r\n    return data;\r\n  }\r\n}\r\n\r\n// Like Array.map but for objects\r\nexport function mapObject(\r\n  obj: Record<string, unknown>,\r\n  fn: (value: unknown, key: string) => unknown,\r\n): Record<string, unknown> {\r\n  // Maps over an object, applying a function to each value and key\r\n  const entries = Object.entries(obj).map(([key, value]) => [\r\n    key,\r\n    fn(value, key),\r\n  ]);\r\n  // Returns a new object with the mapped values\r\n  return Object.fromEntries(entries);\r\n}\r\n\r\n// Like Array.map().filter() but for objects.\r\n// The callback fn() should return undefined to filter out the key.\r\nexport function mapFilterObject(\r\n  obj: Record<string, unknown>,\r\n  fn: (value: unknown, key: string) => unknown,\r\n): Record<string, unknown> {\r\n  // Maps over an object, applying a function to each value and key\r\n  // If no return (or return undefined), the key is not included in the result\r\n  const entries = Object.entries(obj)\r\n    .map(([key, value]) => [key, fn(value, key)])\r\n    .filter(([_, value]) => value !== undefined);\r\n  // Returns a new object with the filtered values\r\n  return Object.fromEntries(entries);\r\n}\r\n\r\n// Recursively finds all ArrayBuffers in an object and returns them as an array\r\n// to use as transferable objects to send between workers.\r\nexport function getArrayBuffers(ctx: unknown): Transferable[] {\r\n  const buffers: ArrayBuffer[] = [];\r\n  const seen = new Set();\r\n\r\n  function traverse(obj: unknown) {\r\n    if (obj && typeof obj === \"object\" && !seen.has(obj)) {\r\n      seen.add(obj);\r\n\r\n      if (obj instanceof ArrayBuffer) {\r\n        buffers.push(obj);\r\n      } else if (ArrayBuffer.isView(obj)) {\r\n        // Handles TypedArrays and DataView\r\n        buffers.push(obj.buffer);\r\n      } else if (Array.isArray(obj)) {\r\n        obj.forEach(traverse);\r\n      } else {\r\n        Object.values(obj).forEach(traverse);\r\n      }\r\n    }\r\n  }\r\n\r\n  traverse(ctx);\r\n  return buffers;\r\n}\r\n\r\n// Create an array of the given size and initialize element with initFunction()\r\nexport function newArray<T>(\r\n  n: number,\r\n  initFunction: (index: number) => T,\r\n): T[] {\r\n  // Creates a new array and calls a constructor function for each element with index\r\n  return new Array(n).fill(null).map((_, i) => initFunction(i));\r\n}\r\n\r\n// A free list that has a pool of items of type T, with callbacks\r\n// for constructing, disposing, and checking if an item is valid for the given args.\r\nexport class FreeList<T, Args> {\r\n  items: T[];\r\n  allocate: (args: Args) => T;\r\n  dispose?: (item: T) => void;\r\n  valid: (item: T, args: Args) => boolean;\r\n\r\n  constructor({\r\n    // Allocate a new item with the given args\r\n    allocate,\r\n    // Dispose of an item (optional, if GC is enough)\r\n    dispose,\r\n    // Check if an existing item in the list is valid for the given args,\r\n    // allowing you to store heterogeneous items in the list.\r\n    valid,\r\n  }: {\r\n    allocate: (args: Args) => T;\r\n    dispose?: (item: T) => void;\r\n    valid: (item: T, args: Args) => boolean;\r\n  }) {\r\n    this.items = [];\r\n    this.allocate = allocate;\r\n    this.dispose = dispose;\r\n    this.valid = valid;\r\n  }\r\n\r\n  // Allocate a new item from the free list, first checking if a existing item\r\n  // on the freelist is valid for the given args.\r\n  alloc(args: Args): T {\r\n    while (true) {\r\n      const item = this.items.pop();\r\n      if (!item) {\r\n        // No items in the free list, allocate a new one\r\n        break;\r\n      }\r\n      if (this.valid(item, args)) {\r\n        // Found a valid item, return it\r\n        // console.log(`FreeList.alloc(${JSON.stringify(args)}): found valid item. Reusing...`);\r\n        return item;\r\n      }\r\n      // Item isn't valid for our args, dispose of it and try again\r\n      if (this.dispose) {\r\n        // console.log(`FreeList.alloc(${JSON.stringify(args)}): disposing invalid item.`);\r\n        this.dispose(item);\r\n      }\r\n    }\r\n    // console.log(`FreeList.alloc(${JSON.stringify(args)}): allocating new item`);\r\n    return this.allocate(args);\r\n  }\r\n\r\n  free(item: T) {\r\n    // Return item to the free list\r\n    this.items.push(item);\r\n  }\r\n\r\n  disposeAll() {\r\n    // Disposes of all items in the free list\r\n    let item: T | undefined;\r\n    item = this.items.pop();\r\n    while (item) {\r\n      if (this.dispose) {\r\n        this.dispose(item);\r\n      }\r\n      item = this.items.pop();\r\n    }\r\n  }\r\n}\r\n\r\n// Encode a PackedSplat as 4 consecutive Uint32 elements in the packedSplats array.\r\n// The center coordinates x,y,z are encoded as float16, the scales x,y,z as a\r\n// logarithmic uint8, rotation as three uint8s representing rotation axis and angle,\r\n// and RGBA as 4xuint8.\r\nexport function setPackedSplat(\r\n  packedSplats: Uint32Array,\r\n  index: number,\r\n  x: number,\r\n  y: number,\r\n  z: number,\r\n  scaleX: number,\r\n  scaleY: number,\r\n  scaleZ: number,\r\n  quatX: number,\r\n  quatY: number,\r\n  quatZ: number,\r\n  quatW: number,\r\n  opacity: number,\r\n  r: number,\r\n  g: number,\r\n  b: number,\r\n  encoding?: {\r\n    rgbMin?: number;\r\n    rgbMax?: number;\r\n    lnScaleMin?: number;\r\n    lnScaleMax?: number;\r\n  },\r\n) {\r\n  const rgbMin = encoding?.rgbMin ?? 0.0;\r\n  const rgbMax = encoding?.rgbMax ?? 1.0;\r\n  const rgbRange = rgbMax - rgbMin;\r\n  const uR = floatToUint8((r - rgbMin) / rgbRange);\r\n  const uG = floatToUint8((g - rgbMin) / rgbRange);\r\n  const uB = floatToUint8((b - rgbMin) / rgbRange);\r\n  const uA = floatToUint8(opacity);\r\n\r\n  // Alternate internal encodings commented out below.\r\n  const uQuat = encodeQuatOctXy88R8(\r\n    tempQuaternion.set(quatX, quatY, quatZ, quatW),\r\n  );\r\n  // const uQuat = encodeQuatXyz888(new THREE.Quaternion(quatX, quatY, quatZ, quatW));\r\n  // const uQuat = encodeQuatEulerXyz888(new THREE.Quaternion(quatX, quatY, quatZ, quatW));\r\n  const uQuatX = uQuat & 0xff;\r\n  const uQuatY = (uQuat >>> 8) & 0xff;\r\n  const uQuatZ = (uQuat >>> 16) & 0xff;\r\n\r\n  // Allow scales below LN_SCALE_MIN to be encoded as 0, which signifies a 2DGS\r\n  const lnScaleMin = encoding?.lnScaleMin ?? LN_SCALE_MIN;\r\n  const lnScaleMax = encoding?.lnScaleMax ?? LN_SCALE_MAX;\r\n  const lnScaleScale = 254.0 / (lnScaleMax - lnScaleMin);\r\n  const uScaleX =\r\n    scaleX < SCALE_ZERO\r\n      ? 0\r\n      : Math.min(\r\n          255,\r\n          Math.max(\r\n            1,\r\n            Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1,\r\n          ),\r\n        );\r\n  const uScaleY =\r\n    scaleY < SCALE_ZERO\r\n      ? 0\r\n      : Math.min(\r\n          255,\r\n          Math.max(\r\n            1,\r\n            Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1,\r\n          ),\r\n        );\r\n  const uScaleZ =\r\n    scaleZ < SCALE_ZERO\r\n      ? 0\r\n      : Math.min(\r\n          255,\r\n          Math.max(\r\n            1,\r\n            Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1,\r\n          ),\r\n        );\r\n\r\n  const uCenterX = toHalf(x);\r\n  const uCenterY = toHalf(y);\r\n  const uCenterZ = toHalf(z);\r\n\r\n  // Encode the splat as 4 consecutive Uint32 elements\r\n  const i4 = index * 4;\r\n  packedSplats[i4] = uR | (uG << 8) | (uB << 16) | (uA << 24);\r\n  packedSplats[i4 + 1] = uCenterX | (uCenterY << 16);\r\n  packedSplats[i4 + 2] = uCenterZ | (uQuatX << 16) | (uQuatY << 24);\r\n  packedSplats[i4 + 3] =\r\n    uScaleX | (uScaleY << 8) | (uScaleZ << 16) | (uQuatZ << 24);\r\n}\r\n\r\n// Encode the center coordinates x,y,z in the packedSplats Uint32Array,\r\n// leaving all other fields as is.\r\nexport function setPackedSplatCenter(\r\n  packedSplats: Uint32Array,\r\n  index: number,\r\n  x: number,\r\n  y: number,\r\n  z: number,\r\n) {\r\n  const uCenterX = toHalf(x);\r\n  const uCenterY = toHalf(y);\r\n  const uCenterZ = toHalf(z);\r\n\r\n  const i4 = index * 4;\r\n  packedSplats[i4 + 1] = uCenterX | (uCenterY << 16);\r\n  packedSplats[i4 + 2] = uCenterZ | (packedSplats[i4 + 2] & 0xffff0000);\r\n}\r\n\r\n// Encode the scales x,y,z in the packedSplats Uint32Array, leaving all other fields as is.\r\nexport function setPackedSplatScales(\r\n  packedSplats: Uint32Array,\r\n  index: number,\r\n  scaleX: number,\r\n  scaleY: number,\r\n  scaleZ: number,\r\n  encoding?: {\r\n    lnScaleMin?: number;\r\n    lnScaleMax?: number;\r\n  },\r\n) {\r\n  // Allow scales below LN_SCALE_MIN to be encoded as 0, which signifies a 2DGS\r\n  const lnScaleMin = encoding?.lnScaleMin ?? LN_SCALE_MIN;\r\n  const lnScaleMax = encoding?.lnScaleMax ?? LN_SCALE_MAX;\r\n  const lnScaleScale = 254.0 / (lnScaleMax - lnScaleMin);\r\n  const uScaleX =\r\n    scaleX < SCALE_ZERO\r\n      ? 0\r\n      : Math.min(\r\n          255,\r\n          Math.max(\r\n            1,\r\n            Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1,\r\n          ),\r\n        );\r\n  const uScaleY =\r\n    scaleY < SCALE_ZERO\r\n      ? 0\r\n      : Math.min(\r\n          255,\r\n          Math.max(\r\n            1,\r\n            Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1,\r\n          ),\r\n        );\r\n  const uScaleZ =\r\n    scaleZ < SCALE_ZERO\r\n      ? 0\r\n      : Math.min(\r\n          255,\r\n          Math.max(\r\n            1,\r\n            Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1,\r\n          ),\r\n        );\r\n\r\n  const i4 = index * 4;\r\n  packedSplats[i4 + 3] =\r\n    uScaleX |\r\n    (uScaleY << 8) |\r\n    (uScaleZ << 16) |\r\n    (packedSplats[i4 + 3] & 0xff000000);\r\n}\r\n\r\n// Temporary storage used in `encodeQuatOCtXy88R8` and `decodeQuatOctXy88R8` to\r\n// avoid allocation new Quaternions and Vector3 instances.\r\nconst tempQuaternion = new THREE.Quaternion();\r\n\r\n// Encode the rotation quatX, quatY, quatZ, quatW in the packedSplats Uint32Array,\r\n// leaving all other fields as is.\r\nexport function setPackedSplatQuat(\r\n  packedSplats: Uint32Array,\r\n  index: number,\r\n  quatX: number,\r\n  quatY: number,\r\n  quatZ: number,\r\n  quatW: number,\r\n) {\r\n  const uQuat = encodeQuatOctXy88R8(\r\n    tempQuaternion.set(quatX, quatY, quatZ, quatW),\r\n  );\r\n  // const uQuat = encodeQuatXyz888(new THREE.Quaternion(quatX, quatY, quatZ, quatW));\r\n  // const uQuat = encodeQuatEulerXyz888(new THREE.Quaternion(quatX, quatY, quatZ, quatW));\r\n  const uQuatX = uQuat & 0xff;\r\n  const uQuatY = (uQuat >>> 8) & 0xff;\r\n  const uQuatZ = (uQuat >>> 16) & 0xff;\r\n\r\n  const i4 = index * 4;\r\n  packedSplats[i4 + 2] =\r\n    (packedSplats[i4 + 2] & 0x0000ffff) | (uQuatX << 16) | (uQuatY << 24);\r\n  packedSplats[i4 + 3] = (packedSplats[i4 + 3] & 0x00ffffff) | (uQuatZ << 24);\r\n}\r\n\r\n// Encode the RGBA color in the packedSplats Uint32Array, leaving other fields alone.\r\nexport function setPackedSplatRgba(\r\n  packedSplats: Uint32Array,\r\n  index: number,\r\n  r: number,\r\n  g: number,\r\n  b: number,\r\n  a: number,\r\n  encoding?: {\r\n    rgbMin?: number;\r\n    rgbMax?: number;\r\n  },\r\n) {\r\n  const rgbMin = encoding?.rgbMin ?? 0.0;\r\n  const rgbMax = encoding?.rgbMax ?? 1.0;\r\n  const rgbRange = rgbMax - rgbMin;\r\n  const uR = floatToUint8((r - rgbMin) / rgbRange);\r\n  const uG = floatToUint8((g - rgbMin) / rgbRange);\r\n  const uB = floatToUint8((b - rgbMin) / rgbRange);\r\n  const uA = floatToUint8(a);\r\n  const i4 = index * 4;\r\n  packedSplats[i4] = uR | (uG << 8) | (uB << 16) | (uA << 24);\r\n}\r\n\r\n// Encode the RGB color in the packedSplats Uint32Array, leaving other fields alone.\r\nexport function setPackedSplatRgb(\r\n  packedSplats: Uint32Array,\r\n  index: number,\r\n  r: number,\r\n  g: number,\r\n  b: number,\r\n  encoding?: {\r\n    rgbMin?: number;\r\n    rgbMax?: number;\r\n  },\r\n) {\r\n  const rgbMin = encoding?.rgbMin ?? 0.0;\r\n  const rgbMax = encoding?.rgbMax ?? 1.0;\r\n  const rgbRange = rgbMax - rgbMin;\r\n  const uR = floatToUint8((r - rgbMin) / rgbRange);\r\n  const uG = floatToUint8((g - rgbMin) / rgbRange);\r\n  const uB = floatToUint8((b - rgbMin) / rgbRange);\r\n\r\n  const i4 = index * 4;\r\n  packedSplats[i4] =\r\n    uR | (uG << 8) | (uB << 16) | (packedSplats[i4] & 0xff000000);\r\n}\r\n\r\n// Encode the opacity in the packedSplats Uint32Array, leaving other fields alone.\r\nexport function setPackedSplatOpacity(\r\n  packedSplats: Uint32Array,\r\n  index: number,\r\n  opacity: number,\r\n) {\r\n  const uA = floatToUint8(opacity);\r\n\r\n  const i4 = index * 4;\r\n  packedSplats[i4] = (packedSplats[i4] & 0x00ffffff) | (uA << 24);\r\n}\r\n\r\nconst packedCenter = new THREE.Vector3();\r\nconst packedScales = new THREE.Vector3();\r\nconst packedQuaternion = new THREE.Quaternion();\r\nconst packedColor = new THREE.Color();\r\nconst packedFields = {\r\n  center: packedCenter,\r\n  scales: packedScales,\r\n  quaternion: packedQuaternion,\r\n  color: packedColor,\r\n  opacity: 0.0,\r\n};\r\n\r\n// Unpack all components of a PackedSplat from the packedSplats Uint32Array into\r\n// THREE.js vector objects. The returned objects will be reused each call.\r\nexport function unpackSplat(\r\n  packedSplats: Uint32Array,\r\n  index: number,\r\n  encoding?: {\r\n    rgbMin?: number;\r\n    rgbMax?: number;\r\n    lnScaleMin?: number;\r\n    lnScaleMax?: number;\r\n  },\r\n): {\r\n  center: THREE.Vector3;\r\n  scales: THREE.Vector3;\r\n  quaternion: THREE.Quaternion;\r\n  color: THREE.Color;\r\n  opacity: number;\r\n} {\r\n  // Returns a static object which is reused each time\r\n  const result = packedFields;\r\n\r\n  const i4 = index * 4;\r\n  const word0 = packedSplats[i4];\r\n  const word1 = packedSplats[i4 + 1];\r\n  const word2 = packedSplats[i4 + 2];\r\n  const word3 = packedSplats[i4 + 3];\r\n\r\n  const rgbMin = encoding?.rgbMin ?? 0.0;\r\n  const rgbMax = encoding?.rgbMax ?? 1.0;\r\n  const rgbRange = rgbMax - rgbMin;\r\n  result.color.set(\r\n    rgbMin + ((word0 & 0xff) / 255) * rgbRange,\r\n    rgbMin + (((word0 >>> 8) & 0xff) / 255) * rgbRange,\r\n    rgbMin + (((word0 >>> 16) & 0xff) / 255) * rgbRange,\r\n  );\r\n  result.opacity = ((word0 >>> 24) & 0xff) / 255;\r\n  result.center.set(\r\n    fromHalf(word1 & 0xffff),\r\n    fromHalf((word1 >>> 16) & 0xffff),\r\n    fromHalf(word2 & 0xffff),\r\n  );\r\n\r\n  const lnScaleMin = encoding?.lnScaleMin ?? LN_SCALE_MIN;\r\n  const lnScaleMax = encoding?.lnScaleMax ?? LN_SCALE_MAX;\r\n  const lnScaleScale = (lnScaleMax - lnScaleMin) / 254.0;\r\n  const uScalesX = word3 & 0xff;\r\n  result.scales.x =\r\n    uScalesX === 0 ? 0.0 : Math.exp(lnScaleMin + (uScalesX - 1) * lnScaleScale);\r\n  const uScalesY = (word3 >>> 8) & 0xff;\r\n  result.scales.y =\r\n    uScalesY === 0 ? 0.0 : Math.exp(lnScaleMin + (uScalesY - 1) * lnScaleScale);\r\n  const uScalesZ = (word3 >>> 16) & 0xff;\r\n  result.scales.z =\r\n    uScalesZ === 0 ? 0.0 : Math.exp(lnScaleMin + (uScalesZ - 1) * lnScaleScale);\r\n\r\n  const uQuat = ((word2 >>> 16) & 0xffff) | ((word3 >>> 8) & 0xff0000);\r\n  decodeQuatOctXy88R8(uQuat, result.quaternion);\r\n  // decodeQuatXyz888(uQuat, result.quaternion);\r\n  // decodeQuatEulerXyz888(uQuat, result.quaternion);\r\n\r\n  return result;\r\n}\r\n\r\n// Compute a texture array size that is large enough to fit numSplats. The most\r\n// common 2D texture size in WebGL2 is 4096x4096 which only allows for 16M splats,\r\n// so Spark stores Gsplat data in a 2D texture array, which most platforms support\r\n// up to 2048x2048x2048 = 8G splats. Allocations that fit within a single 2D texture\r\n// array layer will be rounded up to fill an entire texture row. Once a texture\r\n// array layer is filled, the allocation will be rounded up to fill an entire layer.\r\n// This is done so the entire set of splats can be covered by min/max coords across\r\n// each dimension.\r\nexport function getTextureSize(numSplats: number): {\r\n  width: number;\r\n  height: number;\r\n  depth: number;\r\n  maxSplats: number;\r\n} {\r\n  // Compute a texture array size that is large enough to fit numSplats.\r\n  // The width is always 2048, the height sized to fit the splats but no larger than 2048.\r\n  // The depth is the number of layers needed to fit the splats.\r\n  // maxSplats is computed as the new total available splats that can be stored.\r\n  const width = SPLAT_TEX_WIDTH;\r\n  const height = Math.max(\r\n    SPLAT_TEX_MIN_HEIGHT,\r\n    Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width)),\r\n  );\r\n  const depth = Math.ceil(numSplats / (width * height));\r\n  const maxSplats = width * height * depth;\r\n  return { width, height, depth, maxSplats };\r\n}\r\n\r\nexport function computeMaxSplats(numSplats: number): number {\r\n  // Compute the size of a Gsplat array texture (2048x2048xD) that can fit\r\n  // numSplats splats, and return the total number of splats that can be stored\r\n  // in such a texture.\r\n  const width = SPLAT_TEX_WIDTH;\r\n  const height = Math.max(\r\n    SPLAT_TEX_MIN_HEIGHT,\r\n    Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width)),\r\n  );\r\n  const depth = Math.ceil(numSplats / (width * height));\r\n  return width * height * depth;\r\n}\r\n\r\n// Heuristic function to determine if we are running on a mobile device.\r\nexport function isMobile(): boolean {\r\n  if (navigator.maxTouchPoints > 0) {\r\n    // Touch-enabled device, assume it's mobile\r\n    return true;\r\n  }\r\n  return /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/.test(\r\n    navigator.userAgent,\r\n  );\r\n}\r\n\r\n// Heuristic function to determine if we are running on an Android device.\r\n// (does not include Oculus Quest)\r\nexport function isAndroid(): boolean {\r\n  return /Android/.test(navigator.userAgent);\r\n}\r\n\r\n// Heuristic function to determine if we are running on an Oculus Quest device.\r\nexport function isOculus(): boolean {\r\n  return /Oculus/.test(navigator.userAgent);\r\n}\r\n\r\n// Take an array of RGBA8 encoded pixels and flip them vertically in-place.\r\n// This is useful for converting between top-left and bottom-left coordinate systems\r\n// in standard 2D images vs WebGL2.\r\nexport function flipPixels(\r\n  pixels: Uint8Array,\r\n  width: number,\r\n  height: number,\r\n): Uint8Array {\r\n  // Flips pixels vertically in-place, returns original array.\r\n  const tempLine = new Uint8Array(width * 4);\r\n\r\n  // Only need to process half the height since we're swapping\r\n  for (let y = 0; y < height / 2; y++) {\r\n    const topOffset = y * width * 4;\r\n    const bottomOffset = (height - 1 - y) * width * 4;\r\n\r\n    // Save top line to temp buffer\r\n    tempLine.set(pixels.subarray(topOffset, topOffset + width * 4));\r\n    // Move bottom line to top\r\n    pixels.set(\r\n      pixels.subarray(bottomOffset, bottomOffset + width * 4),\r\n      topOffset,\r\n    );\r\n    // Move saved top line to bottom\r\n    pixels.set(tempLine, bottomOffset);\r\n  }\r\n  return pixels;\r\n}\r\n\r\n// Utility to take an array of RGBA8 encoded pixels and convert them to a\r\n// PNG-encoded image data URL that can be downloaded to the client.\r\nexport function pixelsToPngUrl(\r\n  pixels: Uint8Array,\r\n  width: number,\r\n  height: number,\r\n): string {\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.width = width;\r\n  canvas.height = height;\r\n  const ctx = canvas.getContext(\"2d\");\r\n  if (!ctx) {\r\n    throw new Error(\"Can't get 2d context\");\r\n  }\r\n  const imageData = ctx.createImageData(width, height);\r\n  imageData.data.set(pixels);\r\n  ctx.putImageData(imageData, 0, 0);\r\n  return canvas.toDataURL(\"image/png\");\r\n}\r\n\r\n// Manually clone a THREE.Clock object.\r\nexport function cloneClock(clock: THREE.Clock): THREE.Clock {\r\n  const newClock = new THREE.Clock(clock.autoStart);\r\n  newClock.startTime = clock.startTime;\r\n  newClock.oldTime = clock.oldTime;\r\n  newClock.elapsedTime = clock.elapsedTime;\r\n  newClock.running = clock.running;\r\n  return newClock;\r\n}\r\n\r\n// Utility to filter out an undefined values from an object.\r\nexport function omitUndefined<T extends object>(obj: T): Partial<T> {\r\n  return Object.fromEntries(\r\n    Object.entries(obj).filter(([_, value]) => value !== undefined),\r\n  ) as Partial<T>;\r\n}\r\n\r\n// \"Identity\" vertex shader that just passes through the position.\r\nexport const IDENT_VERTEX_SHADER = unindent(`\r\n  precision highp float;\r\n\r\n  in vec3 position;\r\n\r\n  void main() {\r\n    gl_Position = vec4(position.xy, 0.0, 1.0);\r\n  }\r\n`);\r\n\r\n// Returns the average position of an array of THREE.Vector3.\r\nexport function averagePositions(positions: THREE.Vector3[]): THREE.Vector3 {\r\n  const sum = new THREE.Vector3();\r\n  for (const position of positions) {\r\n    sum.add(position);\r\n  }\r\n  return sum.divideScalar(positions.length);\r\n}\r\n\r\n// Returns an \"average\" of an array of THREE.Quaternion objects.\r\n// Note that this is not a spherical lerp between quaternions but\r\n// rather an arithmetic mean that is normalized to unit length.\r\nexport function averageQuaternions(\r\n  quaternions: THREE.Quaternion[],\r\n): THREE.Quaternion {\r\n  if (quaternions.length === 0) {\r\n    return new THREE.Quaternion();\r\n  }\r\n  const sum = quaternions[0].clone();\r\n  for (let i = 1; i < quaternions.length; i++) {\r\n    if (quaternions[i].dot(quaternions[0]) < 0.0) {\r\n      sum.x -= quaternions[i].x;\r\n      sum.y -= quaternions[i].y;\r\n      sum.z -= quaternions[i].z;\r\n      sum.w -= quaternions[i].w;\r\n    } else {\r\n      sum.x += quaternions[i].x;\r\n      sum.y += quaternions[i].y;\r\n      sum.z += quaternions[i].z;\r\n      sum.w += quaternions[i].w;\r\n    }\r\n  }\r\n  return sum.normalize();\r\n}\r\n\r\n// Compare two coordinates given by matrix1 and matrix2, returning the distance\r\n// between their origins and the \"coincidence\" of their orientations, defined\r\n// as the dot product of their \"-z\" axes.\r\nexport function coinciDist(matrix1: THREE.Matrix4, matrix2: THREE.Matrix4) {\r\n  const origin1 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix1);\r\n  const origin2 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix2);\r\n  const direction1 = new THREE.Vector3(0, 0, -1)\r\n    .applyMatrix4(matrix1)\r\n    .sub(origin1)\r\n    .normalize();\r\n  const direction2 = new THREE.Vector3(0, 0, -1)\r\n    .applyMatrix4(matrix2)\r\n    .sub(origin2)\r\n    .normalize();\r\n\r\n  const distance = origin1.distanceTo(origin2);\r\n  const coincidence = direction1.dot(direction2);\r\n  return { distance, coincidence };\r\n}\r\n\r\n// Utility function that returns whether two coordinate system origins\r\n// given by matrix1 and matrix2 are within a certain maxDistance of each other.\r\nexport function withinDist({\r\n  matrix1,\r\n  matrix2,\r\n  maxDistance,\r\n}: {\r\n  matrix1: THREE.Matrix4;\r\n  matrix2: THREE.Matrix4;\r\n  maxDistance: number;\r\n}): boolean {\r\n  const origin1 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix1);\r\n  const origin2 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix2);\r\n  return origin1.distanceTo(origin2) <= maxDistance;\r\n}\r\n\r\n// Utility function that returns whether two coordinate systems are \"close\"\r\n// to each other, defined by a maxDistance and a minCoincidence.\r\nexport function withinCoinciDist({\r\n  matrix1,\r\n  matrix2,\r\n  maxDistance,\r\n  minCoincidence,\r\n}: {\r\n  matrix1: THREE.Matrix4;\r\n  matrix2: THREE.Matrix4;\r\n  maxDistance: number;\r\n  minCoincidence?: number;\r\n}): boolean {\r\n  const { distance, coincidence } = coinciDist(matrix1, matrix2);\r\n  return (\r\n    distance <= maxDistance &&\r\n    (minCoincidence == null || coincidence >= minCoincidence)\r\n  );\r\n}\r\n\r\n// Compare two coordinate systems given by matrix1 and matrix2, returning the\r\n// distance between their origins and the \"coorientation\" of their orientations,\r\n// define as the dot product of their quaternion transforms (flipping their\r\n// orientation to be on the same hemisphere if necessary).\r\nexport function coorientDist(matrix1: THREE.Matrix4, matrix2: THREE.Matrix4) {\r\n  const [origin1, rotate1] = [new THREE.Vector3(), new THREE.Quaternion()];\r\n  const [origin2, rotate2] = [new THREE.Vector3(), new THREE.Quaternion()];\r\n  matrix1.decompose(origin1, rotate1, new THREE.Vector3());\r\n  matrix2.decompose(origin2, rotate2, new THREE.Vector3());\r\n\r\n  const distance = origin1.distanceTo(origin2);\r\n  const coorient = Math.abs(rotate1.dot(rotate2));\r\n  return { distance, coorient };\r\n}\r\n\r\n// Utility function that returns whether two coordinate systems are \"close\"\r\n// to each other, defined a maxDistance and a minCoorient.\r\nexport function withinCoorientDist({\r\n  matrix1,\r\n  matrix2,\r\n  maxDistance,\r\n  minCoorient,\r\n}: {\r\n  matrix1: THREE.Matrix4;\r\n  matrix2: THREE.Matrix4;\r\n  maxDistance: number;\r\n  minCoorient?: number;\r\n}): boolean {\r\n  const { distance, coorient } = coorientDist(matrix1, matrix2);\r\n  return (\r\n    distance <= maxDistance && (minCoorient == null || coorient >= minCoorient)\r\n  );\r\n}\r\n\r\n// Like Math.sign but with a custom epsilon value.\r\nexport function epsilonSign(value: number, epsilon = 0.001): number {\r\n  if (Math.abs(value) < epsilon) {\r\n    return 0;\r\n  }\r\n  return Math.sign(value);\r\n}\r\n\r\n// Encode a THREE.Quaternion into a 24-bit integer, converting the xyz coordinates\r\n// to signed 8-bit integers (w can be derived from xyz), and flipping the sign\r\n// of the quaternion if necessary to make this possible (q == -q for quaternions).\r\nexport function encodeQuatXyz888(q: THREE.Quaternion): number {\r\n  const negQuat = q.w < 0.0;\r\n  const iQuatX = floatToSint8(negQuat ? -q.x : q.x);\r\n  const iQuatY = floatToSint8(negQuat ? -q.y : q.y);\r\n  const iQuatZ = floatToSint8(negQuat ? -q.z : q.z);\r\n  const uQuatX = iQuatX & 0xff;\r\n  const uQuatY = iQuatY & 0xff;\r\n  const uQuatZ = iQuatZ & 0xff;\r\n  return uQuatX | (uQuatY << 8) | (uQuatZ << 16);\r\n}\r\n\r\n// Decode a 24-bit integer of the quaternion's xyz coordinates into a THREE.Quaternion.\r\nexport function decodeQuatXyz888(\r\n  encoded: number,\r\n  out: THREE.Quaternion,\r\n): THREE.Quaternion {\r\n  const iQuatX = (encoded << 24) >> 24;\r\n  const iQuatY = (encoded << 16) >> 24;\r\n  const iQuatZ = (encoded << 8) >> 24;\r\n  out.set(iQuatX / 127.0, iQuatY / 127.0, iQuatZ / 127.0, 0.0);\r\n  const dotSelf = out.x * out.x + out.y * out.y + out.z * out.z;\r\n  out.w = Math.sqrt(Math.max(0.0, 1.0 - dotSelf));\r\n  return out;\r\n}\r\n\r\n// Temporary storage used in `encodeQuatOCtXy88R8` and `decodeQuatOctXy88R8` to\r\n// avoid allocation new Quaternions and Vector3 instances.\r\nconst tempNormalizedQuaternion = new THREE.Quaternion();\r\nconst tempAxis = new THREE.Vector3();\r\n\r\n/**\r\n * Encodes a THREE.Quaternion into a 24bit integer.\r\n *\r\n * Bit layout (LSB  MSB):\r\n *   - Bits  07:  quantized U (8 bits)\r\n *   - Bits  815: quantized V (8 bits)\r\n *   - Bits 1623: quantized angle  (8 bits) from [0,]\r\n *\r\n * This version uses folded octahedral mapping (all inline).\r\n */\r\nexport function encodeQuatOctXy88R8(q: THREE.Quaternion): number {\r\n  // Force the minimal representation (q.w >= 0)\r\n  const qnorm = tempNormalizedQuaternion.copy(q).normalize();\r\n  if (qnorm.w < 0) {\r\n    qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\r\n  }\r\n  // Compute the rotation angle  in [0, ]\r\n  const theta = 2 * Math.acos(qnorm.w);\r\n  // Recover the rotation axis (default to (1,0,0) for near-zero rotation)\r\n  const xyz_norm = Math.sqrt(\r\n    qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z,\r\n  );\r\n  const axis =\r\n    xyz_norm < 1e-6\r\n      ? tempAxis.set(1, 0, 0)\r\n      : tempAxis.set(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);\r\n  // const foldAxis = (axis.z < 0);\r\n\r\n  // --- Folded Octahedral Mapping (inline) ---\r\n  // Compute p = (axis.x, axis.y) / (|axis.x|+|axis.y|+|axis.z|)\r\n  const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);\r\n  let p_x = axis.x / sum;\r\n  let p_y = axis.y / sum;\r\n  // Fold the lower hemisphere.\r\n  if (axis.z < 0) {\r\n    const tmp = p_x;\r\n    p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\r\n    p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);\r\n  }\r\n  // Remap from [-1,1] to [0,1]\r\n  const u_f = p_x * 0.5 + 0.5;\r\n  const v_f = p_y * 0.5 + 0.5;\r\n  // Quantize to 7 bits (0..127)\r\n  const quantU = Math.round(u_f * 255);\r\n  const quantV = Math.round(v_f * 255);\r\n  // --- Angle Quantization: Quantize   [0,] to 10 bits (0..1023) ---\r\n  const angleInt = Math.round(theta * (255 / Math.PI));\r\n\r\n  // Pack into 24 bits: bits [07]: quantU, [815]: quantV, [1623]: angleInt.\r\n  return (angleInt << 16) | (quantV << 8) | quantU;\r\n}\r\n\r\n/**\r\n * Decodes a 24bit encoded quaternion (packed in a number) back to a THREE.Quaternion.\r\n *\r\n * Assumes the same bit layout as in encodeQuatOctXy88R8.\r\n */\r\nexport function decodeQuatOctXy88R8(\r\n  encoded: number,\r\n  out: THREE.Quaternion,\r\n): THREE.Quaternion {\r\n  // Extract 8bit quantU and quantV, and 8bit angleInt.\r\n  const quantU = encoded & 0xff; // bits 07\r\n  const quantV = (encoded >>> 8) & 0xff; // bits 815\r\n  const angleInt = (encoded >>> 16) & 0xff; // bits 1623\r\n\r\n  // Recover u and v in [0,1] then map to [-1,1]\r\n  const u_f = quantU / 255;\r\n  const v_f = quantV / 255;\r\n  let f_x = (u_f - 0.5) * 2;\r\n  let f_y = (v_f - 0.5) * 2;\r\n  // Inverse folded mapping: recover z from the constraint |p_x|+|p_y|+z = 1.\r\n  const f_z = 1 - (Math.abs(f_x) + Math.abs(f_y));\r\n  const t = Math.max(-f_z, 0);\r\n  f_x += f_x >= 0 ? -t : t;\r\n  f_y += f_y >= 0 ? -t : t;\r\n  const axis = tempAxis.set(f_x, f_y, f_z).normalize();\r\n\r\n  // Decode the angle:   [0,]\r\n  const theta = (angleInt / 255) * Math.PI;\r\n  const halfTheta = theta * 0.5;\r\n  const s = Math.sin(halfTheta);\r\n  const w = Math.cos(halfTheta);\r\n  // Reconstruct the quaternion from axis-angle: (axis * sin(/2), cos(/2))\r\n  out.set(axis.x * s, axis.y * s, axis.z * s, w);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Encodes a THREE.Quaternion into a 24bit unsigned integer\r\n * by converting it to Euler angles (roll, pitch, yaw).\r\n * The Euler angles are assumed to be in radians in the range [-, ].\r\n * Each angle is normalized to [0,1] and quantized to 8 bits.\r\n * Bit layout (LSBMSB):\r\n *   - Bits 07:   roll (quantized)\r\n *   - Bits 815:  pitch (quantized)\r\n *   - Bits 1623: yaw (quantized)\r\n */\r\nexport function encodeQuatEulerXyz888(q: THREE.Quaternion): number {\r\n  // Normalize quaternion to ensure a proper rotation.\r\n  const qNorm = q.clone().normalize();\r\n\r\n  // TaitBryan angles (roll, pitch, yaw)\r\n  const sinr_cosp = 2.0 * (qNorm.w * qNorm.x + qNorm.y * qNorm.z);\r\n  const cosr_cosp = 1.0 - 2.0 * (qNorm.x * qNorm.x + qNorm.y * qNorm.y);\r\n  const roll = Math.atan2(sinr_cosp, cosr_cosp);\r\n\r\n  const sinp = 2.0 * (qNorm.w * qNorm.y - qNorm.z * qNorm.x);\r\n  const pitch =\r\n    Math.abs(sinp) >= 1.0 ? Math.sign(sinp) * (Math.PI / 2) : Math.asin(sinp);\r\n\r\n  const siny_cosp = 2.0 * (qNorm.w * qNorm.z + qNorm.x * qNorm.y);\r\n  const cosy_cosp = 1.0 - 2.0 * (qNorm.y * qNorm.y + qNorm.z * qNorm.z);\r\n  const yaw = Math.atan2(siny_cosp, cosy_cosp);\r\n\r\n  // Map each angle from [-, ] to [0, 1]\r\n  const normRoll = (roll + Math.PI) / (2 * Math.PI);\r\n  const normPitch = (pitch + Math.PI) / (2 * Math.PI);\r\n  const normYaw = (yaw + Math.PI) / (2 * Math.PI);\r\n\r\n  // Quantize to 8 bits (0 to 255)\r\n  const rollQ = Math.round(normRoll * 255);\r\n  const pitchQ = Math.round(normPitch * 255);\r\n  const yawQ = Math.round(normYaw * 255);\r\n\r\n  // Pack into a 24-bit unsigned integer:\r\n  //   Bits 07:   rollQ, Bits 815: pitchQ, Bits 1623: yawQ.\r\n  return (yawQ << 16) | (pitchQ << 8) | rollQ;\r\n}\r\n\r\n/**\r\n * Decodes a 24bit unsigned integer into a THREE.Quaternion\r\n * by unpacking three 8bit values (roll, pitch, yaw) in the range [0,255]\r\n * and then converting them back to Euler angles in [-, ] and to a quaternion.\r\n */\r\nexport function decodeQuatEulerXyz888(\r\n  encoded: number,\r\n  out: THREE.Quaternion,\r\n): THREE.Quaternion {\r\n  // Unpack 8bit values.\r\n  const rollQ = encoded & 0xff;\r\n  const pitchQ = (encoded >>> 8) & 0xff;\r\n  const yawQ = (encoded >>> 16) & 0xff;\r\n\r\n  // Convert quantized values back to normalized [0,1] values.\r\n  const normRoll = rollQ / 255;\r\n  const normPitch = pitchQ / 255;\r\n  const normYaw = yawQ / 255;\r\n\r\n  // Map from [0,1] to [-, ]\r\n  const roll = normRoll * (2 * Math.PI) - Math.PI;\r\n  const pitch = normPitch * (2 * Math.PI) - Math.PI;\r\n  const yaw = normYaw * (2 * Math.PI) - Math.PI;\r\n\r\n  // Convert Euler angles to quaternion (TaitBryan: roll, pitch, yaw).\r\n  const cr = Math.cos(roll * 0.5);\r\n  const sr = Math.sin(roll * 0.5);\r\n  const cp = Math.cos(pitch * 0.5);\r\n  const sp = Math.sin(pitch * 0.5);\r\n  const cy = Math.cos(yaw * 0.5);\r\n  const sy = Math.sin(yaw * 0.5);\r\n\r\n  out.w = cr * cp * cy + sr * sp * sy;\r\n  out.x = sr * cp * cy - cr * sp * sy;\r\n  out.y = cr * sp * cy + sr * cp * sy;\r\n  out.z = cr * cp * sy - sr * sp * cy;\r\n  out.normalize();\r\n  return out;\r\n}\r\n\r\n// Pack four signed 8-bit values into a single uint32.\r\nfunction packSint8Bytes(\r\n  b0: number,\r\n  b1: number,\r\n  b2: number,\r\n  b3: number,\r\n): number {\r\n  const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));\r\n  const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));\r\n  const clampedB2 = Math.max(-127, Math.min(127, b2 * 127));\r\n  const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));\r\n  return (\r\n    (clampedB0 & 0xff) |\r\n    ((clampedB1 & 0xff) << 8) |\r\n    ((clampedB2 & 0xff) << 16) |\r\n    ((clampedB3 & 0xff) << 24)\r\n  );\r\n}\r\n\r\n// Encode an array of 9 signed RGB SH1 coefficients (clamped to [-1,1]) into\r\n// a pair of uint32 values, where each coefficient is stored as a sint7\r\nexport function encodeSh1Rgb(\r\n  sh1Array: Uint32Array,\r\n  index: number,\r\n  sh1Rgb: Float32Array,\r\n  encoding?: {\r\n    sh1Min?: number;\r\n    sh1Max?: number;\r\n  },\r\n) {\r\n  const sh1Min = encoding?.sh1Min ?? -1;\r\n  const sh1Max = encoding?.sh1Max ?? 1;\r\n  const sh1Mid = 0.5 * (sh1Min + sh1Max);\r\n  const sh1Scale = 126 / (sh1Max - sh1Min);\r\n\r\n  // Pack sint7 values into 2 x uint32\r\n  const base = index * 2;\r\n  for (let i = 0; i < 9; ++i) {\r\n    const s = (sh1Rgb[i] - sh1Mid) * sh1Scale;\r\n    const value = Math.round(Math.max(-63, Math.min(63, s))) & 0x7f;\r\n    const bitStart = i * 7;\r\n    const bitEnd = bitStart + 7;\r\n\r\n    const wordStart = Math.floor(bitStart / 32);\r\n    const bitOffset = bitStart - wordStart * 32;\r\n    const firstWord = (value << bitOffset) & 0xffffffff;\r\n    sh1Array[base + wordStart] |= firstWord;\r\n\r\n    if (bitEnd > wordStart * 32 + 32) {\r\n      const secondWord = (value >>> (32 - bitOffset)) & 0xffffffff;\r\n      sh1Array[base + wordStart + 1] |= secondWord;\r\n    }\r\n  }\r\n}\r\n\r\n// Encode an array of 15 signed RGB SH2 coefficients (clamped to [-1,1]) into\r\n// an array of 4 uint32 values, where each coefficient is stored as a sint8.\r\nexport function encodeSh2Rgb(\r\n  sh2Array: Uint32Array,\r\n  index: number,\r\n  sh2Rgb: Float32Array,\r\n  encoding?: {\r\n    sh2Min?: number;\r\n    sh2Max?: number;\r\n  },\r\n) {\r\n  const sh2Min = encoding?.sh2Min ?? -1;\r\n  const sh2Max = encoding?.sh2Max ?? 1;\r\n  const sh2Mid = 0.5 * (sh2Min + sh2Max);\r\n  const sh2Scale = 2 / (sh2Max - sh2Min);\r\n\r\n  // Pack sint8 values into 4 x uint32\r\n  sh2Array[index * 4 + 0] = packSint8Bytes(\r\n    (sh2Rgb[0] - sh2Mid) * sh2Scale,\r\n    (sh2Rgb[1] - sh2Mid) * sh2Scale,\r\n    (sh2Rgb[2] - sh2Mid) * sh2Scale,\r\n    (sh2Rgb[3] - sh2Mid) * sh2Scale,\r\n  );\r\n  sh2Array[index * 4 + 1] = packSint8Bytes(\r\n    (sh2Rgb[4] - sh2Mid) * sh2Scale,\r\n    (sh2Rgb[5] - sh2Mid) * sh2Scale,\r\n    (sh2Rgb[6] - sh2Mid) * sh2Scale,\r\n    (sh2Rgb[7] - sh2Mid) * sh2Scale,\r\n  );\r\n  sh2Array[index * 4 + 2] = packSint8Bytes(\r\n    (sh2Rgb[8] - sh2Mid) * sh2Scale,\r\n    (sh2Rgb[9] - sh2Mid) * sh2Scale,\r\n    (sh2Rgb[10] - sh2Mid) * sh2Scale,\r\n    (sh2Rgb[11] - sh2Mid) * sh2Scale,\r\n  );\r\n  sh2Array[index * 4 + 3] = packSint8Bytes(\r\n    (sh2Rgb[12] - sh2Mid) * sh2Scale,\r\n    (sh2Rgb[13] - sh2Mid) * sh2Scale,\r\n    (sh2Rgb[14] - sh2Mid) * sh2Scale,\r\n    0,\r\n  );\r\n}\r\n\r\n// Encode an array of 21 signed RGB SH3 coefficients (clamped to [-1,1]) into\r\n// an array of 4 uint32 values, where each coefficient is stored as a sint6.\r\nexport function encodeSh3Rgb(\r\n  sh3Array: Uint32Array,\r\n  index: number,\r\n  sh3Rgb: Float32Array,\r\n  encoding?: {\r\n    sh3Min?: number;\r\n    sh3Max?: number;\r\n  },\r\n) {\r\n  const sh3Min = encoding?.sh3Min ?? -1;\r\n  const sh3Max = encoding?.sh3Max ?? 1;\r\n  const sh3Mid = 0.5 * (sh3Min + sh3Max);\r\n  const sh3Scale = 62 / (sh3Max - sh3Min);\r\n\r\n  // Pack sint6 values into 4 x uint32\r\n  const base = index * 4;\r\n  for (let i = 0; i < 21; ++i) {\r\n    const s = (sh3Rgb[i] - sh3Mid) * sh3Scale;\r\n    const value = Math.round(Math.max(-31, Math.min(31, s))) & 0x3f;\r\n    const bitStart = i * 6;\r\n    const bitEnd = bitStart + 6;\r\n\r\n    const wordStart = Math.floor(bitStart / 32);\r\n    const bitOffset = bitStart - wordStart * 32;\r\n    const firstWord = (value << bitOffset) & 0xffffffff;\r\n    sh3Array[base + wordStart] |= firstWord;\r\n\r\n    if (bitEnd > wordStart * 32 + 32) {\r\n      const secondWord = (value >>> (32 - bitOffset)) & 0xffffffff;\r\n      sh3Array[base + wordStart + 1] |= secondWord;\r\n    }\r\n  }\r\n}\r\n\r\n// Partially decompress a gzip-encoded Uint8Array, returning a Uint8Array of\r\n// the specified numBytes from the start of the file.\r\nexport function decompressPartialGzip(\r\n  fileBytes: Uint8Array,\r\n  numBytes: number,\r\n): Uint8Array {\r\n  const chunks: Uint8Array[] = [];\r\n  let totalBytes = 0;\r\n  let result: Uint8Array | null = null;\r\n\r\n  const gunzip = new Gunzip((data, final) => {\r\n    chunks.push(data);\r\n    totalBytes += data.length;\r\n    if (final || totalBytes >= numBytes) {\r\n      const allBytes = new Uint8Array(totalBytes);\r\n      let offset = 0;\r\n      for (const chunk of chunks) {\r\n        allBytes.set(chunk, offset);\r\n        offset += chunk.length;\r\n      }\r\n      result = allBytes.slice(0, numBytes);\r\n    }\r\n  });\r\n\r\n  const CHUNK_SIZE = 1024;\r\n  let offset = 0;\r\n  while (result == null && offset < fileBytes.length) {\r\n    const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);\r\n    gunzip.push(chunk, false);\r\n    offset += CHUNK_SIZE;\r\n  }\r\n\r\n  if (result == null) {\r\n    gunzip.push(new Uint8Array(), true);\r\n    if (result == null) {\r\n      throw new Error(\"Failed to decompress partial gzip\");\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport class GunzipReader {\r\n  fileBytes: Uint8Array;\r\n  chunkBytes: number;\r\n\r\n  chunks: Uint8Array[];\r\n  totalBytes: number;\r\n  reader: ReadableStreamDefaultReader;\r\n\r\n  constructor({\r\n    fileBytes,\r\n    chunkBytes = 64 * 1024,\r\n  }: { fileBytes: Uint8Array; chunkBytes?: number }) {\r\n    this.fileBytes = fileBytes;\r\n    this.chunkBytes = chunkBytes;\r\n    this.chunks = [];\r\n    this.totalBytes = 0;\r\n\r\n    const ds = new DecompressionStream(\"gzip\");\r\n    const decompressionStream = new Blob([fileBytes]).stream().pipeThrough(ds);\r\n    this.reader = decompressionStream.getReader();\r\n  }\r\n\r\n  async read(numBytes: number): Promise<Uint8Array> {\r\n    while (this.totalBytes < numBytes) {\r\n      const { value: chunk, done: readerDone } = await this.reader.read();\r\n      if (readerDone) {\r\n        break;\r\n      }\r\n\r\n      this.chunks.push(chunk);\r\n      this.totalBytes += chunk.length;\r\n    }\r\n\r\n    if (this.totalBytes < numBytes) {\r\n      throw new Error(\r\n        `Unexpected EOF: needed ${numBytes}, got ${this.totalBytes}`,\r\n      );\r\n    }\r\n\r\n    const allBytes = new Uint8Array(this.totalBytes);\r\n    let outOffset = 0;\r\n    for (const chunk of this.chunks) {\r\n      allBytes.set(chunk, outOffset);\r\n      outOffset += chunk.length;\r\n    }\r\n\r\n    const result = allBytes.subarray(0, numBytes);\r\n    this.chunks = [allBytes.subarray(numBytes)];\r\n    this.totalBytes -= numBytes;\r\n    return result;\r\n  }\r\n}\r\n","import * as THREE from \"three\";\r\n\r\nimport { IDENT_VERTEX_SHADER } from \"../utils\";\r\nimport { Compilation, type Dyno, type IOTypes } from \"./base\";\r\n\r\nexport class DynoProgram {\r\n  graph: Dyno<IOTypes, IOTypes>;\r\n  template: DynoProgramTemplate;\r\n  inputs: Record<string, string>;\r\n  outputs: Record<string, string>;\r\n  shader: string;\r\n  uniforms: Record<string, THREE.IUniform>;\r\n  updaters: (() => void)[];\r\n\r\n  constructor({\r\n    graph,\r\n    inputs,\r\n    outputs,\r\n    template,\r\n  }: {\r\n    graph: Dyno<IOTypes, IOTypes>;\r\n    inputs?: Record<string, string>;\r\n    outputs?: Record<string, string>;\r\n    template: DynoProgramTemplate;\r\n  }) {\r\n    this.graph = graph;\r\n    this.template = template;\r\n    this.inputs = inputs ?? {};\r\n    this.outputs = outputs ?? {};\r\n\r\n    const compile = new Compilation({ indent: this.template.indent });\r\n    for (const key in this.outputs) {\r\n      if (this.outputs[key]) {\r\n        compile.declares.add(this.outputs[key]);\r\n      }\r\n    }\r\n    const statements = graph.compile({\r\n      inputs: this.inputs,\r\n      outputs: this.outputs,\r\n      compile,\r\n    });\r\n\r\n    this.shader = template.generate({ globals: compile.globals, statements });\r\n    this.uniforms = compile.uniforms;\r\n    this.updaters = compile.updaters;\r\n    // console.log(\"*** COMPILED SHADER\", this.shader);\r\n    // console.log(\"*** UNIFORMS\", this.uniforms);\r\n  }\r\n\r\n  prepareMaterial(): THREE.RawShaderMaterial {\r\n    return getMaterial(this);\r\n  }\r\n\r\n  update() {\r\n    for (const updater of this.updaters) {\r\n      updater();\r\n    }\r\n  }\r\n}\r\n\r\nexport class DynoProgramTemplate {\r\n  before: string;\r\n  between: string;\r\n  after: string;\r\n  indent: string;\r\n\r\n  constructor(template: string) {\r\n    const globals = template.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m);\r\n    const statements = template.match(/^([ \\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);\r\n    if (!globals || !statements) {\r\n      throw new Error(\r\n        \"Template must contain {{ GLOBALS }} and {{ STATEMENTS }}\",\r\n      );\r\n    }\r\n\r\n    this.before = template.substring(0, globals.index);\r\n    this.between = template.substring(\r\n      (globals.index as number) + globals[0].length,\r\n      statements.index,\r\n    );\r\n    this.after = template.substring(\r\n      (statements.index as number) + statements[0].length,\r\n    );\r\n    this.indent = statements[1];\r\n  }\r\n\r\n  generate({\r\n    globals,\r\n    statements,\r\n  }: { globals: Set<string>; statements: string[] }): string {\r\n    return (\r\n      this.before +\r\n      Array.from(globals).join(\"\\n\\n\") +\r\n      this.between +\r\n      statements.map((s) => this.indent + s).join(\"\\n\") +\r\n      this.after\r\n    );\r\n  }\r\n}\r\n\r\nconst programMaterial = new Map<DynoProgram, THREE.RawShaderMaterial>();\r\n\r\nfunction getMaterial(program: DynoProgram): THREE.RawShaderMaterial {\r\n  let material = programMaterial.get(program);\r\n  if (material) {\r\n    return material;\r\n  }\r\n\r\n  material = new THREE.RawShaderMaterial({\r\n    glslVersion: THREE.GLSL3,\r\n    vertexShader: IDENT_VERTEX_SHADER,\r\n    fragmentShader: program.shader,\r\n    uniforms: program.uniforms,\r\n  });\r\n  programMaterial.set(program, material);\r\n  return material;\r\n}\r\n","import {\r\n  type AllFloatTypes,\r\n  type AllIntTypes,\r\n  type AllSignedTypes,\r\n  type AllValueTypes,\r\n  type BaseType,\r\n  type BoolTypes,\r\n  type FloatTypes,\r\n  type IntTypes,\r\n  type SignedTypes,\r\n  type UintTypes,\r\n  type ValueTypes,\r\n  isAllFloatType,\r\n  isFloatType,\r\n  isIntType,\r\n  isMat2,\r\n  isMat3,\r\n  isMat4,\r\n  isUintType,\r\n} from \"./types\";\r\n\r\nexport type AddOutput<\r\n  A extends AllValueTypes,\r\n  B extends AllValueTypes,\r\n> = BaseType &\r\n  (A extends B\r\n    ? A\r\n    : A extends \"int\"\r\n      ? B extends IntTypes\r\n        ? B\r\n        : never\r\n      : B extends \"int\"\r\n        ? A extends IntTypes\r\n          ? A\r\n          : never\r\n        : A extends \"uint\"\r\n          ? B extends UintTypes\r\n            ? B\r\n            : never\r\n          : B extends \"uint\"\r\n            ? A extends UintTypes\r\n              ? A\r\n              : never\r\n            : A extends \"float\"\r\n              ? B extends AllFloatTypes\r\n                ? B\r\n                : never\r\n              : B extends \"float\"\r\n                ? A extends AllFloatTypes\r\n                  ? A\r\n                  : never\r\n                : never);\r\n\r\nexport type SubOutput<\r\n  A extends AllValueTypes,\r\n  B extends AllValueTypes,\r\n> = AddOutput<A, B>;\r\n\r\nexport type MulOutput<\r\n  A extends AllValueTypes,\r\n  B extends AllValueTypes,\r\n> = BaseType &\r\n  (A extends \"int\"\r\n    ? B extends IntTypes\r\n      ? B\r\n      : never\r\n    : B extends \"int\"\r\n      ? A extends IntTypes\r\n        ? A\r\n        : never\r\n      : A extends \"uint\"\r\n        ? B extends UintTypes\r\n          ? B\r\n          : never\r\n        : B extends \"uint\"\r\n          ? A extends UintTypes\r\n            ? A\r\n            : never\r\n          : A extends \"float\"\r\n            ? B extends AllFloatTypes\r\n              ? B\r\n              : never\r\n            : B extends \"float\"\r\n              ? A extends AllFloatTypes\r\n                ? A\r\n                : never\r\n              : A extends IntTypes\r\n                ? B extends A\r\n                  ? A\r\n                  : never\r\n                : B extends IntTypes\r\n                  ? A extends B\r\n                    ? A\r\n                    : never\r\n                  : A extends UintTypes\r\n                    ? B extends A\r\n                      ? A\r\n                      : never\r\n                    : B extends UintTypes\r\n                      ? A extends B\r\n                        ? A\r\n                        : never\r\n                      : // Vector * Matrix/Vector\r\n                        A extends \"vec2\"\r\n                        ? B extends \"vec2\" | \"mat2\" | \"mat2x2\"\r\n                          ? \"vec2\"\r\n                          : B extends \"mat3x2\"\r\n                            ? \"vec3\"\r\n                            : B extends \"mat4x2\"\r\n                              ? \"vec4\"\r\n                              : never\r\n                        : A extends \"vec3\"\r\n                          ? B extends \"mat2x3\"\r\n                            ? \"vec2\"\r\n                            : B extends \"vec3\" | \"mat3\" | \"mat3x3\"\r\n                              ? \"vec3\"\r\n                              : B extends \"mat4x3\"\r\n                                ? \"vec4\"\r\n                                : never\r\n                          : A extends \"vec4\"\r\n                            ? B extends \"mat2x4\"\r\n                              ? \"vec2\"\r\n                              : B extends \"mat3x4\"\r\n                                ? \"vec3\"\r\n                                : B extends \"vec4\" | \"mat4\" | \"mat4x4\"\r\n                                  ? \"vec4\"\r\n                                  : never\r\n                            : // Matrix * Vector\r\n                              B extends \"vec2\"\r\n                              ? A extends \"mat2\" | \"mat2x2\"\r\n                                ? \"vec2\"\r\n                                : A extends \"mat2x3\"\r\n                                  ? \"vec3\"\r\n                                  : A extends \"mat2x4\"\r\n                                    ? \"vec4\"\r\n                                    : never\r\n                              : B extends \"vec3\"\r\n                                ? A extends \"mat3x2\"\r\n                                  ? \"vec2\"\r\n                                  : A extends \"mat3\" | \"mat3x3\"\r\n                                    ? \"vec3\"\r\n                                    : A extends \"mat3x4\"\r\n                                      ? \"vec4\"\r\n                                      : never\r\n                                : B extends \"vec4\"\r\n                                  ? A extends \"mat4x2\"\r\n                                    ? \"vec2\"\r\n                                    : A extends \"mat4x3\"\r\n                                      ? \"vec3\"\r\n                                      : A extends \"mat4\" | \"mat4x4\"\r\n                                        ? \"vec4\"\r\n                                        : never\r\n                                  : // Matrix * Matrix: mat{Acols}x{Arows} * mat{Bcols}x{Brows} => mat{Bcols}x{Arows}\r\n                                    A extends \"mat2\" | \"mat2x2\" // Acols = 2 => Brows = 2\r\n                                    ? B extends \"mat2\" | \"mat2x2\"\r\n                                      ? \"mat2\"\r\n                                      : B extends \"mat3x2\"\r\n                                        ? \"mat3x2\"\r\n                                        : B extends \"mat4x2\"\r\n                                          ? \"mat4x2\"\r\n                                          : never\r\n                                    : A extends \"mat2x3\" // Acols = 2 => Brows = 2\r\n                                      ? B extends \"mat2\" | \"mat2x2\"\r\n                                        ? \"mat2x3\"\r\n                                        : B extends \"mat3x2\"\r\n                                          ? \"mat3\"\r\n                                          : B extends \"mat4x2\"\r\n                                            ? \"mat4x3\"\r\n                                            : never\r\n                                      : A extends \"mat2x4\" // Acols = 2 => Brows = 2\r\n                                        ? B extends \"mat2\" | \"mat2x2\"\r\n                                          ? \"mat2x4\"\r\n                                          : B extends \"mat3x2\"\r\n                                            ? \"mat3x4\"\r\n                                            : B extends \"mat4x2\"\r\n                                              ? \"mat4\"\r\n                                              : never\r\n                                        : A extends \"mat3x2\" // Acols = 3 => Brows = 3\r\n                                          ? B extends \"mat2x3\"\r\n                                            ? \"mat2\"\r\n                                            : B extends \"mat3\" | \"mat3x3\"\r\n                                              ? \"mat3x2\"\r\n                                              : B extends \"mat4x3\"\r\n                                                ? \"mat4x2\"\r\n                                                : never\r\n                                          : A extends \"mat3\" | \"mat3x3\" // Acols = 3 => Brows = 3\r\n                                            ? B extends \"mat2x3\"\r\n                                              ? \"mat2x3\"\r\n                                              : B extends \"mat3\" | \"mat3x3\"\r\n                                                ? \"mat3\"\r\n                                                : B extends \"mat4x3\"\r\n                                                  ? \"mat4x3\"\r\n                                                  : never\r\n                                            : A extends \"mat3x4\" // Acols = 3 => Brows = 3\r\n                                              ? B extends \"mat2x3\"\r\n                                                ? \"mat2x4\"\r\n                                                : B extends \"mat3\" | \"mat3x3\"\r\n                                                  ? \"mat3x4\"\r\n                                                  : B extends \"mat4x3\"\r\n                                                    ? \"mat4\"\r\n                                                    : never\r\n                                              : A extends \"mat4x2\" // Acols = 4 => Brows = 4\r\n                                                ? B extends \"mat2x4\"\r\n                                                  ? \"mat2\"\r\n                                                  : B extends \"mat3x4\"\r\n                                                    ? \"mat3x2\"\r\n                                                    : B extends\r\n                                                          | \"mat4\"\r\n                                                          | \"mat4x4\"\r\n                                                      ? \"mat4x2\"\r\n                                                      : never\r\n                                                : A extends \"mat4x3\" // Acols = 4 => Brows = 4\r\n                                                  ? B extends \"mat2x4\"\r\n                                                    ? \"mat2x3\"\r\n                                                    : B extends \"mat3x4\"\r\n                                                      ? \"mat3\"\r\n                                                      : B extends\r\n                                                            | \"mat4\"\r\n                                                            | \"mat4x4\"\r\n                                                        ? \"mat4x3\"\r\n                                                        : never\r\n                                                  : A extends \"mat4\" | \"mat4x4\" // Acols = 4 => Brows = 4\r\n                                                    ? B extends \"mat2x4\"\r\n                                                      ? \"mat2x4\"\r\n                                                      : B extends \"mat3x4\"\r\n                                                        ? \"mat3x4\"\r\n                                                        : B extends\r\n                                                              | \"mat4\"\r\n                                                              | \"mat4x4\"\r\n                                                          ? \"mat4\"\r\n                                                          : never\r\n                                                    : never);\r\n\r\nexport type DivOutput<\r\n  A extends AllValueTypes,\r\n  B extends AllValueTypes,\r\n> = AddOutput<A, B>;\r\n\r\nexport type IModOutput<\r\n  A extends AllIntTypes,\r\n  B extends AllIntTypes,\r\n> = BaseType &\r\n  (A extends B\r\n    ? A\r\n    : A extends \"int\"\r\n      ? B extends IntTypes\r\n        ? B\r\n        : never\r\n      : B extends \"int\"\r\n        ? A extends IntTypes\r\n          ? A\r\n          : never\r\n        : A extends \"uint\"\r\n          ? B extends UintTypes\r\n            ? B\r\n            : never\r\n          : B extends \"uint\"\r\n            ? A extends UintTypes\r\n              ? A\r\n              : never\r\n            : never);\r\n\r\nexport type ModOutput<A extends FloatTypes, B extends FloatTypes> = BaseType &\r\n  (A extends B ? A : B extends \"float\" ? A : never);\r\n\r\nexport type PowOutput<A extends FloatTypes, B extends FloatTypes> = BaseType &\r\n  (A extends B ? A : never);\r\n\r\nexport type MinOutput<A extends ValueTypes, B extends ValueTypes> = BaseType &\r\n  (A extends B\r\n    ? A\r\n    : B extends \"float\"\r\n      ? A extends FloatTypes\r\n        ? A\r\n        : never\r\n      : B extends \"int\"\r\n        ? A extends IntTypes\r\n          ? A\r\n          : never\r\n        : B extends \"uint\"\r\n          ? A extends UintTypes\r\n            ? A\r\n            : never\r\n          : never);\r\nexport type MaxOutput<A extends ValueTypes, B extends ValueTypes> = MinOutput<\r\n  A,\r\n  B\r\n>;\r\nexport type ClampOutput<A extends ValueTypes, B extends ValueTypes> = BaseType &\r\n  (B extends \"float\"\r\n    ? A extends FloatTypes\r\n      ? A\r\n      : never\r\n    : B extends \"int\"\r\n      ? A extends IntTypes\r\n        ? A\r\n        : never\r\n      : B extends \"uint\"\r\n        ? A extends UintTypes\r\n          ? A\r\n          : never\r\n        : never);\r\nexport type MixOutput<\r\n  A extends FloatTypes,\r\n  T extends FloatTypes | BoolTypes,\r\n> = BaseType &\r\n  (T extends A\r\n    ? A\r\n    : T extends \"float\"\r\n      ? A\r\n      : T extends \"bool\"\r\n        ? A extends \"float\"\r\n          ? A\r\n          : never\r\n        : T extends \"bvec2\"\r\n          ? A extends \"vec2\"\r\n            ? A\r\n            : never\r\n          : T extends \"bvec3\"\r\n            ? A extends \"vec3\"\r\n              ? A\r\n              : never\r\n            : T extends \"bvec4\"\r\n              ? A extends \"vec4\"\r\n                ? A\r\n                : never\r\n              : never);\r\nexport type StepOutput<A extends FloatTypes, B extends FloatTypes> = BaseType &\r\n  (A extends B ? B : A extends \"float\" ? B : never);\r\nexport type SmoothstepOutput<\r\n  A extends FloatTypes,\r\n  B extends FloatTypes,\r\n  C extends FloatTypes,\r\n> = BaseType &\r\n  (A extends B ? (A extends C ? C : A extends \"float\" ? C : never) : never);\r\n\r\nexport type IsNanOutput<A extends FloatTypes> = BaseType &\r\n  (A extends \"float\"\r\n    ? \"bool\"\r\n    : A extends \"vec2\"\r\n      ? \"bvec2\"\r\n      : A extends \"vec3\"\r\n        ? \"bvec3\"\r\n        : A extends \"vec4\"\r\n          ? \"bvec4\"\r\n          : never);\r\nexport type IsInfOutput<A extends FloatTypes> = IsNanOutput<A>;\r\n\r\n// // Run-time type helper functions\r\n\r\nexport function addOutputType<A extends AllValueTypes, B extends AllValueTypes>(\r\n  a: A,\r\n  b: B,\r\n  operation = \"add\",\r\n): AddOutput<A, B> {\r\n  const error = () => {\r\n    throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\r\n  };\r\n  // @ts-ignore\r\n  if (a === b) return a as AddOutput<A, B>;\r\n  if (a === \"int\") {\r\n    if (isIntType(b)) return b as AddOutput<A, B>;\r\n    error();\r\n  }\r\n  if (b === \"int\") {\r\n    if (isIntType(a)) return a as AddOutput<A, B>;\r\n    error();\r\n  }\r\n  if (a === \"uint\") {\r\n    if (isUintType(b)) return b as AddOutput<A, B>;\r\n    error();\r\n  }\r\n  if (b === \"uint\") {\r\n    if (isUintType(a)) return a as AddOutput<A, B>;\r\n    error();\r\n  }\r\n  if (a === \"float\") {\r\n    if (isAllFloatType(b)) return b as AddOutput<A, B>;\r\n    error();\r\n  }\r\n  if (b === \"float\") {\r\n    if (isAllFloatType(a)) return a as AddOutput<A, B>;\r\n    error();\r\n  }\r\n  throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\r\n}\r\n\r\nexport function subOutputType<A extends AllValueTypes, B extends AllValueTypes>(\r\n  a: A,\r\n  b: B,\r\n): SubOutput<A, B> {\r\n  return addOutputType(a, b, \"sub\");\r\n}\r\n\r\nexport function mulOutputType<A extends AllValueTypes, B extends AllValueTypes>(\r\n  a: A,\r\n  b: B,\r\n): MulOutput<A, B> {\r\n  const error = () => {\r\n    throw new Error(`Invalid mul types: ${a}, ${b}`);\r\n  };\r\n  const result = (value: unknown) => value as MulOutput<A, B>;\r\n  if (a === \"int\") {\r\n    if (isIntType(b)) return result(b);\r\n    error();\r\n  }\r\n  if (b === \"int\") {\r\n    if (isIntType(a)) return result(a);\r\n    error();\r\n  }\r\n  if (a === \"uint\") {\r\n    if (isUintType(b)) return result(b);\r\n    error();\r\n  }\r\n  if (b === \"uint\") {\r\n    if (isUintType(a)) return result(a);\r\n    error();\r\n  }\r\n  if (a === \"float\") {\r\n    if (isAllFloatType(b)) return result(b);\r\n    error();\r\n  }\r\n  if (b === \"float\") {\r\n    if (isAllFloatType(a)) return result(a);\r\n    error();\r\n  }\r\n  if (isIntType(a) || isUintType(a) || isIntType(b) || isUintType(b)) {\r\n    // @ts-ignore\r\n    if (a === b) return result(a);\r\n    error();\r\n  }\r\n  // Vector * Matrix/Vector\r\n  if (a === \"vec2\") {\r\n    if (b === \"vec2\" || isMat2(b)) return result(\"vec2\");\r\n    if (b === \"mat3x2\") return result(\"vec3\");\r\n    if (b === \"mat4x2\") return result(\"vec4\");\r\n    error();\r\n  }\r\n  if (a === \"vec3\") {\r\n    if (b === \"mat2x3\") return result(\"vec2\");\r\n    if (b === \"vec3\" || isMat3(b)) return result(\"vec3\");\r\n    if (b === \"mat4x3\") return result(\"vec4\");\r\n    error();\r\n  }\r\n  if (a === \"vec4\") {\r\n    if (b === \"mat2x4\") return result(\"vec2\");\r\n    if (b === \"mat3x4\") return result(\"vec3\");\r\n    if (b === \"vec4\" || isMat4(b)) return result(\"vec4\");\r\n    error();\r\n  }\r\n  // Matrix * Vector\r\n  if (b === \"vec2\") {\r\n    if (isMat2(a)) return result(\"vec2\");\r\n    if (a === \"mat2x3\") return result(\"vec3\");\r\n    if (a === \"mat2x4\") return result(\"vec4\");\r\n    error();\r\n  }\r\n  if (b === \"vec3\") {\r\n    if (a === \"mat3x2\") return result(\"vec2\");\r\n    if (isMat3(a)) return result(\"vec3\");\r\n    if (a === \"mat3x4\") return result(\"vec4\");\r\n    error();\r\n  }\r\n  if (b === \"vec4\") {\r\n    if (a === \"mat4x2\") return result(\"vec2\");\r\n    if (a === \"mat4x3\") return result(\"vec3\");\r\n    if (isMat4(a)) return result(\"vec4\");\r\n    error();\r\n  }\r\n  // Matrix * Matrix: mat{Acols}x{Arows} * mat{Bcols}x{Brows} => mat{Bcols}x{Arows}\r\n  if (isMat2(a)) {\r\n    if (isMat2(b)) return result(\"mat2\");\r\n    if (b === \"mat3x2\") return result(\"mat3x2\");\r\n    if (b === \"mat4x2\") return result(\"mat4x2\");\r\n    error();\r\n  }\r\n  if (a === \"mat2x3\") {\r\n    if (isMat2(b)) return result(\"mat2x3\");\r\n    if (b === \"mat3x2\") return result(\"mat3\");\r\n    if (b === \"mat4x2\") return result(\"mat4x3\");\r\n    error();\r\n  }\r\n  if (a === \"mat2x4\") {\r\n    if (isMat2(b)) return result(\"mat2x4\");\r\n    if (b === \"mat3x2\") return result(\"mat3x4\");\r\n    if (b === \"mat4x2\") return result(\"mat4\");\r\n    error();\r\n  }\r\n  if (a === \"mat3x2\") {\r\n    if (b === \"mat2x3\") return result(\"mat2\");\r\n    if (isMat3(b)) return result(\"mat3x2\");\r\n    if (b === \"mat4x3\") return result(\"mat4x2\");\r\n    error();\r\n  }\r\n  if (isMat3(a)) {\r\n    if (b === \"mat2x3\") return result(\"mat2x3\");\r\n    if (isMat3(b)) return result(\"mat3\");\r\n    if (b === \"mat4x3\") return result(\"mat4x3\");\r\n    error();\r\n  }\r\n  if (a === \"mat3x4\") {\r\n    if (b === \"mat2x3\") return result(\"mat2x4\");\r\n    if (isMat3(b)) return result(\"mat3x4\");\r\n    if (b === \"mat4x3\") return result(\"mat4\");\r\n    error();\r\n  }\r\n  if (a === \"mat4x2\") {\r\n    if (b === \"mat2x4\") return result(\"mat2\");\r\n    if (b === \"mat3x4\") return result(\"mat3x2\");\r\n    if (isMat4(b)) return result(\"mat4x2\");\r\n    error();\r\n  }\r\n  if (a === \"mat4x3\") {\r\n    if (b === \"mat2x4\") return result(\"mat2x3\");\r\n    if (b === \"mat3x4\") return result(\"mat3\");\r\n    if (isMat4(b)) return result(\"mat4x3\");\r\n    error();\r\n  }\r\n  if (isMat4(a)) {\r\n    if (b === \"mat2x4\") return result(\"mat2x4\");\r\n    if (b === \"mat3x4\") return result(\"mat3x4\");\r\n    if (isMat4(b)) return result(\"mat4\");\r\n    error();\r\n  }\r\n  throw new Error(`Invalid mul types: ${a}, ${b}`);\r\n}\r\n\r\nexport function divOutputType<A extends AllValueTypes, B extends AllValueTypes>(\r\n  a: A,\r\n  b: B,\r\n): DivOutput<A, B> {\r\n  return addOutputType(a, b, \"div\");\r\n}\r\n\r\nexport function imodOutputType<A extends AllIntTypes, B extends AllIntTypes>(\r\n  a: A,\r\n  b: B,\r\n): IModOutput<A, B> {\r\n  // @ts-ignore\r\n  if (a === b) return a as IModOutput<A, B>;\r\n  if (a === \"int\") {\r\n    if (isIntType(b)) return b as IModOutput<A, B>;\r\n  } else if (b === \"int\") {\r\n    if (isIntType(a)) return a as IModOutput<A, B>;\r\n  } else if (a === \"uint\") {\r\n    if (isUintType(b)) return b as IModOutput<A, B>;\r\n  } else if (b === \"uint\") {\r\n    if (isUintType(a)) return a as IModOutput<A, B>;\r\n  }\r\n  throw new Error(`Invalid imod types: ${a}, ${b}`);\r\n}\r\n\r\nexport function modOutputType<A extends FloatTypes, B extends FloatTypes>(\r\n  a: A,\r\n  b: B,\r\n): ModOutput<A, B> {\r\n  // @ts-ignore\r\n  if (a === b || b === \"float\") return a as ModOutput<A, B>;\r\n  throw new Error(`Invalid mod types: ${a}, ${b}`);\r\n}\r\n\r\nexport function modfOutputType<A extends FloatTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function negOutputType<A extends AllSignedTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function absOutputType<A extends SignedTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function signOutputType<A extends SignedTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function floorOutputType<A extends FloatTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function ceilOutputType<A extends FloatTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function truncOutputType<A extends FloatTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function roundOutputType<A extends FloatTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function fractOutputType<A extends FloatTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function powOutputType<A extends FloatTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function expOutputType<A extends FloatTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function exp2OutputType<A extends FloatTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function logOutputType<A extends FloatTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function log2OutputType<A extends FloatTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function sqrOutputType<A extends ValueTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function sqrtOutputType<A extends FloatTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function inversesqrtOutputType<A extends FloatTypes>(a: A): A {\r\n  return a;\r\n}\r\n\r\nexport function minOutputType<A extends ValueTypes, B extends ValueTypes>(\r\n  a: A,\r\n  b: B,\r\n  operation = \"min\",\r\n): MinOutput<A, B> {\r\n  // @ts-ignore\r\n  if (a === b) return a as MinOutput<A, B>;\r\n  if (b === \"float\") {\r\n    if (isFloatType(a)) return a as MinOutput<A, B>;\r\n  } else if (b === \"int\") {\r\n    if (isIntType(a)) return a as MinOutput<A, B>;\r\n  } else if (b === \"uint\") {\r\n    if (isUintType(a)) return a as MinOutput<A, B>;\r\n  }\r\n  throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\r\n}\r\n\r\nexport function maxOutputType<A extends ValueTypes, B extends ValueTypes>(\r\n  a: A,\r\n  b: B,\r\n): MaxOutput<A, B> {\r\n  return minOutputType(a, b, \"max\");\r\n}\r\n\r\nexport function clampOutputType<A extends ValueTypes, B extends ValueTypes>(\r\n  a: A,\r\n  b: B,\r\n  _c: B,\r\n): ClampOutput<A, B> {\r\n  if (b === \"float\") {\r\n    if (isFloatType(a)) return a as ClampOutput<A, B>;\r\n  } else if (b === \"int\") {\r\n    if (isIntType(a)) return a as ClampOutput<A, B>;\r\n  } else if (b === \"uint\") {\r\n    if (isUintType(a)) return a as ClampOutput<A, B>;\r\n  }\r\n  throw new Error(`Invalid clamp types: ${a}, ${b}`);\r\n}\r\n\r\nexport function mixOutputType<\r\n  A extends FloatTypes,\r\n  C extends FloatTypes | BoolTypes,\r\n>(a: A, b: A, c: C): MixOutput<A, C> {\r\n  // @ts-ignore\r\n  if (c === a) return a as MixOutput<A, C>;\r\n  if (c === \"float\") return a as MixOutput<A, C>;\r\n  if (c === \"bool\" && a === \"float\") return a as MixOutput<A, C>;\r\n  if (c === \"bvec2\" && a === \"vec2\") return a as MixOutput<A, C>;\r\n  if (c === \"bvec3\" && a === \"vec3\") return a as MixOutput<A, C>;\r\n  if (c === \"bvec4\" && a === \"vec4\") return a as MixOutput<A, C>;\r\n  throw new Error(`Invalid mix types: ${a}, ${b}, ${c}`);\r\n}\r\n\r\nexport function stepOutputType<A extends FloatTypes, B extends FloatTypes>(\r\n  a: A,\r\n  b: B,\r\n): StepOutput<A, B> {\r\n  // @ts-ignore\r\n  if (a === b || b === \"float\") return b as StepOutput<A, B>;\r\n  throw new Error(`Invalid step types: ${a}, ${b}`);\r\n}\r\n\r\nexport function smoothstepOutputType<\r\n  A extends FloatTypes,\r\n  B extends FloatTypes,\r\n  C extends FloatTypes,\r\n>(a: A, b: B, c: C): SmoothstepOutput<A, B, C> {\r\n  // @ts-ignore\r\n  if (a === b) {\r\n    if (a === c || a === \"float\") return c as SmoothstepOutput<A, B, C>;\r\n  }\r\n  throw new Error(`Invalid smoothstep types: ${a}, ${b}, ${c}`);\r\n}\r\n\r\nexport function isNanOutputType<A extends FloatTypes>(\r\n  a: A,\r\n  operation = \"isNan\",\r\n): IsNanOutput<A> {\r\n  if (a === \"float\") return \"bool\" as IsNanOutput<A>;\r\n  if (a === \"vec2\") return \"bvec2\" as IsNanOutput<A>;\r\n  if (a === \"vec3\") return \"bvec3\" as IsNanOutput<A>;\r\n  if (a === \"vec4\") return \"bvec4\" as IsNanOutput<A>;\r\n  throw new Error(`Invalid ${operation} types: ${a}`);\r\n}\r\n\r\nexport function isInfOutputType<A extends FloatTypes>(a: A): IsInfOutput<A> {\r\n  return isNanOutputType(a, \"isInf\");\r\n}\r\n","import { BinaryOp, Dyno, TrinaryOp, UnaryOp } from \"./base\";\r\nimport {\r\n  type AddOutput,\r\n  type ClampOutput,\r\n  type DivOutput,\r\n  type IModOutput,\r\n  type IsInfOutput,\r\n  type IsNanOutput,\r\n  type MaxOutput,\r\n  type MinOutput,\r\n  type MixOutput,\r\n  type ModOutput,\r\n  type MulOutput,\r\n  type SmoothstepOutput,\r\n  type StepOutput,\r\n  type SubOutput,\r\n  absOutputType,\r\n  addOutputType,\r\n  ceilOutputType,\r\n  clampOutputType,\r\n  divOutputType,\r\n  exp2OutputType,\r\n  expOutputType,\r\n  floorOutputType,\r\n  fractOutputType,\r\n  imodOutputType,\r\n  inversesqrtOutputType,\r\n  isInfOutputType,\r\n  isNanOutputType,\r\n  log2OutputType,\r\n  logOutputType,\r\n  maxOutputType,\r\n  minOutputType,\r\n  mixOutputType,\r\n  modOutputType,\r\n  modfOutputType,\r\n  mulOutputType,\r\n  negOutputType,\r\n  powOutputType,\r\n  roundOutputType,\r\n  signOutputType,\r\n  smoothstepOutputType,\r\n  sqrOutputType,\r\n  sqrtOutputType,\r\n  stepOutputType,\r\n  subOutputType,\r\n  truncOutputType,\r\n} from \"./mathTypes\";\r\nimport type {\r\n  AllIntTypes,\r\n  AllSignedTypes,\r\n  AllValueTypes,\r\n  BoolTypes,\r\n  FloatTypes,\r\n  SignedTypes,\r\n  ValueTypes,\r\n} from \"./types\";\r\nimport { type DynoVal, valType } from \"./value\";\r\n\r\nexport const add = <A extends AllValueTypes, B extends AllValueTypes>(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<B>,\r\n): DynoVal<AddOutput<A, B>> => new Add({ a, b });\r\nexport const sub = <A extends AllValueTypes, B extends AllValueTypes>(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<B>,\r\n): DynoVal<SubOutput<A, B>> => new Sub({ a, b });\r\nexport const mul = <A extends AllValueTypes, B extends AllValueTypes>(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<B>,\r\n): DynoVal<MulOutput<A, B>> => new Mul({ a, b });\r\nexport const div = <A extends AllValueTypes, B extends AllValueTypes>(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<B>,\r\n): DynoVal<DivOutput<A, B>> => new Div({ a, b });\r\nexport const imod = <A extends AllIntTypes, B extends AllIntTypes>(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<B>,\r\n): DynoVal<IModOutput<A, B>> => new IMod({ a, b });\r\nexport const mod = <A extends FloatTypes, B extends FloatTypes>(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<B>,\r\n): DynoVal<ModOutput<A, B>> => new Mod({ a, b });\r\nexport const modf = <A extends FloatTypes>(a: DynoVal<A>) =>\r\n  new Modf({ a }).outputs;\r\n\r\nexport const neg = <A extends AllSignedTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Neg({ a });\r\nexport const abs = <A extends SignedTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Abs({ a });\r\nexport const sign = <A extends SignedTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Sign({ a });\r\nexport const floor = <A extends FloatTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Floor({ a });\r\nexport const ceil = <A extends FloatTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Ceil({ a });\r\nexport const trunc = <A extends FloatTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Trunc({ a });\r\nexport const round = <A extends FloatTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Round({ a });\r\nexport const fract = <A extends FloatTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Fract({ a });\r\n\r\nexport const pow = <A extends FloatTypes>(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<A>,\r\n): DynoVal<A> => new Pow({ a, b });\r\nexport const exp = <A extends FloatTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Exp({ a });\r\nexport const exp2 = <A extends FloatTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Exp2({ a });\r\nexport const log = <A extends FloatTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Log({ a });\r\nexport const log2 = <A extends FloatTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Log2({ a });\r\nexport const sqr = <A extends ValueTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Sqr({ a });\r\nexport const sqrt = <A extends FloatTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Sqrt({ a });\r\nexport const inversesqrt = <A extends FloatTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new InverseSqrt({ a });\r\n\r\nexport const min = <A extends ValueTypes, B extends ValueTypes>(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<B>,\r\n): DynoVal<MinOutput<A, B>> => new Min({ a, b });\r\nexport const max = <A extends ValueTypes, B extends ValueTypes>(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<B>,\r\n): DynoVal<MaxOutput<A, B>> => new Max({ a, b });\r\nexport const clamp = <A extends ValueTypes, MinMax extends ValueTypes>(\r\n  a: DynoVal<A>,\r\n  min: DynoVal<MinMax>,\r\n  max: DynoVal<MinMax>,\r\n): DynoVal<ClampOutput<A, MinMax>> => new Clamp({ a, min, max });\r\nexport const mix = <A extends FloatTypes, T extends FloatTypes | BoolTypes>(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<A>,\r\n  t: DynoVal<T>,\r\n): DynoVal<MixOutput<A, T>> => new Mix({ a, b, t });\r\nexport const step = <A extends FloatTypes, B extends FloatTypes>(\r\n  edge: DynoVal<A>,\r\n  x: DynoVal<B>,\r\n): DynoVal<StepOutput<A, B>> => new Step({ edge, x });\r\nexport const smoothstep = <X extends FloatTypes, Edge extends X | \"float\">(\r\n  edge0: DynoVal<Edge>,\r\n  edge1: DynoVal<Edge>,\r\n  x: DynoVal<X>,\r\n): DynoVal<SmoothstepOutput<Edge, Edge, X>> =>\r\n  new Smoothstep({ edge0, edge1, x });\r\n\r\nexport const isNan = <A extends FloatTypes>(\r\n  a: DynoVal<A>,\r\n): DynoVal<IsNanOutput<A>> => new IsNan({ a });\r\nexport const isInf = <A extends FloatTypes>(\r\n  a: DynoVal<A>,\r\n): DynoVal<IsInfOutput<A>> => new IsInf({ a });\r\n\r\nexport class Add<\r\n  A extends AllValueTypes,\r\n  B extends AllValueTypes,\r\n> extends BinaryOp<A, B, AddOutput<A, B>, \"sum\"> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<B> }) {\r\n    super({ a, b, outKey: \"sum\", outTypeFunc: addOutputType<A, B> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.sum} = ${inputs.a} + ${inputs.b};`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Sub<\r\n  A extends AllValueTypes,\r\n  B extends AllValueTypes,\r\n> extends BinaryOp<A, B, SubOutput<A, B>, \"difference\"> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<B> }) {\r\n    super({ a, b, outKey: \"difference\", outTypeFunc: subOutputType<A, B> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.difference} = ${inputs.a} - ${inputs.b};`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Mul<\r\n  A extends AllValueTypes,\r\n  B extends AllValueTypes,\r\n> extends BinaryOp<A, B, MulOutput<A, B>, \"product\"> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<B> }) {\r\n    super({ a, b, outKey: \"product\", outTypeFunc: mulOutputType<A, B> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.product} = ${inputs.a} * ${inputs.b};`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Div<\r\n  A extends AllValueTypes,\r\n  B extends AllValueTypes,\r\n> extends BinaryOp<A, B, DivOutput<A, B>, \"quotient\"> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<B> }) {\r\n    super({ a, b, outKey: \"quotient\", outTypeFunc: divOutputType<A, B> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.quotient} = ${inputs.a} / ${inputs.b};`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class IMod<\r\n  A extends AllIntTypes,\r\n  B extends AllIntTypes,\r\n> extends BinaryOp<A, B, IModOutput<A, B>, \"remainder\"> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<B> }) {\r\n    super({ a, b, outKey: \"remainder\", outTypeFunc: imodOutputType<A, B> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.remainder} = ${inputs.a} % ${inputs.b};`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Mod<A extends FloatTypes, B extends FloatTypes> extends BinaryOp<\r\n  A,\r\n  B,\r\n  ModOutput<A, B>,\r\n  \"remainder\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<B> }) {\r\n    super({ a, b, outKey: \"remainder\", outTypeFunc: modOutputType<A, B> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.remainder} = mod(${inputs.a}, ${inputs.b});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Modf<A extends FloatTypes> extends Dyno<\r\n  { a: A },\r\n  { fract: A; integer: A }\r\n> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    const inTypes = { a: valType(a) };\r\n    const outType = modfOutputType<A>(inTypes.a);\r\n    const outTypes = {\r\n      fract: outType,\r\n      integer: outType,\r\n    };\r\n    super({ inTypes, outTypes, inputs: { a } });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.fract} = modf(${inputs.a}, ${outputs.integer});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Neg<A extends AllSignedTypes> extends UnaryOp<A, A, \"neg\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"neg\", outTypeFunc: negOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.neg} = -${inputs.a};`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Abs<A extends SignedTypes> extends UnaryOp<A, A, \"abs\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"abs\", outTypeFunc: absOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.abs} = abs(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Sign<A extends SignedTypes> extends UnaryOp<A, A, \"sign\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"sign\", outTypeFunc: signOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.sign} = sign(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Floor<A extends FloatTypes> extends UnaryOp<A, A, \"floor\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"floor\", outTypeFunc: floorOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.floor} = floor(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Ceil<A extends FloatTypes> extends UnaryOp<A, A, \"ceil\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"ceil\", outTypeFunc: ceilOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.ceil} = ceil(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Trunc<A extends FloatTypes> extends UnaryOp<A, A, \"trunc\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"trunc\", outTypeFunc: truncOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.trunc} = trunc(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Round<A extends FloatTypes> extends UnaryOp<A, A, \"round\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"round\", outTypeFunc: roundOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.round} = round(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Fract<A extends FloatTypes> extends UnaryOp<A, A, \"fract\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"fract\", outTypeFunc: fractOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.fract} = fract(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Pow<A extends FloatTypes> extends BinaryOp<A, A, A, \"power\"> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<A> }) {\r\n    super({ a, b, outKey: \"power\", outTypeFunc: powOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.power} = pow(${inputs.a}, ${inputs.b});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Exp<A extends FloatTypes> extends UnaryOp<A, A, \"exp\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"exp\", outTypeFunc: expOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.exp} = exp(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Exp2<A extends FloatTypes> extends UnaryOp<A, A, \"exp2\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"exp2\", outTypeFunc: exp2OutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.exp2} = exp2(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Log<A extends FloatTypes> extends UnaryOp<A, A, \"log\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"log\", outTypeFunc: logOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.log} = log(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Log2<A extends FloatTypes> extends UnaryOp<A, A, \"log2\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"log2\", outTypeFunc: log2OutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.log2} = log2(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Sqr<A extends ValueTypes> extends UnaryOp<A, A, \"sqr\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"sqr\", outTypeFunc: sqrOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.sqr} = ${inputs.a} * ${inputs.a};`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Sqrt<A extends FloatTypes> extends UnaryOp<A, A, \"sqrt\"> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"sqrt\", outTypeFunc: sqrtOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.sqrt} = sqrt(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class InverseSqrt<A extends FloatTypes> extends UnaryOp<\r\n  A,\r\n  A,\r\n  \"inversesqrt\"\r\n> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"inversesqrt\", outTypeFunc: inversesqrtOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.inversesqrt} = inversesqrt(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Min<A extends ValueTypes, B extends ValueTypes> extends BinaryOp<\r\n  A,\r\n  B,\r\n  MinOutput<A, B>,\r\n  \"min\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<B> }) {\r\n    super({ a, b, outKey: \"min\", outTypeFunc: minOutputType<A, B> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.min} = min(${inputs.a}, ${inputs.b});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Max<A extends ValueTypes, B extends ValueTypes> extends BinaryOp<\r\n  A,\r\n  B,\r\n  MaxOutput<A, B>,\r\n  \"max\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<B> }) {\r\n    super({ a, b, outKey: \"max\", outTypeFunc: maxOutputType<A, B> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.max} = max(${inputs.a}, ${inputs.b});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Clamp<\r\n  A extends ValueTypes,\r\n  MinMax extends ValueTypes,\r\n> extends TrinaryOp<A, MinMax, MinMax, ClampOutput<A, MinMax>, \"clamp\"> {\r\n  constructor({\r\n    a,\r\n    min,\r\n    max,\r\n  }: { a: DynoVal<A>; min: DynoVal<MinMax>; max: DynoVal<MinMax> }) {\r\n    super({\r\n      a,\r\n      b: min,\r\n      c: max,\r\n      outKey: \"clamp\",\r\n      outTypeFunc: clampOutputType<A, MinMax>,\r\n    });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      const { a, b: min, c: max } = inputs;\r\n      return [`${outputs.clamp} = clamp(${a}, ${min}, ${max});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Mix<\r\n  A extends FloatTypes,\r\n  T extends FloatTypes | BoolTypes,\r\n> extends TrinaryOp<A, A, T, MixOutput<A, T>, \"mix\"> {\r\n  constructor({ a, b, t }: { a: DynoVal<A>; b: DynoVal<A>; t: DynoVal<T> }) {\r\n    super({ a, b, c: t, outKey: \"mix\", outTypeFunc: mixOutputType<A, T> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      const { a, b, c: t } = inputs;\r\n      return [`${outputs.mix} = mix(${a}, ${b}, ${t});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Step<\r\n  Edge extends FloatTypes,\r\n  X extends FloatTypes,\r\n> extends BinaryOp<Edge, X, StepOutput<Edge, X>, \"step\"> {\r\n  constructor({ edge, x }: { edge: DynoVal<Edge>; x: DynoVal<X> }) {\r\n    super({\r\n      a: edge,\r\n      b: x,\r\n      outKey: \"step\",\r\n      outTypeFunc: stepOutputType<Edge, X>,\r\n    });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      const { a: edge, b: x } = inputs;\r\n      return [`${outputs.step} = step(${edge}, ${x});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Smoothstep<\r\n  X extends FloatTypes,\r\n  Edge extends X | \"float\",\r\n> extends TrinaryOp<\r\n  Edge,\r\n  Edge,\r\n  X,\r\n  SmoothstepOutput<Edge, Edge, X>,\r\n  \"smoothstep\"\r\n> {\r\n  constructor({\r\n    edge0,\r\n    edge1,\r\n    x,\r\n  }: { edge0: DynoVal<Edge>; edge1: DynoVal<Edge>; x: DynoVal<X> }) {\r\n    super({\r\n      a: edge0,\r\n      b: edge1,\r\n      c: x,\r\n      outKey: \"smoothstep\",\r\n      outTypeFunc: smoothstepOutputType<Edge, Edge, X>,\r\n    });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      const { a: edge0, b: edge1, c: x } = inputs;\r\n      return [`${outputs.smoothstep} = smoothstep(${edge0}, ${edge1}, ${x});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class IsNan<A extends FloatTypes> extends UnaryOp<\r\n  A,\r\n  IsNanOutput<A>,\r\n  \"isNan\"\r\n> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"isNan\", outTypeFunc: isNanOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.isNan} = isNan(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class IsInf<A extends FloatTypes> extends UnaryOp<\r\n  A,\r\n  IsInfOutput<A>,\r\n  \"isInf\"\r\n> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"isInf\", outTypeFunc: isInfOutputType<A> });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.isInf} = isInf(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n","import { BinaryOp, TrinaryOp, UnaryOp } from \"./base\";\r\nimport {\r\n  type AllIntTypes,\r\n  type BoolTypes,\r\n  type IntTypes,\r\n  type ScalarTypes,\r\n  type SimpleTypes,\r\n  type UintTypes,\r\n  type ValueTypes,\r\n  isBoolType,\r\n  isIntType,\r\n  isScalarType,\r\n  isUintType,\r\n  isVector2Type,\r\n  isVector3Type,\r\n} from \"./types\";\r\nimport { type DynoVal, valType } from \"./value\";\r\n\r\nexport const and = <T extends \"bool\" | AllIntTypes>(\r\n  a: DynoVal<T>,\r\n  b: DynoVal<T>,\r\n): DynoVal<T> => new And({ a, b });\r\nexport const or = <T extends \"bool\" | AllIntTypes>(\r\n  a: DynoVal<T>,\r\n  b: DynoVal<T>,\r\n): DynoVal<T> => new Or({ a, b });\r\nexport const xor = <T extends \"bool\" | AllIntTypes>(\r\n  a: DynoVal<T>,\r\n  b: DynoVal<T>,\r\n): DynoVal<T> => new Xor({ a, b });\r\nexport const not = <T extends BoolTypes | AllIntTypes>(\r\n  a: DynoVal<T>,\r\n): DynoVal<T> => new Not({ a });\r\n\r\nexport const lessThan = <T extends ValueTypes>(\r\n  a: DynoVal<T>,\r\n  b: DynoVal<T>,\r\n): DynoVal<CompareOutput<T>> => new LessThan({ a, b });\r\nexport const lessThanEqual = <T extends ValueTypes>(\r\n  a: DynoVal<T>,\r\n  b: DynoVal<T>,\r\n): DynoVal<CompareOutput<T>> => new LessThanEqual({ a, b });\r\nexport const greaterThan = <T extends ValueTypes>(\r\n  a: DynoVal<T>,\r\n  b: DynoVal<T>,\r\n): DynoVal<CompareOutput<T>> => new GreaterThan({ a, b });\r\nexport const greaterThanEqual = <T extends ValueTypes>(\r\n  a: DynoVal<T>,\r\n  b: DynoVal<T>,\r\n): DynoVal<CompareOutput<T>> => new GreaterThanEqual({ a, b });\r\nexport const equal = <T extends ValueTypes | BoolTypes>(\r\n  a: DynoVal<T>,\r\n  b: DynoVal<T>,\r\n): DynoVal<EqualOutput<T>> => new Equal({ a, b });\r\nexport const notEqual = <T extends ValueTypes | BoolTypes>(\r\n  a: DynoVal<T>,\r\n  b: DynoVal<T>,\r\n): DynoVal<NotEqualOutput<T>> => new NotEqual({ a, b });\r\n\r\nexport const any = <T extends \"bvec2\" | \"bvec3\" | \"bvec4\">(\r\n  a: DynoVal<T>,\r\n): DynoVal<\"bool\"> => new Any({ a });\r\nexport const all = <T extends \"bvec2\" | \"bvec3\" | \"bvec4\">(\r\n  a: DynoVal<T>,\r\n): DynoVal<\"bool\"> => new All({ a });\r\nexport const select = <T extends SimpleTypes>(\r\n  cond: DynoVal<\"bool\">,\r\n  t: DynoVal<T>,\r\n  f: DynoVal<T>,\r\n): DynoVal<T> => new Select({ cond, t, f });\r\n\r\nexport const compXor = <T extends BoolTypes | AllIntTypes>(\r\n  a: DynoVal<T>,\r\n): DynoVal<CompXorOutput<T>> => new CompXor({ a });\r\n\r\nexport class And<T extends \"bool\" | AllIntTypes> extends BinaryOp<\r\n  T,\r\n  T,\r\n  T,\r\n  \"and\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<T>; b: DynoVal<T> }) {\r\n    super({ a, b, outTypeFunc: (aType: T, bType: T) => aType, outKey: \"and\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      if (this.outTypes.and === \"bool\") {\r\n        return [`${outputs.and} = ${inputs.a} && ${inputs.b};`];\r\n      }\r\n      return [`${outputs.and} = ${inputs.a} & ${inputs.b};`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Or<T extends \"bool\" | AllIntTypes> extends BinaryOp<\r\n  T,\r\n  T,\r\n  T,\r\n  \"or\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<T>; b: DynoVal<T> }) {\r\n    super({ a, b, outTypeFunc: (aType: T, bType: T) => aType, outKey: \"or\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      if (this.outTypes.or === \"bool\") {\r\n        return [`${outputs.or} = ${inputs.a} || ${inputs.b};`];\r\n      }\r\n      return [`${outputs.or} = ${inputs.a} | ${inputs.b};`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Xor<T extends \"bool\" | AllIntTypes> extends BinaryOp<\r\n  T,\r\n  T,\r\n  T,\r\n  \"xor\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<T>; b: DynoVal<T> }) {\r\n    super({ a, b, outTypeFunc: (aType: T, bType: T) => aType, outKey: \"xor\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      if (this.outTypes.xor === \"bool\") {\r\n        return [`${outputs.xor} = ${inputs.a} ^^ ${inputs.b};`];\r\n      }\r\n      return [`${outputs.xor} = ${inputs.a} ^ ${inputs.b};`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Not<T extends BoolTypes | AllIntTypes> extends UnaryOp<\r\n  T,\r\n  T,\r\n  \"not\"\r\n> {\r\n  constructor({ a }: { a: DynoVal<T> }) {\r\n    super({ a, outTypeFunc: (aType: T) => aType, outKey: \"not\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      if (this.outTypes.not === \"bool\") {\r\n        return [`${outputs.not} = !${inputs.a};`];\r\n      }\r\n      return [`${outputs.not} = not(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class LessThan<T extends ValueTypes> extends BinaryOp<\r\n  T,\r\n  T,\r\n  CompareOutput<T>,\r\n  \"lessThan\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<T>; b: DynoVal<T> }) {\r\n    super({\r\n      a,\r\n      b,\r\n      outTypeFunc: (aType: T, bType: T) => compareOutputType(aType, \"lessThan\"),\r\n      outKey: \"lessThan\",\r\n    });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      if (this.outTypes.lessThan === \"bool\") {\r\n        return [`${outputs.lessThan} = ${inputs.a} < ${inputs.b};`];\r\n      }\r\n      return [`${outputs.lessThan} = lessThan(${inputs.a}, ${inputs.b});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class LessThanEqual<T extends ValueTypes> extends BinaryOp<\r\n  T,\r\n  T,\r\n  CompareOutput<T>,\r\n  \"lessThanEqual\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<T>; b: DynoVal<T> }) {\r\n    super({\r\n      a,\r\n      b,\r\n      outTypeFunc: (aType: T, bType: T) =>\r\n        compareOutputType(aType, \"lessThanEqual\"),\r\n      outKey: \"lessThanEqual\",\r\n    });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      if (this.outTypes.lessThanEqual === \"bool\") {\r\n        return [`${outputs.lessThanEqual} = ${inputs.a} <= ${inputs.b};`];\r\n      }\r\n      return [\r\n        `${outputs.lessThanEqual} = lessThanEqual(${inputs.a}, ${inputs.b});`,\r\n      ];\r\n    };\r\n  }\r\n}\r\n\r\nexport class GreaterThan<T extends ValueTypes> extends BinaryOp<\r\n  T,\r\n  T,\r\n  CompareOutput<T>,\r\n  \"greaterThan\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<T>; b: DynoVal<T> }) {\r\n    super({\r\n      a,\r\n      b,\r\n      outTypeFunc: (aType: T, bType: T) =>\r\n        compareOutputType(aType, \"greaterThan\"),\r\n      outKey: \"greaterThan\",\r\n    });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      if (this.outTypes.greaterThan === \"bool\") {\r\n        return [`${outputs.greaterThan} = ${inputs.a} > ${inputs.b};`];\r\n      }\r\n      return [\r\n        `${outputs.greaterThan} = greaterThan(${inputs.a}, ${inputs.b});`,\r\n      ];\r\n    };\r\n  }\r\n}\r\n\r\nexport class GreaterThanEqual<T extends ValueTypes> extends BinaryOp<\r\n  T,\r\n  T,\r\n  CompareOutput<T>,\r\n  \"greaterThanEqual\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<T>; b: DynoVal<T> }) {\r\n    super({\r\n      a,\r\n      b,\r\n      outTypeFunc: (aType: T, bType: T) =>\r\n        compareOutputType(aType, \"greaterThanEqual\"),\r\n      outKey: \"greaterThanEqual\",\r\n    });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      if (this.outTypes.greaterThanEqual === \"bool\") {\r\n        return [`${outputs.greaterThanEqual} = ${inputs.a} >= ${inputs.b};`];\r\n      }\r\n      return [\r\n        `${outputs.greaterThanEqual} = greaterThanEqual(${inputs.a}, ${inputs.b});`,\r\n      ];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Equal<T extends ValueTypes | BoolTypes> extends BinaryOp<\r\n  T,\r\n  T,\r\n  EqualOutput<T>,\r\n  \"equal\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<T>; b: DynoVal<T> }) {\r\n    super({ a, b, outTypeFunc: equalOutputType<T>, outKey: \"equal\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      if (this.outTypes.equal === \"bool\") {\r\n        return [`${outputs.equal} = ${inputs.a} == ${inputs.b};`];\r\n      }\r\n      return [`${outputs.equal} = equal(${inputs.a}, ${inputs.b});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class NotEqual<T extends ValueTypes | BoolTypes> extends BinaryOp<\r\n  T,\r\n  T,\r\n  NotEqualOutput<T>,\r\n  \"notEqual\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<T>; b: DynoVal<T> }) {\r\n    super({ a, b, outTypeFunc: notEqualOutputType<T>, outKey: \"notEqual\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      if (this.outTypes.notEqual === \"bool\") {\r\n        return [`${outputs.notEqual} = ${inputs.a} != ${inputs.b};`];\r\n      }\r\n      return [`${outputs.notEqual} = notEqual(${inputs.a}, ${inputs.b});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Any<T extends BoolTypes> extends UnaryOp<T, \"bool\", \"any\"> {\r\n  constructor({ a }: { a: DynoVal<T> }) {\r\n    super({ a, outTypeFunc: (aType: T) => \"bool\", outKey: \"any\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.any} = any(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class All<T extends BoolTypes> extends UnaryOp<T, \"bool\", \"all\"> {\r\n  constructor({ a }: { a: DynoVal<T> }) {\r\n    super({ a, outTypeFunc: (aType: T) => \"bool\", outKey: \"all\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.all} = all(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Select<T extends SimpleTypes> extends TrinaryOp<\r\n  \"bool\",\r\n  T,\r\n  T,\r\n  T,\r\n  \"select\"\r\n> {\r\n  constructor({\r\n    cond,\r\n    t,\r\n    f,\r\n  }: { cond: DynoVal<\"bool\">; t: DynoVal<T>; f: DynoVal<T> }) {\r\n    super({\r\n      a: cond,\r\n      b: t,\r\n      c: f,\r\n      outKey: \"select\",\r\n      outTypeFunc: (aType: \"bool\", bType: T, cType: T) => bType,\r\n    });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      const { a: cond, b: t, c: f } = inputs;\r\n      return [`${outputs.select} = (${cond}) ? (${t}) : (${f});`];\r\n    };\r\n  }\r\n}\r\n\r\ntype CompareOutput<T extends ValueTypes> = T extends ScalarTypes\r\n  ? \"bool\"\r\n  : T extends \"ivec2\" | \"uvec2\" | \"vec2\"\r\n    ? \"bvec2\"\r\n    : T extends \"ivec3\" | \"uvec3\" | \"vec3\"\r\n      ? \"bvec3\"\r\n      : T extends \"ivec4\" | \"uvec4\" | \"vec4\"\r\n        ? \"bvec4\"\r\n        : never;\r\n\r\nfunction compareOutputType<T extends ValueTypes>(\r\n  type: T,\r\n  operator: string,\r\n): CompareOutput<T> {\r\n  if (isScalarType(type)) {\r\n    return \"bool\" as CompareOutput<T>;\r\n  }\r\n  if (type === \"ivec2\" || type === \"uvec2\" || type === \"vec2\") {\r\n    return \"bvec2\" as CompareOutput<T>;\r\n  }\r\n  if (type === \"ivec3\" || type === \"uvec3\" || type === \"vec3\") {\r\n    return \"bvec3\" as CompareOutput<T>;\r\n  }\r\n  if (type === \"ivec4\" || type === \"uvec4\" || type === \"vec4\") {\r\n    return \"bvec4\" as CompareOutput<T>;\r\n  }\r\n  throw new Error(`Invalid ${operator} type: ${type}`);\r\n}\r\n\r\ntype EqualOutput<A extends ValueTypes | BoolTypes> = A extends ScalarTypes\r\n  ? \"bool\"\r\n  : A extends BoolTypes\r\n    ? A\r\n    : A extends \"ivec2\" | \"uvec2\" | \"vec2\"\r\n      ? \"bvec2\"\r\n      : A extends \"ivec3\" | \"uvec3\" | \"vec3\"\r\n        ? \"bvec3\"\r\n        : A extends \"ivec4\" | \"uvec4\" | \"vec4\"\r\n          ? \"bvec4\"\r\n          : never;\r\n\r\nfunction equalOutputType<A extends ValueTypes | BoolTypes>(\r\n  type: A,\r\n  operator = \"equal\",\r\n): EqualOutput<A> {\r\n  if (isScalarType(type)) {\r\n    return \"bool\" as EqualOutput<A>;\r\n  }\r\n  if (isBoolType(type)) {\r\n    return type as EqualOutput<A>;\r\n  }\r\n  if (type === \"ivec2\" || type === \"uvec2\" || type === \"vec2\") {\r\n    return \"bvec2\" as EqualOutput<A>;\r\n  }\r\n  if (type === \"ivec3\" || type === \"uvec3\" || type === \"vec3\") {\r\n    return \"bvec3\" as EqualOutput<A>;\r\n  }\r\n  if (type === \"ivec4\" || type === \"uvec4\" || type === \"vec4\") {\r\n    return \"bvec4\" as EqualOutput<A>;\r\n  }\r\n  throw new Error(`Invalid ${operator} type: ${type}`);\r\n}\r\n\r\ntype NotEqualOutput<A extends ValueTypes | BoolTypes> = EqualOutput<A>;\r\n\r\nfunction notEqualOutputType<A extends ValueTypes | BoolTypes>(\r\n  type: A,\r\n): NotEqualOutput<A> {\r\n  return equalOutputType(type, \"notEqual\");\r\n}\r\n\r\ntype CompXorOutput<A extends BoolTypes | AllIntTypes> = A extends BoolTypes\r\n  ? \"bool\"\r\n  : A extends IntTypes\r\n    ? \"int\"\r\n    : A extends UintTypes\r\n      ? \"uint\"\r\n      : never;\r\n\r\nfunction compXorOutputType<A extends BoolTypes | AllIntTypes>(\r\n  type: A,\r\n): CompXorOutput<A> {\r\n  if (isBoolType(type)) {\r\n    return \"bool\" as CompXorOutput<A>;\r\n  }\r\n  if (isIntType(type)) {\r\n    return \"int\" as CompXorOutput<A>;\r\n  }\r\n  if (isUintType(type)) {\r\n    return \"uint\" as CompXorOutput<A>;\r\n  }\r\n  throw new Error(`Invalid compXor type: ${type}`);\r\n}\r\n\r\nexport class CompXor<T extends BoolTypes | AllIntTypes> extends UnaryOp<\r\n  T,\r\n  CompXorOutput<T>,\r\n  \"compXor\"\r\n> {\r\n  constructor({ a }: { a: DynoVal<T> }) {\r\n    const outType = compXorOutputType(valType(a));\r\n    super({ a, outTypeFunc: (aType: T) => outType, outKey: \"compXor\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      if (isScalarType(this.outTypes.compXor)) {\r\n        return [`${outputs.compXor} = ${inputs.a};`];\r\n      }\r\n      const components = isVector2Type(outType)\r\n        ? [\"x\", \"y\"]\r\n        : isVector3Type(outType)\r\n          ? [\"x\", \"y\", \"z\"]\r\n          : [\"x\", \"y\", \"z\", \"w\"];\r\n      const operands = components.map((c) => `${inputs.a}.${c}`);\r\n      const operator = isBoolType(outType) ? \"^^\" : \"^\";\r\n      return [`${outputs.compXor} = ${operands.join(` ${operator} `)};`];\r\n    };\r\n  }\r\n}\r\n","import { UnaryOp } from \"./base\";\r\nimport { type SimpleTypes, typeLiteral } from \"./types\";\r\nimport type { DynoVal } from \"./value\";\r\n\r\nexport const bool = <T extends \"bool\" | \"int\" | \"uint\" | \"float\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"bool\"> => new Bool({ value });\r\nexport const int = <T extends \"bool\" | \"int\" | \"uint\" | \"float\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"int\"> => new Int({ value });\r\nexport const uint = <T extends \"bool\" | \"int\" | \"uint\" | \"float\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"uint\"> => new Uint({ value });\r\nexport const float = <T extends \"bool\" | \"int\" | \"uint\" | \"float\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"float\"> => new Float({ value });\r\n\r\nexport const bvec2 = <T extends \"bool\" | \"bvec2\" | \"ivec2\" | \"uvec2\" | \"vec2\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"bvec2\"> => new BVec2({ value });\r\nexport const bvec3 = <T extends \"bool\" | \"bvec3\" | \"ivec3\" | \"uvec3\" | \"vec3\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"bvec3\"> => new BVec3({ value });\r\nexport const bvec4 = <T extends \"bool\" | \"bvec4\" | \"ivec4\" | \"uvec4\" | \"vec4\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"bvec4\"> => new BVec4({ value });\r\n\r\nexport const ivec2 = <T extends \"int\" | \"bvec2\" | \"ivec2\" | \"uvec2\" | \"vec2\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"ivec2\"> => new IVec2({ value });\r\nexport const ivec3 = <T extends \"int\" | \"bvec3\" | \"ivec3\" | \"uvec3\" | \"vec3\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"ivec3\"> => new IVec3({ value });\r\nexport const ivec4 = <T extends \"int\" | \"bvec4\" | \"ivec4\" | \"uvec4\" | \"vec4\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"ivec4\"> => new IVec4({ value });\r\n\r\nexport const uvec2 = <T extends \"uint\" | \"bvec2\" | \"ivec2\" | \"uvec2\" | \"vec2\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"uvec2\"> => new UVec2({ value });\r\nexport const uvec3 = <T extends \"uint\" | \"bvec3\" | \"ivec3\" | \"uvec3\" | \"vec3\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"uvec3\"> => new UVec3({ value });\r\nexport const uvec4 = <T extends \"uint\" | \"bvec4\" | \"ivec4\" | \"uvec4\" | \"vec4\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"uvec4\"> => new UVec4({ value });\r\n\r\nexport const vec2 = <\r\n  T extends \"float\" | \"bvec2\" | \"ivec2\" | \"uvec2\" | \"vec2\" | \"vec3\" | \"vec4\",\r\n>(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"vec2\"> => new Vec2({ value });\r\nexport const vec3 = <\r\n  T extends \"float\" | \"bvec3\" | \"ivec3\" | \"uvec3\" | \"vec3\" | \"vec4\",\r\n>(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"vec3\"> => new Vec3({ value });\r\nexport const vec4 = <T extends \"float\" | \"bvec4\" | \"ivec4\" | \"uvec4\" | \"vec4\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"vec4\"> => new Vec4({ value });\r\n\r\nexport const mat2 = <T extends \"float\" | \"mat2\" | \"mat3\" | \"mat4\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"mat2\"> => new Mat2({ value });\r\nexport const mat3 = <T extends \"float\" | \"mat2\" | \"mat3\" | \"mat4\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"mat3\"> => new Mat3({ value });\r\nexport const mat4 = <T extends \"float\" | \"mat2\" | \"mat3\" | \"mat4\">(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"mat4\"> => new Mat4({ value });\r\n\r\nexport const floatBitsToInt = (value: DynoVal<\"float\">): DynoVal<\"int\"> =>\r\n  new FloatBitsToInt({ value });\r\nexport const floatBitsToUint = (value: DynoVal<\"float\">): DynoVal<\"uint\"> =>\r\n  new FloatBitsToUint({ value });\r\nexport const intBitsToFloat = (value: DynoVal<\"int\">): DynoVal<\"float\"> =>\r\n  new IntBitsToFloat({ value });\r\nexport const uintBitsToFloat = (value: DynoVal<\"uint\">): DynoVal<\"float\"> =>\r\n  new UintBitsToFloat({ value });\r\n\r\nexport const packSnorm2x16 = (value: DynoVal<\"vec2\">): DynoVal<\"uint\"> =>\r\n  new PackSnorm2x16({ value });\r\nexport const unpackSnorm2x16 = (value: DynoVal<\"uint\">): DynoVal<\"vec2\"> =>\r\n  new UnpackSnorm2x16({ value });\r\nexport const packUnorm2x16 = (value: DynoVal<\"vec2\">): DynoVal<\"uint\"> =>\r\n  new PackUnorm2x16({ value });\r\nexport const unpackUnorm2x16 = (value: DynoVal<\"uint\">): DynoVal<\"vec2\"> =>\r\n  new UnpackUnorm2x16({ value });\r\n\r\nexport const packHalf2x16 = (value: DynoVal<\"vec2\">): DynoVal<\"uint\"> =>\r\n  new PackHalf2x16({ value });\r\nexport const unpackHalf2x16 = (value: DynoVal<\"uint\">): DynoVal<\"vec2\"> =>\r\n  new UnpackHalf2x16({ value });\r\n\r\nexport const uintToRgba8 = (value: DynoVal<\"uint\">): DynoVal<\"vec4\"> =>\r\n  new UintToRgba8({ value });\r\n\r\nexport class SimpleCast<\r\n  Allowed extends SimpleTypes,\r\n  OutType extends SimpleTypes,\r\n  OutKey extends string,\r\n> extends UnaryOp<Allowed, OutType, OutKey> {\r\n  constructor({\r\n    value,\r\n    outType,\r\n    outKey,\r\n  }: { value: DynoVal<Allowed>; outType: OutType; outKey: OutKey }) {\r\n    super({ a: value, outTypeFunc: () => outType, outKey });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs[outKey]} = ${typeLiteral(outType)}(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Bool extends SimpleCast<\r\n  \"bool\" | \"int\" | \"uint\" | \"float\",\r\n  \"bool\",\r\n  \"bool\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"bool\" | \"int\" | \"uint\" | \"float\"> }) {\r\n    super({ value, outType: \"bool\", outKey: \"bool\" });\r\n  }\r\n}\r\n\r\nexport class Int extends SimpleCast<\r\n  \"bool\" | \"int\" | \"uint\" | \"float\",\r\n  \"int\",\r\n  \"int\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"bool\" | \"int\" | \"uint\" | \"float\"> }) {\r\n    super({ value, outType: \"int\", outKey: \"int\" });\r\n  }\r\n}\r\n\r\nexport class Uint extends SimpleCast<\r\n  \"bool\" | \"int\" | \"uint\" | \"float\",\r\n  \"uint\",\r\n  \"uint\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"bool\" | \"int\" | \"uint\" | \"float\"> }) {\r\n    super({ value, outType: \"uint\", outKey: \"uint\" });\r\n  }\r\n}\r\n\r\nexport class Float extends SimpleCast<\r\n  \"bool\" | \"int\" | \"uint\" | \"float\",\r\n  \"float\",\r\n  \"float\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"bool\" | \"int\" | \"uint\" | \"float\"> }) {\r\n    super({ value, outType: \"float\", outKey: \"float\" });\r\n  }\r\n}\r\n\r\nexport class BVec2 extends SimpleCast<\r\n  \"bool\" | \"bvec2\" | \"ivec2\" | \"uvec2\" | \"vec2\",\r\n  \"bvec2\",\r\n  \"bvec2\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"bool\" | \"bvec2\" | \"ivec2\" | \"uvec2\" | \"vec2\"> }) {\r\n    super({ value, outType: \"bvec2\", outKey: \"bvec2\" });\r\n  }\r\n}\r\n\r\nexport class BVec3 extends SimpleCast<\r\n  \"bool\" | \"bvec3\" | \"ivec3\" | \"uvec3\" | \"vec3\",\r\n  \"bvec3\",\r\n  \"bvec3\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"bool\" | \"bvec3\" | \"ivec3\" | \"uvec3\" | \"vec3\"> }) {\r\n    super({ value, outType: \"bvec3\", outKey: \"bvec3\" });\r\n  }\r\n}\r\n\r\nexport class BVec4 extends SimpleCast<\r\n  \"bool\" | \"bvec4\" | \"ivec4\" | \"uvec4\" | \"vec4\",\r\n  \"bvec4\",\r\n  \"bvec4\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"bool\" | \"bvec4\" | \"ivec4\" | \"uvec4\" | \"vec4\"> }) {\r\n    super({ value, outType: \"bvec4\", outKey: \"bvec4\" });\r\n  }\r\n}\r\n\r\nexport class IVec2 extends SimpleCast<\r\n  \"int\" | \"bvec2\" | \"ivec2\" | \"uvec2\" | \"vec2\",\r\n  \"ivec2\",\r\n  \"ivec2\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"int\" | \"bvec2\" | \"ivec2\" | \"uvec2\" | \"vec2\"> }) {\r\n    super({ value, outType: \"ivec2\", outKey: \"ivec2\" });\r\n  }\r\n}\r\n\r\nexport class IVec3 extends SimpleCast<\r\n  \"int\" | \"bvec3\" | \"ivec3\" | \"uvec3\" | \"vec3\",\r\n  \"ivec3\",\r\n  \"ivec3\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"int\" | \"bvec3\" | \"ivec3\" | \"uvec3\" | \"vec3\"> }) {\r\n    super({ value, outType: \"ivec3\", outKey: \"ivec3\" });\r\n  }\r\n}\r\n\r\nexport class IVec4 extends SimpleCast<\r\n  \"int\" | \"bvec4\" | \"ivec4\" | \"uvec4\" | \"vec4\",\r\n  \"ivec4\",\r\n  \"ivec4\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"int\" | \"bvec4\" | \"ivec4\" | \"uvec4\" | \"vec4\"> }) {\r\n    super({ value, outType: \"ivec4\", outKey: \"ivec4\" });\r\n  }\r\n}\r\n\r\nexport class UVec2 extends SimpleCast<\r\n  \"uint\" | \"ivec2\" | \"bvec2\" | \"uvec2\" | \"vec2\",\r\n  \"uvec2\",\r\n  \"uvec2\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"uint\" | \"ivec2\" | \"bvec2\" | \"uvec2\" | \"vec2\"> }) {\r\n    super({ value, outType: \"uvec2\", outKey: \"uvec2\" });\r\n  }\r\n}\r\n\r\nexport class UVec3 extends SimpleCast<\r\n  \"uint\" | \"ivec3\" | \"bvec3\" | \"uvec3\" | \"vec3\",\r\n  \"uvec3\",\r\n  \"uvec3\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"uint\" | \"ivec3\" | \"bvec3\" | \"uvec3\" | \"vec3\"> }) {\r\n    super({ value, outType: \"uvec3\", outKey: \"uvec3\" });\r\n  }\r\n}\r\n\r\nexport class UVec4 extends SimpleCast<\r\n  \"uint\" | \"ivec4\" | \"bvec4\" | \"uvec4\" | \"vec4\",\r\n  \"uvec4\",\r\n  \"uvec4\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"uint\" | \"ivec4\" | \"bvec4\" | \"uvec4\" | \"vec4\"> }) {\r\n    super({ value, outType: \"uvec4\", outKey: \"uvec4\" });\r\n  }\r\n}\r\n\r\nexport class Vec2 extends SimpleCast<\r\n  \"float\" | \"bvec2\" | \"ivec2\" | \"uvec2\" | \"vec2\" | \"vec3\" | \"vec4\",\r\n  \"vec2\",\r\n  \"vec2\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: {\r\n    value: DynoVal<\r\n      \"float\" | \"bvec2\" | \"ivec2\" | \"uvec2\" | \"vec2\" | \"vec3\" | \"vec4\"\r\n    >;\r\n  }) {\r\n    super({ value, outType: \"vec2\", outKey: \"vec2\" });\r\n  }\r\n}\r\n\r\nexport class Vec3 extends SimpleCast<\r\n  \"float\" | \"bvec3\" | \"ivec3\" | \"uvec3\" | \"vec3\" | \"vec2\" | \"vec4\",\r\n  \"vec3\",\r\n  \"vec3\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: {\r\n    value: DynoVal<\r\n      \"float\" | \"bvec3\" | \"ivec3\" | \"uvec3\" | \"vec3\" | \"vec2\" | \"vec4\"\r\n    >;\r\n  }) {\r\n    super({ value, outType: \"vec3\", outKey: \"vec3\" });\r\n  }\r\n}\r\n\r\nexport class Vec4 extends SimpleCast<\r\n  \"float\" | \"bvec4\" | \"ivec4\" | \"uvec4\" | \"vec4\",\r\n  \"vec4\",\r\n  \"vec4\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"float\" | \"bvec4\" | \"ivec4\" | \"uvec4\" | \"vec4\"> }) {\r\n    super({ value, outType: \"vec4\", outKey: \"vec4\" });\r\n  }\r\n}\r\n\r\nexport class Mat2 extends SimpleCast<\r\n  \"float\" | \"mat2\" | \"mat3\" | \"mat4\",\r\n  \"mat2\",\r\n  \"mat2\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"float\" | \"mat2\" | \"mat3\" | \"mat4\"> }) {\r\n    super({ value, outType: \"mat2\", outKey: \"mat2\" });\r\n  }\r\n}\r\n\r\nexport class Mat3 extends SimpleCast<\r\n  \"float\" | \"mat2\" | \"mat3\" | \"mat4\",\r\n  \"mat3\",\r\n  \"mat3\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"float\" | \"mat2\" | \"mat3\" | \"mat4\"> }) {\r\n    super({ value, outType: \"mat3\", outKey: \"mat3\" });\r\n  }\r\n}\r\n\r\nexport class Mat4 extends SimpleCast<\r\n  \"float\" | \"mat2\" | \"mat3\" | \"mat4\",\r\n  \"mat4\",\r\n  \"mat4\"\r\n> {\r\n  constructor({\r\n    value,\r\n  }: { value: DynoVal<\"float\" | \"mat2\" | \"mat3\" | \"mat4\"> }) {\r\n    super({ value, outType: \"mat4\", outKey: \"mat4\" });\r\n  }\r\n}\r\n\r\nexport class FloatBitsToInt extends UnaryOp<\"float\", \"int\", \"int\"> {\r\n  constructor({ value }: { value: DynoVal<\"float\"> }) {\r\n    super({ a: value, outKey: \"int\", outTypeFunc: () => \"int\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.int} = floatBitsToInt(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class FloatBitsToUint extends UnaryOp<\"float\", \"uint\", \"uint\"> {\r\n  constructor({ value }: { value: DynoVal<\"float\"> }) {\r\n    super({ a: value, outKey: \"uint\", outTypeFunc: () => \"uint\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.uint} = floatBitsToUint(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class IntBitsToFloat extends UnaryOp<\"int\", \"float\", \"float\"> {\r\n  constructor({ value }: { value: DynoVal<\"int\"> }) {\r\n    super({ a: value, outKey: \"float\", outTypeFunc: () => \"float\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.float} = intBitsToFloat(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class UintBitsToFloat extends UnaryOp<\"uint\", \"float\", \"float\"> {\r\n  constructor({ value }: { value: DynoVal<\"uint\"> }) {\r\n    super({ a: value, outKey: \"float\", outTypeFunc: () => \"float\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.float} = uintBitsToFloat(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class PackSnorm2x16 extends UnaryOp<\"vec2\", \"uint\", \"uint\"> {\r\n  constructor({ value }: { value: DynoVal<\"vec2\"> }) {\r\n    super({ a: value, outKey: \"uint\", outTypeFunc: () => \"uint\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.uint} = packSnorm2x16(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class UnpackSnorm2x16 extends UnaryOp<\"uint\", \"vec2\", \"vec2\"> {\r\n  constructor({ value }: { value: DynoVal<\"uint\"> }) {\r\n    super({ a: value, outKey: \"vec2\", outTypeFunc: () => \"vec2\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.vec2} = unpackSnorm2x16(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class PackUnorm2x16 extends UnaryOp<\"vec2\", \"uint\", \"uint\"> {\r\n  constructor({ value }: { value: DynoVal<\"vec2\"> }) {\r\n    super({ a: value, outKey: \"uint\", outTypeFunc: () => \"uint\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.uint} = packUnorm2x16(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class UnpackUnorm2x16 extends UnaryOp<\"uint\", \"vec2\", \"vec2\"> {\r\n  constructor({ value }: { value: DynoVal<\"uint\"> }) {\r\n    super({ a: value, outKey: \"vec2\", outTypeFunc: () => \"vec2\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.vec2} = unpackUnorm2x16(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class PackHalf2x16 extends UnaryOp<\"vec2\", \"uint\", \"uint\"> {\r\n  constructor({ value }: { value: DynoVal<\"vec2\"> }) {\r\n    super({ a: value, outKey: \"uint\", outTypeFunc: () => \"uint\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.uint} = packHalf2x16(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class UnpackHalf2x16 extends UnaryOp<\"uint\", \"vec2\", \"vec2\"> {\r\n  constructor({ value }: { value: DynoVal<\"uint\"> }) {\r\n    super({ a: value, outKey: \"vec2\", outTypeFunc: () => \"vec2\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [`${outputs.vec2} = unpackHalf2x16(${inputs.a});`];\r\n    };\r\n  }\r\n}\r\n\r\nexport class UintToRgba8 extends UnaryOp<\"uint\", \"vec4\", \"rgba8\"> {\r\n  constructor({ value }: { value: DynoVal<\"uint\"> }) {\r\n    super({ a: value, outKey: \"rgba8\", outTypeFunc: () => \"vec4\" });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      return [\r\n        `uvec4 uRgba = uvec4(${inputs.a} & 0xffu, (${inputs.a} >> 8u) & 0xffu, (${inputs.a} >> 16u) & 0xffu, (${inputs.a} >> 24u) & 0xffu);`,\r\n        `${outputs.rgba8} = vec4(uRgba) / 255.0;`,\r\n      ];\r\n    };\r\n  }\r\n}\r\n","import { BinaryOp, Dyno, TrinaryOp, UnaryOp } from \"./base\";\r\nimport {\r\n  type FloatTypes,\r\n  type IntTypes,\r\n  type MatFloatTypes,\r\n  type SquareMatTypes,\r\n  type UintTypes,\r\n  type VectorElementType,\r\n  type VectorTypes,\r\n  isFloatType,\r\n  isIntType,\r\n  isUintType,\r\n  vectorDim,\r\n  vectorElementType,\r\n} from \"./types\";\r\nimport {\r\n  DynoOutput,\r\n  type DynoVal,\r\n  type DynoValue,\r\n  type HasDynoOut,\r\n  literalZero,\r\n  valType,\r\n} from \"./value\";\r\n\r\nexport const length = <A extends \"vec2\" | \"vec3\" | \"vec4\">(\r\n  a: DynoVal<A>,\r\n): DynoVal<\"float\"> => new Length({ a });\r\nexport const distance = <A extends \"vec2\" | \"vec3\" | \"vec4\">(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<A>,\r\n): DynoVal<\"float\"> => new Distance({ a, b });\r\nexport const dot = <A extends \"vec2\" | \"vec3\" | \"vec4\">(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<A>,\r\n): DynoVal<\"float\"> => new Dot({ a, b });\r\nexport const cross = (\r\n  a: DynoVal<\"vec3\">,\r\n  b: DynoVal<\"vec3\">,\r\n): DynoVal<\"vec3\"> => new Cross({ a, b });\r\nexport const normalize = <A extends \"vec2\" | \"vec3\" | \"vec4\">(\r\n  a: DynoVal<A>,\r\n): DynoVal<A> => new Normalize({ a });\r\nexport const faceforward = <A extends \"vec2\" | \"vec3\" | \"vec4\">(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<A>,\r\n  c: DynoVal<A>,\r\n): DynoVal<A> => new FaceForward({ a, b, c });\r\nexport const reflectVec = <A extends \"vec2\" | \"vec3\" | \"vec4\">(\r\n  incident: DynoVal<A>,\r\n  normal: DynoVal<A>,\r\n): DynoVal<A> => new ReflectVec({ incident, normal });\r\nexport const refractVec = <A extends \"vec2\" | \"vec3\" | \"vec4\">(\r\n  incident: DynoVal<A>,\r\n  normal: DynoVal<A>,\r\n  eta: DynoVal<\"float\">,\r\n): DynoVal<A> => new RefractVec({ incident, normal, eta });\r\nexport const split = <V extends VectorTypes>(vector: DynoVal<V>): Split<V> =>\r\n  new Split({ vector });\r\nexport const combine = <V extends VectorTypes, T extends VectorElementType<V>>({\r\n  vector,\r\n  vectorType,\r\n  x,\r\n  y,\r\n  z,\r\n  w,\r\n  r,\r\n  g,\r\n  b,\r\n  a,\r\n}: {\r\n  vector?: DynoVal<V>;\r\n  vectorType?: V;\r\n  x?: DynoVal<T>;\r\n  y?: DynoVal<T>;\r\n  z?: DynoVal<T>;\r\n  w?: DynoVal<T>;\r\n  r?: DynoVal<T>;\r\n  g?: DynoVal<T>;\r\n  b?: DynoVal<T>;\r\n  a?: DynoVal<T>;\r\n}): DynoVal<V> => new Combine({ vector, vectorType, x, y, z, w, r, g, b, a });\r\nexport const projectH = <A extends \"vec3\" | \"vec4\">(\r\n  a: DynoVal<A>,\r\n): DynoVal<ProjectHOutput<A>> => new ProjectH({ a });\r\nexport const extendVec = <A extends \"float\" | \"vec2\" | \"vec3\">(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<\"float\">,\r\n): DynoVal<ExtendVecOutput<A>> => new ExtendVec({ a, b });\r\nexport const swizzle = <A extends VectorTypes, S extends SwizzleSelect>(\r\n  a: DynoVal<A>,\r\n  select: S,\r\n): DynoVal<SwizzleOutput<A, SwizzleSelectLen<S>>> =>\r\n  new Swizzle({ vector: a, select });\r\nexport const compMult = <A extends MatFloatTypes>(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<A>,\r\n): DynoVal<A> => new CompMult({ a, b });\r\nexport const outer = <\r\n  A extends \"vec2\" | \"vec3\" | \"vec4\",\r\n  B extends \"vec2\" | \"vec3\" | \"vec4\",\r\n>(\r\n  a: DynoVal<A>,\r\n  b: DynoVal<B>,\r\n): DynoVal<OuterOutput<A, B>> => new Outer({ a, b });\r\nexport const transpose = <A extends MatFloatTypes>(\r\n  a: DynoVal<A>,\r\n): DynoVal<TransposeOutput<A>> => new Transpose({ a });\r\nexport const determinant = <A extends SquareMatTypes>(\r\n  a: DynoVal<A>,\r\n): DynoVal<\"float\"> => new Determinant({ a });\r\nexport const inverse = <A extends SquareMatTypes>(a: DynoVal<A>): DynoVal<A> =>\r\n  new Inverse({ a });\r\n\r\nexport class Length<A extends \"vec2\" | \"vec3\" | \"vec4\"> extends UnaryOp<\r\n  A,\r\n  \"float\",\r\n  \"length\"\r\n> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outTypeFunc: (aType) => \"float\", outKey: \"length\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.length} = length(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Distance<A extends \"vec2\" | \"vec3\" | \"vec4\"> extends BinaryOp<\r\n  A,\r\n  A,\r\n  \"float\",\r\n  \"distance\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<A> }) {\r\n    super({ a, b, outKey: \"distance\", outTypeFunc: (aType, bType) => \"float\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.distance} = distance(${inputs.a}, ${inputs.b});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Dot<A extends \"vec2\" | \"vec3\" | \"vec4\"> extends BinaryOp<\r\n  A,\r\n  A,\r\n  \"float\",\r\n  \"dot\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<A> }) {\r\n    super({ a, b, outKey: \"dot\", outTypeFunc: (aType, bType) => \"float\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.dot} = dot(${inputs.a}, ${inputs.b});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Cross extends BinaryOp<\"vec3\", \"vec3\", \"vec3\", \"cross\"> {\r\n  constructor({ a, b }: { a: DynoVal<\"vec3\">; b: DynoVal<\"vec3\"> }) {\r\n    super({ a, b, outKey: \"cross\", outTypeFunc: (aType, bType) => \"vec3\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.cross} = cross(${inputs.a}, ${inputs.b});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Normalize<A extends \"vec2\" | \"vec3\" | \"vec4\"> extends UnaryOp<\r\n  A,\r\n  A,\r\n  \"normalize\"\r\n> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outTypeFunc: (aType) => aType, outKey: \"normalize\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.normalize} = normalize(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\ntype ProjectHOutput<A extends \"vec3\" | \"vec4\"> = A extends \"vec3\"\r\n  ? \"vec2\"\r\n  : A extends \"vec4\"\r\n    ? \"vec3\"\r\n    : never;\r\n\r\nfunction projectHOutputType<A extends \"vec3\" | \"vec4\">(\r\n  type: A,\r\n): ProjectHOutput<A> {\r\n  if (type === \"vec3\") {\r\n    return \"vec2\" as ProjectHOutput<A>;\r\n  }\r\n  if (type === \"vec4\") {\r\n    return \"vec3\" as ProjectHOutput<A>;\r\n  }\r\n  throw new Error(\"Invalid type\");\r\n}\r\n\r\nexport class ProjectH<A extends \"vec3\" | \"vec4\"> extends UnaryOp<\r\n  A,\r\n  ProjectHOutput<A>,\r\n  \"projected\"\r\n> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({\r\n      a,\r\n      outTypeFunc: (aType) => projectHOutputType(aType),\r\n      outKey: \"projected\",\r\n    });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      if (this.inTypes.a === \"vec3\") {\r\n        return [`${outputs.projected} = ${inputs.a}.xy / ${inputs.a}.z;`];\r\n      }\r\n      if (this.inTypes.a === \"vec4\") {\r\n        return [`${outputs.projected} = ${inputs.a}.xyz / ${inputs.a}.w;`];\r\n      }\r\n      throw new Error(\"Invalid type\");\r\n    };\r\n  }\r\n}\r\n\r\ntype ExtendVecOutput<A extends \"float\" | \"vec2\" | \"vec3\"> = A extends \"float\"\r\n  ? \"vec2\"\r\n  : A extends \"vec2\"\r\n    ? \"vec3\"\r\n    : A extends \"vec3\"\r\n      ? \"vec4\"\r\n      : never;\r\n\r\nfunction extendVecOutputType<A extends \"float\" | \"vec2\" | \"vec3\">(\r\n  type: A,\r\n): ExtendVecOutput<A> {\r\n  if (type === \"float\") return \"vec2\" as ExtendVecOutput<A>;\r\n  if (type === \"vec2\") return \"vec3\" as ExtendVecOutput<A>;\r\n  if (type === \"vec3\") return \"vec4\" as ExtendVecOutput<A>;\r\n  throw new Error(\"Invalid type\");\r\n}\r\n\r\nexport class ExtendVec<A extends \"float\" | \"vec2\" | \"vec3\"> extends BinaryOp<\r\n  A,\r\n  \"float\",\r\n  ExtendVecOutput<A>,\r\n  \"extend\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<\"float\"> }) {\r\n    const type = valType(a);\r\n    const outType = extendVecOutputType(type);\r\n    super({ a, b, outKey: \"extend\", outTypeFunc: () => outType });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.extend} = ${outType}(${inputs.a}, ${inputs.b});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class FaceForward<A extends \"vec2\" | \"vec3\" | \"vec4\"> extends TrinaryOp<\r\n  A,\r\n  A,\r\n  A,\r\n  A,\r\n  \"forward\"\r\n> {\r\n  constructor({ a, b, c }: { a: DynoVal<A>; b: DynoVal<A>; c: DynoVal<A> }) {\r\n    super({\r\n      a,\r\n      b,\r\n      c,\r\n      outKey: \"forward\",\r\n      outTypeFunc: (aType, bType, cType) => aType,\r\n    });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.forward} = faceforward(${inputs.a}, ${inputs.b}, ${inputs.c});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class ReflectVec<A extends \"vec2\" | \"vec3\" | \"vec4\"> extends BinaryOp<\r\n  A,\r\n  A,\r\n  A,\r\n  \"reflection\"\r\n> {\r\n  constructor({\r\n    incident,\r\n    normal,\r\n  }: { incident: DynoVal<A>; normal: DynoVal<A> }) {\r\n    super({\r\n      a: incident,\r\n      b: normal,\r\n      outKey: \"reflection\",\r\n      outTypeFunc: (aType, bType) => aType,\r\n    });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.reflection} = reflect(${inputs.a}, ${inputs.b});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class RefractVec<A extends \"vec2\" | \"vec3\" | \"vec4\"> extends TrinaryOp<\r\n  A,\r\n  A,\r\n  \"float\",\r\n  A,\r\n  \"refraction\"\r\n> {\r\n  constructor({\r\n    incident,\r\n    normal,\r\n    eta,\r\n  }: { incident: DynoVal<A>; normal: DynoVal<A>; eta: DynoVal<\"float\"> }) {\r\n    super({\r\n      a: incident,\r\n      b: normal,\r\n      c: eta,\r\n      outKey: \"refraction\",\r\n      outTypeFunc: (aType, bType, cType) => aType,\r\n    });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.refraction} = refract(${inputs.a}, ${inputs.b}, ${inputs.c});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class CompMult<A extends MatFloatTypes> extends BinaryOp<\r\n  A,\r\n  A,\r\n  A,\r\n  \"product\"\r\n> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<A> }) {\r\n    super({ a, b, outKey: \"product\", outTypeFunc: (aType, bType) => aType });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.product} = matrixCompMult(${a}, ${b});`,\r\n    ];\r\n  }\r\n}\r\n\r\ntype OuterOutput<\r\n  A extends \"vec2\" | \"vec3\" | \"vec4\",\r\n  B extends \"vec2\" | \"vec3\" | \"vec4\",\r\n> = A extends \"vec2\"\r\n  ? B extends \"vec2\"\r\n    ? \"mat2\"\r\n    : B extends \"vec3\"\r\n      ? \"mat3x2\"\r\n      : B extends \"vec4\"\r\n        ? \"mat4x2\"\r\n        : never\r\n  : A extends \"vec3\"\r\n    ? B extends \"vec2\"\r\n      ? \"mat2x3\"\r\n      : B extends \"vec3\"\r\n        ? \"mat3\"\r\n        : B extends \"vec4\"\r\n          ? \"mat4x3\"\r\n          : never\r\n    : A extends \"vec4\"\r\n      ? B extends \"vec2\"\r\n        ? \"mat2x4\"\r\n        : B extends \"vec3\"\r\n          ? \"mat3x4\"\r\n          : B extends \"vec4\"\r\n            ? \"mat4\"\r\n            : never\r\n      : never;\r\n\r\nfunction outerOutputType<\r\n  A extends \"vec2\" | \"vec3\" | \"vec4\",\r\n  B extends \"vec2\" | \"vec3\" | \"vec4\",\r\n>(aType: A, bType: B): OuterOutput<A, B> {\r\n  if (aType === \"vec2\") {\r\n    if (bType === \"vec2\") return \"mat2\" as OuterOutput<A, B>;\r\n    if (bType === \"vec3\") return \"mat3x2\" as OuterOutput<A, B>;\r\n    if (bType === \"vec4\") return \"mat4x2\" as OuterOutput<A, B>;\r\n  }\r\n  if (aType === \"vec3\") {\r\n    if (bType === \"vec2\") return \"mat2x3\" as OuterOutput<A, B>;\r\n    if (bType === \"vec3\") return \"mat3\" as OuterOutput<A, B>;\r\n    if (bType === \"vec4\") return \"mat4x3\" as OuterOutput<A, B>;\r\n  }\r\n  if (aType === \"vec4\") {\r\n    if (bType === \"vec2\") return \"mat2x4\" as OuterOutput<A, B>;\r\n    if (bType === \"vec3\") return \"mat3x4\" as OuterOutput<A, B>;\r\n    if (bType === \"vec4\") return \"mat4\" as OuterOutput<A, B>;\r\n  }\r\n  throw new Error(`Invalid outer type: ${aType}, ${bType}`);\r\n}\r\n\r\nexport class Outer<\r\n  A extends \"vec2\" | \"vec3\" | \"vec4\",\r\n  B extends \"vec2\" | \"vec3\" | \"vec4\",\r\n> extends BinaryOp<A, B, OuterOutput<A, B>, \"outer\"> {\r\n  constructor({ a, b }: { a: DynoVal<A>; b: DynoVal<B> }) {\r\n    super({ a, b, outKey: \"outer\", outTypeFunc: outerOutputType });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.outer} = outerProduct(${inputs.a}, ${inputs.b});`,\r\n    ];\r\n  }\r\n}\r\n\r\ntype TransposeOutput<A extends MatFloatTypes> = A extends SquareMatTypes\r\n  ? A\r\n  : A extends \"mat2x3\"\r\n    ? \"mat3x2\"\r\n    : A extends \"mat2x4\"\r\n      ? \"mat4x2\"\r\n      : A extends \"mat3x2\"\r\n        ? \"mat2x3\"\r\n        : A extends \"mat3x4\"\r\n          ? \"mat4x3\"\r\n          : A extends \"mat4x2\"\r\n            ? \"mat2x4\"\r\n            : A extends \"mat4x3\"\r\n              ? \"mat3x4\"\r\n              : never;\r\n\r\nfunction transposeOutputType<A extends MatFloatTypes>(\r\n  type: A,\r\n): TransposeOutput<A> {\r\n  if (type === \"mat2\") return \"mat2\" as TransposeOutput<A>;\r\n  if (type === \"mat3\") return \"mat3\" as TransposeOutput<A>;\r\n  if (type === \"mat4\") return \"mat4\" as TransposeOutput<A>;\r\n  if (type === \"mat2x2\") return \"mat2x2\" as TransposeOutput<A>;\r\n  if (type === \"mat2x3\") return \"mat3x2\" as TransposeOutput<A>;\r\n  if (type === \"mat2x4\") return \"mat4x2\" as TransposeOutput<A>;\r\n  if (type === \"mat3x2\") return \"mat2x3\" as TransposeOutput<A>;\r\n  if (type === \"mat3x3\") return \"mat3x3\" as TransposeOutput<A>;\r\n  if (type === \"mat3x4\") return \"mat4x3\" as TransposeOutput<A>;\r\n  if (type === \"mat4x2\") return \"mat2x4\" as TransposeOutput<A>;\r\n  if (type === \"mat4x3\") return \"mat3x4\" as TransposeOutput<A>;\r\n  if (type === \"mat4x4\") return \"mat4x4\" as TransposeOutput<A>;\r\n  throw new Error(`Invalid transpose type: ${type}`);\r\n}\r\n\r\nexport class Transpose<A extends MatFloatTypes> extends UnaryOp<\r\n  A,\r\n  TransposeOutput<A>,\r\n  \"transpose\"\r\n> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"transpose\", outTypeFunc: transposeOutputType });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.transpose} = transpose(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Determinant<A extends SquareMatTypes> extends UnaryOp<\r\n  A,\r\n  \"float\",\r\n  \"det\"\r\n> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"det\", outTypeFunc: (aType) => \"float\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.det} = determinant(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Inverse<A extends SquareMatTypes> extends UnaryOp<\r\n  A,\r\n  A,\r\n  \"inverse\"\r\n> {\r\n  constructor({ a }: { a: DynoVal<A> }) {\r\n    super({ a, outKey: \"inverse\", outTypeFunc: (aType) => aType });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.inverse} = inverse(${a});`,\r\n    ];\r\n  }\r\n}\r\n\r\ntype SplitOutTypes<A extends VectorTypes> = A extends \"vec2\"\r\n  ? { x: \"float\"; y: \"float\"; r: \"float\"; g: \"float\" }\r\n  : A extends \"vec3\"\r\n    ? { x: \"float\"; y: \"float\"; z: \"float\"; r: \"float\"; g: \"float\"; b: \"float\" }\r\n    : A extends \"vec4\"\r\n      ? {\r\n          x: \"float\";\r\n          y: \"float\";\r\n          z: \"float\";\r\n          w: \"float\";\r\n          r: \"float\";\r\n          g: \"float\";\r\n          b: \"float\";\r\n          a: \"float\";\r\n        }\r\n      : A extends \"ivec2\"\r\n        ? { x: \"int\"; y: \"int\"; r: \"int\"; g: \"int\" }\r\n        : A extends \"ivec3\"\r\n          ? { x: \"int\"; y: \"int\"; z: \"int\"; r: \"int\"; g: \"int\"; b: \"int\" }\r\n          : A extends \"ivec4\"\r\n            ? {\r\n                x: \"int\";\r\n                y: \"int\";\r\n                z: \"int\";\r\n                w: \"int\";\r\n                r: \"int\";\r\n                g: \"int\";\r\n                b: \"int\";\r\n                a: \"int\";\r\n              }\r\n            : A extends \"uvec2\"\r\n              ? { x: \"uint\"; y: \"uint\"; r: \"uint\"; g: \"uint\" }\r\n              : A extends \"uvec3\"\r\n                ? {\r\n                    x: \"uint\";\r\n                    y: \"uint\";\r\n                    z: \"uint\";\r\n                    r: \"uint\";\r\n                    g: \"uint\";\r\n                    b: \"uint\";\r\n                  }\r\n                : A extends \"uvec4\"\r\n                  ? {\r\n                      x: \"uint\";\r\n                      y: \"uint\";\r\n                      z: \"uint\";\r\n                      w: \"uint\";\r\n                      r: \"uint\";\r\n                      g: \"uint\";\r\n                      b: \"uint\";\r\n                      a: \"uint\";\r\n                    }\r\n                  : never;\r\n\r\nfunction splitOutTypes<A extends VectorTypes>(type: A): SplitOutTypes<A> {\r\n  const result = (value: unknown) => value as SplitOutTypes<A>;\r\n  switch (type) {\r\n    case \"vec2\":\r\n      return result({ x: \"float\", y: \"float\", r: \"float\", g: \"float\" });\r\n    case \"vec3\":\r\n      return result({\r\n        x: \"float\",\r\n        y: \"float\",\r\n        z: \"float\",\r\n        r: \"float\",\r\n        g: \"float\",\r\n        b: \"float\",\r\n      });\r\n    case \"vec4\":\r\n      return result({\r\n        x: \"float\",\r\n        y: \"float\",\r\n        z: \"float\",\r\n        w: \"float\",\r\n        r: \"float\",\r\n        g: \"float\",\r\n        b: \"float\",\r\n        a: \"float\",\r\n      });\r\n    case \"ivec2\":\r\n      return result({ x: \"int\", y: \"int\", r: \"int\", g: \"int\" });\r\n    case \"ivec3\":\r\n      return result({\r\n        x: \"int\",\r\n        y: \"int\",\r\n        z: \"int\",\r\n        r: \"int\",\r\n        g: \"int\",\r\n        b: \"int\",\r\n      });\r\n    case \"ivec4\":\r\n      return result({\r\n        x: \"int\",\r\n        y: \"int\",\r\n        z: \"int\",\r\n        w: \"int\",\r\n        r: \"int\",\r\n        g: \"int\",\r\n        b: \"int\",\r\n        a: \"int\",\r\n      });\r\n    case \"uvec2\":\r\n      return result({ x: \"uint\", y: \"uint\", r: \"uint\", g: \"uint\" });\r\n    case \"uvec3\":\r\n      return result({\r\n        x: \"uint\",\r\n        y: \"uint\",\r\n        z: \"uint\",\r\n        r: \"uint\",\r\n        g: \"uint\",\r\n        b: \"uint\",\r\n      });\r\n    case \"uvec4\":\r\n      return result({\r\n        x: \"uint\",\r\n        y: \"uint\",\r\n        z: \"uint\",\r\n        w: \"uint\",\r\n        r: \"uint\",\r\n        g: \"uint\",\r\n        b: \"uint\",\r\n        a: \"uint\",\r\n      });\r\n    default:\r\n      throw new Error(`Invalid vector type: ${type}`);\r\n  }\r\n}\r\n\r\nexport class Split<V extends VectorTypes> extends Dyno<\r\n  { vector: V },\r\n  SplitOutTypes<V>\r\n> {\r\n  constructor({ vector }: { vector: DynoVal<V> }) {\r\n    const type = valType(vector);\r\n    const inTypes = { vector: type };\r\n    const outTypes = splitOutTypes(inTypes.vector);\r\n    super({ inTypes, outTypes, inputs: { vector } });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      const { x, y, z, w, r, g, b, a } = outputs as unknown as Record<\r\n        string,\r\n        string\r\n      >;\r\n      const { vector } = inputs;\r\n      return [\r\n        x ? `${x} = ${vector}.x;` : null,\r\n        y ? `${y} = ${vector}.y;` : null,\r\n        z ? `${z} = ${vector}.z;` : null,\r\n        w ? `${w} = ${vector}.w;` : null,\r\n        r ? `${r} = ${vector}.r;` : null,\r\n        g ? `${g} = ${vector}.g;` : null,\r\n        b ? `${b} = ${vector}.b;` : null,\r\n        a ? `${a} = ${vector}.a;` : null,\r\n      ].filter(Boolean) as string[];\r\n    };\r\n  }\r\n}\r\n\r\nexport class Combine<V extends VectorTypes, T extends VectorElementType<V>>\r\n  extends Dyno<SplitOutTypes<V> & { vector: V }, { vector: V }>\r\n  implements HasDynoOut<V>\r\n{\r\n  constructor({\r\n    vector,\r\n    vectorType,\r\n    x,\r\n    y,\r\n    z,\r\n    w,\r\n    r,\r\n    g,\r\n    b,\r\n    a,\r\n  }: {\r\n    vector?: DynoVal<V>;\r\n    vectorType?: V;\r\n    x?: DynoVal<T>;\r\n    y?: DynoVal<T>;\r\n    z?: DynoVal<T>;\r\n    w?: DynoVal<T>;\r\n    r?: DynoVal<T>;\r\n    g?: DynoVal<T>;\r\n    b?: DynoVal<T>;\r\n    a?: DynoVal<T>;\r\n  }) {\r\n    if (!vector && !vectorType) {\r\n      throw new Error(\"Either vector or vectorType must be provided\");\r\n    }\r\n    const vType = vectorType ?? valType(vector as DynoVal<V>);\r\n    const elType = vectorElementType(vType);\r\n    const dim = vectorDim(vType);\r\n\r\n    const inTypes = {\r\n      vector: vType,\r\n      x: elType,\r\n      y: elType,\r\n      r: elType,\r\n      g: elType,\r\n    } as unknown as SplitOutTypes<V> & { vector: V };\r\n    const inputs = { vector, x, y, r, g };\r\n    if (dim >= 3) {\r\n      Object.assign(inTypes, { z: elType, b: elType });\r\n      Object.assign(inputs, { z, b });\r\n    }\r\n    if (dim >= 4) {\r\n      Object.assign(inTypes, { w: elType, a: elType });\r\n      Object.assign(inputs, { w, a });\r\n    }\r\n    // @ts-ignore\r\n    super({ inTypes, outTypes: { vector: vType }, inputs });\r\n    this.statements = ({ inputs, outputs }) => {\r\n      const { vector } = outputs;\r\n      const {\r\n        vector: input,\r\n        x,\r\n        y,\r\n        z,\r\n        w,\r\n        r,\r\n        g,\r\n        b,\r\n        a,\r\n      } = inputs as Record<string, string>;\r\n      const statements = [\r\n        `${vector}.x = ${x ?? r ?? (input ? `${input}.x` : literalZero(elType))};`,\r\n        `${vector}.y = ${y ?? g ?? (input ? `${input}.y` : literalZero(elType))};`,\r\n      ];\r\n      if (dim >= 3)\r\n        statements.push(\r\n          `${vector}.z = ${z ?? b ?? (input ? `${input}.z` : literalZero(elType))};`,\r\n        );\r\n      if (dim >= 4)\r\n        statements.push(\r\n          `${vector}.w = ${w ?? a ?? (input ? `${input}.w` : literalZero(elType))};`,\r\n        );\r\n      return statements;\r\n    };\r\n  }\r\n\r\n  dynoOut(): DynoValue<V> {\r\n    return new DynoOutput<V, SplitOutTypes<V> & { vector: V }, { vector: V }>(\r\n      this,\r\n      \"vector\",\r\n    );\r\n  }\r\n}\r\n\r\ntype SwizzleOutput<\r\n  A extends VectorTypes,\r\n  Len extends number,\r\n> = A extends FloatTypes\r\n  ? Len extends 1\r\n    ? \"float\"\r\n    : Len extends 2\r\n      ? \"vec2\"\r\n      : Len extends 3\r\n        ? \"vec3\"\r\n        : Len extends 4\r\n          ? \"vec4\"\r\n          : never\r\n  : A extends IntTypes\r\n    ? Len extends 1\r\n      ? \"int\"\r\n      : Len extends 2\r\n        ? \"ivec2\"\r\n        : Len extends 3\r\n          ? \"ivec3\"\r\n          : Len extends 4\r\n            ? \"ivec4\"\r\n            : never\r\n    : A extends UintTypes\r\n      ? Len extends 1\r\n        ? \"uint\"\r\n        : Len extends 2\r\n          ? \"uvec2\"\r\n          : Len extends 3\r\n            ? \"uvec3\"\r\n            : Len extends 4\r\n              ? \"uvec4\"\r\n              : never\r\n      : never;\r\n\r\ntype SwizzleSelectLen<S extends SwizzleSelect> = S extends Swizzle1Select\r\n  ? 1\r\n  : S extends Swizzle2Select\r\n    ? 2\r\n    : S extends Swizzle3Select\r\n      ? 3\r\n      : S extends Swizzle4Select\r\n        ? 4\r\n        : never;\r\n\r\nfunction swizzleOutputType<A extends VectorTypes, S extends SwizzleSelect>(\r\n  type: A,\r\n  swizzle: S,\r\n): SwizzleOutput<A, SwizzleSelectLen<S>> {\r\n  let result = null;\r\n  if (isFloatType(type)) {\r\n    result =\r\n      swizzle.length === 1\r\n        ? \"float\"\r\n        : swizzle.length === 2\r\n          ? \"vec2\"\r\n          : swizzle.length === 3\r\n            ? \"vec3\"\r\n            : swizzle.length === 4\r\n              ? \"vec4\"\r\n              : null;\r\n  } else if (isIntType(type)) {\r\n    result =\r\n      swizzle.length === 1\r\n        ? \"int\"\r\n        : swizzle.length === 2\r\n          ? \"ivec2\"\r\n          : swizzle.length === 3\r\n            ? \"ivec3\"\r\n            : swizzle.length === 4\r\n              ? \"ivec4\"\r\n              : null;\r\n  } else if (isUintType(type)) {\r\n    result =\r\n      swizzle.length === 1\r\n        ? \"uint\"\r\n        : swizzle.length === 2\r\n          ? \"uvec2\"\r\n          : swizzle.length === 3\r\n            ? \"uvec3\"\r\n            : swizzle.length === 4\r\n              ? \"uvec4\"\r\n              : null;\r\n  }\r\n  if (result == null) {\r\n    throw new Error(`Invalid swizzle: ${swizzle}`);\r\n  }\r\n  return result as SwizzleOutput<A, SwizzleSelectLen<S>>;\r\n}\r\n\r\ntype Swizzle1Select = `${\"x\" | \"y\" | \"z\" | \"w\"}|${\"r\" | \"g\" | \"b\" | \"a\"}`;\r\ntype Swizzle2Select =\r\n  | `${\"x\" | \"y\" | \"z\" | \"w\"}${\"x\" | \"y\" | \"z\" | \"w\"}`\r\n  | `${\"r\" | \"g\" | \"b\" | \"a\"}${\"r\" | \"g\" | \"b\" | \"a\"}`;\r\ntype Swizzle3Select =\r\n  | `${\"x\" | \"y\" | \"z\" | \"w\"}${\"x\" | \"y\" | \"z\" | \"w\"}${\"x\" | \"y\" | \"z\" | \"w\"}`\r\n  | `${\"r\" | \"g\" | \"b\" | \"a\"}${\"r\" | \"g\" | \"b\" | \"a\"}${\"r\" | \"g\" | \"b\" | \"a\"}`;\r\ntype Swizzle4Select =\r\n  | `${\"x\" | \"y\" | \"z\" | \"w\"}${\"x\" | \"y\" | \"z\" | \"w\"}${\"x\" | \"y\" | \"z\" | \"w\"}${\"x\" | \"y\" | \"z\" | \"w\"}`\r\n  | `${\"r\" | \"g\" | \"b\" | \"a\"}${\"r\" | \"g\" | \"b\" | \"a\"}${\"r\" | \"g\" | \"b\" | \"a\"}${\"r\" | \"g\" | \"b\" | \"a\"}`;\r\ntype SwizzleSelect =\r\n  | Swizzle1Select\r\n  | Swizzle2Select\r\n  | Swizzle3Select\r\n  | Swizzle4Select;\r\n\r\nexport class Swizzle<\r\n  A extends VectorTypes,\r\n  S extends SwizzleSelect,\r\n> extends UnaryOp<A, SwizzleOutput<A, SwizzleSelectLen<S>>, \"swizzle\"> {\r\n  constructor({ vector, select }: { vector: DynoVal<A>; select: S }) {\r\n    super({\r\n      a: vector,\r\n      outKey: \"swizzle\",\r\n      outTypeFunc: (aType) => swizzleOutputType<A, S>(aType, select),\r\n    });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.swizzle} = ${inputs.a}.${select};`,\r\n    ];\r\n  }\r\n}\r\n","import { Dyno, DynoBlock, unindent } from \"./base\";\r\nimport { float, vec2, vec3, vec4 } from \"./convert\";\r\nimport { mul } from \"./math\";\r\nimport { type ValueTypes, isIntType, isUintType, sameSizeUvec } from \"./types\";\r\nimport {\r\n  DynoOutput,\r\n  type DynoVal,\r\n  type DynoValue,\r\n  type HasDynoOut,\r\n  dynoConst,\r\n  valType,\r\n} from \"./value\";\r\nimport { combine } from \"./vecmat\";\r\n\r\nexport const remapIndex = (\r\n  index: DynoVal<\"int\">,\r\n  from: DynoVal<\"int\">,\r\n  to: DynoVal<\"int\">,\r\n): DynoVal<\"int\"> => {\r\n  return new DynoRemapIndex({ index, from, to });\r\n};\r\nexport const pcgMix = <T extends ValueTypes>(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"uint\"> => {\r\n  return new PcgMix({ value });\r\n};\r\nexport const pcgNext = (state: DynoVal<\"uint\">): DynoVal<\"uint\"> => {\r\n  return new PcgNext({ state });\r\n};\r\nexport const pcgHash = (state: DynoVal<\"uint\">): DynoVal<\"uint\"> => {\r\n  return new PcgHash({ state });\r\n};\r\nexport const hash = <T extends ValueTypes>(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"uint\"> => {\r\n  return new Hash({ value });\r\n};\r\nexport const hash2 = <T extends ValueTypes>(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"uvec2\"> => {\r\n  return new Hash2({ value });\r\n};\r\nexport const hash3 = <T extends ValueTypes>(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"uvec3\"> => {\r\n  return new Hash3({ value });\r\n};\r\nexport const hash4 = <T extends ValueTypes>(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"uvec4\"> => {\r\n  return new Hash4({ value });\r\n};\r\nexport const hashFloat = <T extends ValueTypes>(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"float\"> => {\r\n  return new HashFloat({ value });\r\n};\r\nexport const hashVec2 = <T extends ValueTypes>(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"vec2\"> => {\r\n  return new HashVec2({ value });\r\n};\r\nexport const hashVec3 = <T extends ValueTypes>(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"vec3\"> => {\r\n  return new HashVec3({ value });\r\n};\r\nexport const hashVec4 = <T extends ValueTypes>(\r\n  value: DynoVal<T>,\r\n): DynoVal<\"vec4\"> => {\r\n  return new HashVec4({ value });\r\n};\r\nexport const normalizedDepth = (\r\n  z: DynoVal<\"float\">,\r\n  zNear: DynoVal<\"float\">,\r\n  zFar: DynoVal<\"float\">,\r\n): DynoVal<\"float\"> => {\r\n  return new NormalizedDepth({ z, zNear, zFar }).outputs.depth;\r\n};\r\n\r\nexport class DynoRemapIndex\r\n  extends Dyno<{ from: \"int\"; to: \"int\"; index: \"int\" }, { index: \"int\" }>\r\n  implements HasDynoOut<\"int\">\r\n{\r\n  constructor({\r\n    from,\r\n    to,\r\n    index,\r\n  }: { from: DynoVal<\"int\">; to: DynoVal<\"int\">; index: DynoVal<\"int\"> }) {\r\n    super({\r\n      inTypes: { from: \"int\", to: \"int\", index: \"int\" },\r\n      outTypes: { index: \"int\" },\r\n      inputs: { from, to, index },\r\n      statements: ({ inputs, outputs }) => {\r\n        return [\r\n          `${outputs.index} = ${inputs.index} - ${inputs.from} + ${inputs.to};`,\r\n        ];\r\n      },\r\n    });\r\n  }\r\n\r\n  dynoOut(): DynoValue<\"int\"> {\r\n    return new DynoOutput(this, \"index\");\r\n  }\r\n}\r\n\r\nexport class PcgNext<T extends \"uint\" | \"int\" | \"float\">\r\n  extends Dyno<{ state: T }, { state: \"uint\" }>\r\n  implements HasDynoOut<\"uint\">\r\n{\r\n  constructor({ state }: { state: DynoVal<T> }) {\r\n    const type = valType(state);\r\n    super({\r\n      inTypes: { state: type },\r\n      outTypes: { state: \"uint\" },\r\n      inputs: { state },\r\n      globals: () => [\r\n        unindent(`\r\n          uint pcg_next(uint state) {\r\n            return state * 747796405u + 2891336453u;\r\n          }\r\n        `),\r\n      ],\r\n      statements: ({ inputs, outputs }) => {\r\n        const toUint =\r\n          type === \"uint\"\r\n            ? `${inputs.state}`\r\n            : type === \"int\"\r\n              ? `uint(${inputs.state})`\r\n              : `floatBitsToUint(${inputs.state})`;\r\n        return [`${outputs.state} = pcg_next(${toUint});`];\r\n      },\r\n    });\r\n  }\r\n  dynoOut(): DynoValue<\"uint\"> {\r\n    return new DynoOutput(this, \"state\");\r\n  }\r\n}\r\n\r\nexport class PcgHash\r\n  extends Dyno<{ state: \"uint\" }, { hash: \"uint\" }>\r\n  implements HasDynoOut<\"uint\">\r\n{\r\n  constructor({ state }: { state: DynoVal<\"uint\"> }) {\r\n    super({\r\n      inTypes: { state: \"uint\" },\r\n      outTypes: { hash: \"uint\" },\r\n      inputs: { state },\r\n      globals: () => [\r\n        unindent(`\r\n          uint pcg_hash(uint state) {\r\n            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\r\n            return (hash >> 22u) ^ hash;\r\n          }\r\n        `),\r\n      ],\r\n      statements: ({ inputs, outputs }) => [\r\n        `${outputs.hash} = pcg_hash(${inputs.state});`,\r\n      ],\r\n    });\r\n  }\r\n  dynoOut(): DynoValue<\"uint\"> {\r\n    return new DynoOutput(this, \"hash\");\r\n  }\r\n}\r\n\r\nexport class PcgMix<T extends ValueTypes>\r\n  extends Dyno<{ value: T }, { state: \"uint\" }>\r\n  implements HasDynoOut<\"uint\">\r\n{\r\n  constructor({ value }: { value: DynoVal<T> }) {\r\n    const type = valType(value);\r\n    const tempType = sameSizeUvec(type);\r\n    super({\r\n      inTypes: { value: type },\r\n      outTypes: { state: \"uint\" },\r\n      inputs: { value },\r\n      globals: () => [\r\n        unindent(`\r\n          uint pcg_mix(uint value) {\r\n            return value;\r\n          }\r\n          uint pcg_mix(uvec2 value) {\r\n            return value.x + 0x9e3779b9u * value.y;\r\n          }\r\n          uint pcg_mix(uvec3 value) {\r\n            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;\r\n          }\r\n          uint pcg_mix(uvec4 value) {\r\n            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;\r\n          }\r\n        `),\r\n      ],\r\n      statements: ({ inputs, outputs }) => {\r\n        const toUvec = isUintType(type)\r\n          ? `${inputs.value}`\r\n          : isIntType(type)\r\n            ? `${tempType}(${inputs.value})`\r\n            : `floatBitsToUint(${inputs.value})`;\r\n        return [\r\n          `${tempType} bits = ${toUvec};`,\r\n          `${outputs.state} = pcg_mix(bits);`,\r\n        ];\r\n      },\r\n    });\r\n  }\r\n  dynoOut(): DynoValue<\"uint\"> {\r\n    return new DynoOutput(this, \"state\");\r\n  }\r\n}\r\n\r\nexport class Hash<T extends ValueTypes>\r\n  extends DynoBlock<{ value: T }, { hash: \"uint\" }>\r\n  implements HasDynoOut<\"uint\">\r\n{\r\n  constructor({ value }: { value: DynoVal<T> }) {\r\n    super({\r\n      inTypes: { value: valType(value) },\r\n      outTypes: { hash: \"uint\" },\r\n      inputs: { value },\r\n      construct: ({ value }) => {\r\n        if (!value) {\r\n          throw new Error(\"value is required\");\r\n        }\r\n        let state = new PcgMix({ value: value }).outputs.state;\r\n        state = new PcgNext({ state }).outputs.state;\r\n        return new PcgHash({ state }).outputs;\r\n      },\r\n    });\r\n  }\r\n  dynoOut(): DynoValue<\"uint\"> {\r\n    return new DynoOutput(this, \"hash\");\r\n  }\r\n}\r\n\r\nexport class Hash2<T extends ValueTypes>\r\n  extends DynoBlock<{ value: T }, { hash: \"uvec2\" }>\r\n  implements HasDynoOut<\"uvec2\">\r\n{\r\n  constructor({ value }: { value: DynoVal<T> }) {\r\n    super({\r\n      inTypes: { value: valType(value) },\r\n      outTypes: { hash: \"uvec2\" },\r\n      inputs: { value },\r\n      construct: ({ value }) => {\r\n        if (!value) {\r\n          throw new Error(\"value is required\");\r\n        }\r\n        let state = new PcgMix({ value: value }).outputs.state;\r\n        state = new PcgNext({ state }).outputs.state;\r\n        const x = new PcgHash({ state }).outputs.hash;\r\n        state = new PcgNext({ state }).outputs.state;\r\n        const y = new PcgHash({ state }).outputs.hash;\r\n        return { hash: combine({ vectorType: \"uvec2\", x, y }) };\r\n      },\r\n    });\r\n  }\r\n  dynoOut(): DynoValue<\"uvec2\"> {\r\n    return new DynoOutput(this, \"hash\");\r\n  }\r\n}\r\n\r\nexport class Hash3<T extends ValueTypes>\r\n  extends DynoBlock<{ value: T }, { hash: \"uvec3\" }>\r\n  implements HasDynoOut<\"uvec3\">\r\n{\r\n  constructor({ value }: { value: DynoVal<T> }) {\r\n    super({\r\n      inTypes: { value: valType(value) },\r\n      outTypes: { hash: \"uvec3\" },\r\n      inputs: { value },\r\n      construct: ({ value }) => {\r\n        if (!value) {\r\n          throw new Error(\"value is required\");\r\n        }\r\n        let state = new PcgMix({ value: value }).outputs.state;\r\n        state = new PcgNext({ state }).outputs.state;\r\n        const x = new PcgHash({ state }).outputs.hash;\r\n        state = new PcgNext({ state }).outputs.state;\r\n        const y = new PcgHash({ state }).outputs.hash;\r\n        state = new PcgNext({ state }).outputs.state;\r\n        const z = new PcgHash({ state }).outputs.hash;\r\n        return { hash: combine({ vectorType: \"uvec3\", x, y, z }) };\r\n      },\r\n    });\r\n  }\r\n  dynoOut(): DynoValue<\"uvec3\"> {\r\n    return new DynoOutput(this, \"hash\");\r\n  }\r\n}\r\n\r\nexport class Hash4<T extends ValueTypes>\r\n  extends DynoBlock<{ value: T }, { hash: \"uvec4\" }>\r\n  implements HasDynoOut<\"uvec4\">\r\n{\r\n  constructor({ value }: { value: DynoVal<T> }) {\r\n    super({\r\n      inTypes: { value: valType(value) },\r\n      outTypes: { hash: \"uvec4\" },\r\n      inputs: { value },\r\n      construct: ({ value }) => {\r\n        if (!value) {\r\n          throw new Error(\"value is required\");\r\n        }\r\n        let state = new PcgMix({ value: value }).outputs.state;\r\n        state = new PcgNext({ state }).outputs.state;\r\n        const x = new PcgHash({ state }).outputs.hash;\r\n        state = new PcgNext({ state }).outputs.state;\r\n        const y = new PcgHash({ state }).outputs.hash;\r\n        state = new PcgNext({ state }).outputs.state;\r\n        const z = new PcgHash({ state }).outputs.hash;\r\n        state = new PcgNext({ state }).outputs.state;\r\n        const w = new PcgHash({ state }).outputs.hash;\r\n        return { hash: combine({ vectorType: \"uvec4\", x, y, z, w }) };\r\n      },\r\n    });\r\n  }\r\n  dynoOut(): DynoValue<\"uvec4\"> {\r\n    return new DynoOutput(this, \"hash\");\r\n  }\r\n}\r\n\r\nexport class HashFloat<T extends ValueTypes>\r\n  extends DynoBlock<{ value: T }, { hash: \"float\" }>\r\n  implements HasDynoOut<\"float\">\r\n{\r\n  constructor({ value }: { value: DynoVal<T> }) {\r\n    super({\r\n      inTypes: { value: valType(value) },\r\n      outTypes: { hash: \"float\" },\r\n      inputs: { value },\r\n      construct: ({ value }) => {\r\n        if (!value) {\r\n          throw new Error(\"value is required\");\r\n        }\r\n        const word = hash(value);\r\n        return { hash: mul(float(word), dynoConst(\"float\", 1 / 2 ** 32)) };\r\n      },\r\n    });\r\n  }\r\n  dynoOut(): DynoValue<\"float\"> {\r\n    return new DynoOutput(this, \"hash\");\r\n  }\r\n}\r\n\r\nexport class HashVec2<T extends ValueTypes>\r\n  extends DynoBlock<{ value: T }, { hash: \"vec2\" }>\r\n  implements HasDynoOut<\"vec2\">\r\n{\r\n  constructor({ value }: { value: DynoVal<T> }) {\r\n    super({\r\n      inTypes: { value: valType(value) },\r\n      outTypes: { hash: \"vec2\" },\r\n      inputs: { value },\r\n      construct: ({ value }) => {\r\n        if (!value) {\r\n          throw new Error(\"value is required\");\r\n        }\r\n        const words = hash2(value);\r\n        return { hash: mul(vec2(words), dynoConst(\"float\", 1 / 2 ** 32)) };\r\n      },\r\n    });\r\n  }\r\n  dynoOut(): DynoValue<\"vec2\"> {\r\n    return new DynoOutput(this, \"hash\");\r\n  }\r\n}\r\n\r\nexport class HashVec3<T extends ValueTypes>\r\n  extends DynoBlock<{ value: T }, { hash: \"vec3\" }>\r\n  implements HasDynoOut<\"vec3\">\r\n{\r\n  constructor({ value }: { value: DynoVal<T> }) {\r\n    super({\r\n      inTypes: { value: valType(value) },\r\n      outTypes: { hash: \"vec3\" },\r\n      inputs: { value },\r\n      construct: ({ value }) => {\r\n        if (!value) {\r\n          throw new Error(\"value is required\");\r\n        }\r\n        const words = hash3(value);\r\n        return { hash: mul(vec3(words), dynoConst(\"float\", 1 / 2 ** 32)) };\r\n      },\r\n    });\r\n  }\r\n  dynoOut(): DynoValue<\"vec3\"> {\r\n    return new DynoOutput(this, \"hash\");\r\n  }\r\n}\r\n\r\nexport class HashVec4<T extends ValueTypes>\r\n  extends DynoBlock<{ value: T }, { hash: \"vec4\" }>\r\n  implements HasDynoOut<\"vec4\">\r\n{\r\n  constructor({ value }: { value: DynoVal<T> }) {\r\n    super({\r\n      inTypes: { value: valType(value) },\r\n      outTypes: { hash: \"vec4\" },\r\n      inputs: { value },\r\n      construct: ({ value }) => {\r\n        if (!value) {\r\n          throw new Error(\"value is required\");\r\n        }\r\n        const words = hash4(value);\r\n        return { hash: mul(vec4(words), dynoConst(\"float\", 1 / 2 ** 32)) };\r\n      },\r\n    });\r\n  }\r\n  dynoOut(): DynoValue<\"vec4\"> {\r\n    return new DynoOutput(this, \"hash\");\r\n  }\r\n}\r\n\r\nexport class NormalizedDepth\r\n  extends Dyno<\r\n    { z: \"float\"; zNear: \"float\"; zFar: \"float\" },\r\n    { depth: \"float\" }\r\n  >\r\n  implements HasDynoOut<\"float\">\r\n{\r\n  constructor({\r\n    z,\r\n    zNear,\r\n    zFar,\r\n  }: { z: DynoVal<\"float\">; zNear: DynoVal<\"float\">; zFar: DynoVal<\"float\"> }) {\r\n    super({\r\n      inTypes: { z: \"float\", zNear: \"float\", zFar: \"float\" },\r\n      outTypes: { depth: \"float\" },\r\n      inputs: { z, zNear, zFar },\r\n      statements: ({ inputs, outputs }) => [\r\n        `float clamped = clamp(${inputs.z}, ${inputs.zNear}, ${inputs.zFar});`,\r\n        `${outputs.depth} = (log2(clamped + 1.0) - log2(${inputs.zNear} + 1.0)) / (log2(${inputs.zFar} + 1.0) - log2(${inputs.zNear} + 1.0));`,\r\n      ],\r\n    });\r\n  }\r\n\r\n  dynoOut(): DynoValue<\"float\"> {\r\n    return new DynoOutput(this, \"depth\");\r\n  }\r\n}\r\n","import { Dyno } from \"./base\";\r\nimport type { DynoVal } from \"./value\";\r\n\r\nexport const transformPos = (\r\n  position: DynoVal<\"vec3\">,\r\n  {\r\n    scale,\r\n    scales,\r\n    rotate,\r\n    translate,\r\n  }: {\r\n    scale?: DynoVal<\"float\">;\r\n    scales?: DynoVal<\"vec3\">;\r\n    rotate?: DynoVal<\"vec4\">;\r\n    translate?: DynoVal<\"vec3\">;\r\n  },\r\n): DynoVal<\"vec3\"> => {\r\n  return new TransformPosition({ position, scale, scales, rotate, translate })\r\n    .outputs.position;\r\n};\r\nexport const transformDir = (\r\n  dir: DynoVal<\"vec3\">,\r\n  {\r\n    scale,\r\n    scales,\r\n    rotate,\r\n  }: {\r\n    scale?: DynoVal<\"float\">;\r\n    scales?: DynoVal<\"vec3\">;\r\n    rotate?: DynoVal<\"vec4\">;\r\n  },\r\n): DynoVal<\"vec3\"> => {\r\n  return new TransformDir({ dir, scale, scales, rotate }).outputs.dir;\r\n};\r\nexport const transformQuat = (\r\n  quaternion: DynoVal<\"vec4\">,\r\n  { rotate }: { rotate?: DynoVal<\"vec4\"> },\r\n): DynoVal<\"vec4\"> => {\r\n  return new TransformQuaternion({ quaternion, rotate }).outputs.quaternion;\r\n};\r\n\r\nexport class TransformPosition extends Dyno<\r\n  {\r\n    position: \"vec3\";\r\n    scale: \"float\";\r\n    scales: \"vec3\";\r\n    rotate: \"vec4\";\r\n    translate: \"vec3\";\r\n  },\r\n  { position: \"vec3\" }\r\n> {\r\n  constructor({\r\n    position,\r\n    scale,\r\n    scales,\r\n    rotate,\r\n    translate,\r\n  }: {\r\n    position?: DynoVal<\"vec3\">;\r\n    scale?: DynoVal<\"float\">;\r\n    scales?: DynoVal<\"vec3\">;\r\n    rotate?: DynoVal<\"vec4\">;\r\n    translate?: DynoVal<\"vec3\">;\r\n  }) {\r\n    super({\r\n      inTypes: {\r\n        position: \"vec3\",\r\n        scale: \"float\",\r\n        scales: \"vec3\",\r\n        rotate: \"vec4\",\r\n        translate: \"vec3\",\r\n      },\r\n      outTypes: { position: \"vec3\" },\r\n      inputs: { position, scale, scales, rotate, translate },\r\n      statements: ({ inputs, outputs }) => {\r\n        const { position } = outputs;\r\n        if (!position) {\r\n          return [];\r\n        }\r\n        const { scale, scales, rotate, translate } = inputs;\r\n        return [\r\n          `${position} = ${inputs.position ?? \"vec3(0.0, 0.0, 0.0)\"};`,\r\n          !scale ? null : `${position} *= ${scale};`,\r\n          !scales ? null : `${position} *= ${scales};`,\r\n          !rotate ? null : `${position} = quatVec(${rotate}, ${position});`,\r\n          !translate ? null : `${position} += ${translate};`,\r\n        ].filter(Boolean) as string[];\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport class TransformDir extends Dyno<\r\n  { dir: \"vec3\"; scale: \"float\"; scales: \"vec3\"; rotate: \"vec4\" },\r\n  { dir: \"vec3\" }\r\n> {\r\n  constructor({\r\n    dir,\r\n    scale,\r\n    scales,\r\n    rotate,\r\n  }: {\r\n    dir?: DynoVal<\"vec3\">;\r\n    scale?: DynoVal<\"float\">;\r\n    scales?: DynoVal<\"vec3\">;\r\n    rotate?: DynoVal<\"vec4\">;\r\n  }) {\r\n    super({\r\n      inTypes: { dir: \"vec3\", scale: \"float\", scales: \"vec3\", rotate: \"vec4\" },\r\n      outTypes: { dir: \"vec3\" },\r\n      inputs: { dir, scale, scales, rotate },\r\n      statements: ({ inputs, outputs }) => {\r\n        const { dir } = outputs;\r\n        if (!dir) {\r\n          return [];\r\n        }\r\n        const { scale, scales, rotate } = inputs;\r\n        return [\r\n          `${dir} = ${inputs.dir ?? \"vec3(0.0, 0.0, 0.0)\"};`,\r\n          !scale ? null : `${dir} *= ${scale};`,\r\n          !scales ? null : `${dir} *= ${scales};`,\r\n          !rotate ? null : `${dir} = quatVec(${rotate}, ${dir});`,\r\n        ].filter(Boolean) as string[];\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport class TransformQuaternion extends Dyno<\r\n  { quaternion: \"vec4\"; rotate: \"vec4\" },\r\n  { quaternion: \"vec4\" }\r\n> {\r\n  constructor({\r\n    quaternion,\r\n    rotate,\r\n  }: { quaternion?: DynoVal<\"vec4\">; rotate?: DynoVal<\"vec4\"> }) {\r\n    super({\r\n      inTypes: { quaternion: \"vec4\", rotate: \"vec4\" },\r\n      outTypes: { quaternion: \"vec4\" },\r\n      inputs: { quaternion, rotate },\r\n      statements: ({ inputs, outputs }) => {\r\n        const { quaternion } = outputs;\r\n        if (!quaternion) {\r\n          return [];\r\n        }\r\n        return [\r\n          `${quaternion} = ${inputs.quaternion ?? \"vec4(0.0, 0.0, 0.0, 1.0)\"};`,\r\n          !rotate\r\n            ? null\r\n            : `${quaternion} = quatQuat(${inputs.rotate}, ${quaternion});`,\r\n        ].filter(Boolean) as string[];\r\n      },\r\n    });\r\n  }\r\n}\r\n","// TODO:\r\n// if, switch, for, comment,\r\n// arrayIndex, arrayLength,\r\n\r\nexport const dynoIf = () => {\r\n  throw new Error(\"Not implemented\");\r\n};\r\nexport const dynoSwitch = () => {\r\n  throw new Error(\"Not implemented\");\r\n};\r\nexport const dynoFor = () => {\r\n  throw new Error(\"Not implemented\");\r\n};\r\nexport const comment = () => {\r\n  throw new Error(\"Not implemented\");\r\n};\r\nexport const arrayIndex = () => {\r\n  throw new Error(\"Not implemented\");\r\n};\r\nexport const arrayLength = () => {\r\n  throw new Error(\"Not implemented\");\r\n};\r\n","import { Dyno } from \"./base\";\r\nimport type {\r\n  AllSamplerTypes,\r\n  IsamplerTypes,\r\n  NormalSamplerTypes,\r\n  Sampler2DArrayTypes,\r\n  Sampler2DTypes,\r\n  Sampler3DTypes,\r\n  SamplerCubeTypes,\r\n  SamplerShadowTypes,\r\n  SamplerTypes,\r\n  UsamplerTypes,\r\n} from \"./types\";\r\nimport {\r\n  DynoOutput,\r\n  type DynoVal,\r\n  type DynoValue,\r\n  type HasDynoOut,\r\n  valType,\r\n} from \"./value\";\r\n\r\nexport const textureSize = <T extends AllSamplerTypes>(\r\n  texture: DynoVal<T>,\r\n  lod?: DynoVal<\"int\">,\r\n): DynoVal<TextureSizeType<T>> => new TextureSize<T>({ texture, lod });\r\nexport const texture = <T extends AllSamplerTypes>(\r\n  texture: DynoVal<T>,\r\n  coord: DynoVal<TextureCoordType<T>>,\r\n  bias?: DynoVal<\"float\">,\r\n): DynoVal<TextureReturnType<T>> => new Texture<T>({ texture, coord, bias });\r\nexport const texelFetch = <T extends NormalSamplerTypes>(\r\n  texture: DynoVal<T>,\r\n  coord: DynoVal<TextureSizeType<T>>,\r\n  lod?: DynoVal<\"int\">,\r\n): DynoVal<TextureReturnType<T>> => new TexelFetch<T>({ texture, coord, lod });\r\n\r\nexport class TextureSize<T extends AllSamplerTypes>\r\n  extends Dyno<{ texture: T; lod: \"int\" }, { size: TextureSizeType<T> }>\r\n  implements HasDynoOut<TextureSizeType<T>>\r\n{\r\n  constructor({ texture, lod }: { texture: DynoVal<T>; lod?: DynoVal<\"int\"> }) {\r\n    const textureType = valType(texture);\r\n    super({\r\n      inTypes: { texture: textureType, lod: \"int\" },\r\n      outTypes: { size: textureSizeType(textureType) },\r\n      inputs: { texture, lod },\r\n      statements: ({ inputs, outputs }) => [\r\n        `${outputs.size} = textureSize(${inputs.texture}, ${inputs.lod ?? \"0\"});`,\r\n      ],\r\n    });\r\n  }\r\n\r\n  dynoOut(): DynoValue<TextureSizeType<T>> {\r\n    return new DynoOutput(this, \"size\");\r\n  }\r\n}\r\n\r\nexport class Texture<T extends AllSamplerTypes>\r\n  extends Dyno<\r\n    { texture: T; coord: TextureCoordType<T>; bias: \"float\" },\r\n    { sample: TextureReturnType<T> }\r\n  >\r\n  implements HasDynoOut<TextureReturnType<T>>\r\n{\r\n  constructor({\r\n    texture,\r\n    coord,\r\n    bias,\r\n  }: {\r\n    texture: DynoVal<T>;\r\n    coord: DynoVal<TextureCoordType<T>>;\r\n    bias?: DynoVal<\"float\">;\r\n  }) {\r\n    const textureType = valType(texture);\r\n    super({\r\n      inTypes: {\r\n        texture: textureType,\r\n        coord: textureCoordType(textureType),\r\n        bias: \"float\",\r\n      },\r\n      outTypes: { sample: textureReturnType(textureType) },\r\n      inputs: { texture, coord, bias },\r\n      statements: ({ inputs, outputs }) => [\r\n        `${outputs.sample} = texture(${inputs.texture}, ${inputs.coord}${inputs.bias ? `, ${inputs.bias}` : \"\"});`,\r\n      ],\r\n    });\r\n  }\r\n\r\n  dynoOut(): DynoValue<TextureReturnType<T>> {\r\n    return new DynoOutput(this, \"sample\");\r\n  }\r\n}\r\n\r\nexport class TexelFetch<T extends NormalSamplerTypes>\r\n  extends Dyno<\r\n    { texture: T; coord: TextureSizeType<T>; lod: \"int\" },\r\n    { texel: TextureReturnType<T> }\r\n  >\r\n  implements HasDynoOut<TextureReturnType<T>>\r\n{\r\n  constructor({\r\n    texture,\r\n    coord,\r\n    lod,\r\n  }: {\r\n    texture: DynoVal<T>;\r\n    coord: DynoVal<TextureSizeType<T>>;\r\n    lod?: DynoVal<\"int\">;\r\n  }) {\r\n    const textureType = valType(texture);\r\n    super({\r\n      inTypes: {\r\n        texture: textureType,\r\n        coord: textureSizeType(textureType),\r\n        lod: \"int\",\r\n      },\r\n      outTypes: { texel: textureReturnType(textureType) },\r\n      inputs: { texture, coord, lod },\r\n      statements: ({ inputs, outputs }) => [\r\n        `${outputs.texel} = texelFetch(${inputs.texture}, ${inputs.coord}, ${inputs.lod ?? \"0\"});`,\r\n      ],\r\n    });\r\n  }\r\n\r\n  dynoOut(): DynoValue<TextureReturnType<T>> {\r\n    return new DynoOutput(this, \"texel\");\r\n  }\r\n}\r\n\r\ntype TextureSizeType<T extends AllSamplerTypes> = T extends\r\n  | Sampler2DTypes\r\n  | SamplerCubeTypes\r\n  ? \"ivec2\"\r\n  : T extends Sampler3DTypes | Sampler2DArrayTypes\r\n    ? \"ivec3\"\r\n    : never;\r\n\r\nfunction textureSizeType<T extends AllSamplerTypes>(\r\n  textureType: T,\r\n): TextureSizeType<T> {\r\n  switch (textureType) {\r\n    case \"sampler2D\":\r\n    case \"usampler2D\":\r\n    case \"isampler2D\":\r\n    case \"samplerCube\":\r\n    case \"usamplerCube\":\r\n    case \"isamplerCube\":\r\n    case \"sampler2DShadow\":\r\n    case \"samplerCubeShadow\":\r\n      return \"ivec2\" as TextureSizeType<T>;\r\n    case \"sampler3D\":\r\n    case \"usampler3D\":\r\n    case \"isampler3D\":\r\n    case \"sampler2DArray\":\r\n    case \"usampler2DArray\":\r\n    case \"isampler2DArray\":\r\n    case \"sampler2DArrayShadow\":\r\n      return \"ivec3\" as TextureSizeType<T>;\r\n    default:\r\n      throw new Error(`Invalid texture type: ${textureType}`);\r\n  }\r\n}\r\n\r\ntype TextureCoordType<T extends AllSamplerTypes> = T extends Sampler2DTypes\r\n  ? \"vec2\"\r\n  : T extends\r\n        | Sampler3DTypes\r\n        | Sampler2DArrayTypes\r\n        | SamplerCubeTypes\r\n        | Sampler2DArrayTypes\r\n    ? \"vec3\"\r\n    : T extends \"samperCubeShadow\" | \"sampler2DArrayShadow\"\r\n      ? \"vec4\"\r\n      : never;\r\n\r\nfunction textureCoordType<T extends AllSamplerTypes>(\r\n  textureType: T,\r\n): TextureCoordType<T> {\r\n  switch (textureType) {\r\n    case \"sampler2D\":\r\n    case \"usampler2D\":\r\n    case \"isampler2D\":\r\n      return \"vec2\" as TextureCoordType<T>;\r\n    case \"sampler3D\":\r\n    case \"usampler3D\":\r\n    case \"isampler3D\":\r\n    case \"samplerCube\":\r\n    case \"usamplerCube\":\r\n    case \"isamplerCube\":\r\n    case \"sampler2DArray\":\r\n    case \"usampler2DArray\":\r\n    case \"isampler2DArray\":\r\n    case \"sampler2DShadow\":\r\n      return \"vec3\" as TextureCoordType<T>;\r\n    case \"samplerCubeShadow\":\r\n    case \"sampler2DArrayShadow\":\r\n      return \"vec4\" as TextureCoordType<T>;\r\n    default:\r\n      throw new Error(`Invalid texture type: ${textureType}`);\r\n  }\r\n}\r\n\r\ntype TextureReturnType<T extends AllSamplerTypes> = T extends SamplerTypes\r\n  ? \"vec4\"\r\n  : T extends UsamplerTypes\r\n    ? \"uvec4\"\r\n    : T extends IsamplerTypes\r\n      ? \"ivec4\"\r\n      : T extends SamplerShadowTypes\r\n        ? \"float\"\r\n        : never;\r\n\r\nfunction textureReturnType<T extends AllSamplerTypes>(\r\n  textureType: T,\r\n): TextureReturnType<T> {\r\n  switch (textureType) {\r\n    case \"sampler2D\":\r\n    case \"sampler2DArray\":\r\n    case \"sampler3D\":\r\n    case \"samplerCube\":\r\n    case \"sampler2DShadow\":\r\n      return \"vec4\" as TextureReturnType<T>;\r\n    case \"usampler2D\":\r\n    case \"usampler2DArray\":\r\n    case \"usampler3D\":\r\n    case \"usamplerCube\":\r\n      return \"uvec4\" as TextureReturnType<T>;\r\n    case \"isampler2D\":\r\n    case \"isampler2DArray\":\r\n    case \"isampler3D\":\r\n    case \"isamplerCube\":\r\n      return \"ivec4\" as TextureReturnType<T>;\r\n    case \"samplerCubeShadow\":\r\n    case \"sampler2DArrayShadow\":\r\n      return \"float\" as TextureReturnType<T>;\r\n    default:\r\n      throw new Error(`Invalid texture type: ${textureType}`);\r\n  }\r\n}\r\n","import { BinaryOp, UnaryOp } from \"./base\";\r\nimport type { FloatTypes } from \"./types\";\r\nimport type { DynoVal } from \"./value\";\r\n\r\nexport const radians = <A extends FloatTypes>(\r\n  degrees: DynoVal<A>,\r\n): DynoVal<A> => new Radians({ degrees });\r\nexport const degrees = <A extends FloatTypes>(\r\n  radians: DynoVal<A>,\r\n): DynoVal<A> => new Degrees({ radians });\r\n\r\nexport const sin = <A extends FloatTypes>(radians: DynoVal<A>): DynoVal<A> =>\r\n  new Sin({ radians });\r\nexport const cos = <A extends FloatTypes>(radians: DynoVal<A>): DynoVal<A> =>\r\n  new Cos({ radians });\r\nexport const tan = <A extends FloatTypes>(radians: DynoVal<A>): DynoVal<A> =>\r\n  new Tan({ radians });\r\n\r\nexport const asin = <A extends FloatTypes>(sin: DynoVal<A>): DynoVal<A> =>\r\n  new Asin({ sin });\r\nexport const acos = <A extends FloatTypes>(cos: DynoVal<A>): DynoVal<A> =>\r\n  new Acos({ cos });\r\nexport const atan = <A extends FloatTypes>(tan: DynoVal<A>): DynoVal<A> =>\r\n  new Atan({ tan });\r\nexport const atan2 = <A extends FloatTypes>(\r\n  y: DynoVal<A>,\r\n  x: DynoVal<A>,\r\n): DynoVal<A> => new Atan2({ y, x });\r\n\r\nexport const sinh = <A extends FloatTypes>(x: DynoVal<A>): DynoVal<A> =>\r\n  new Sinh({ x });\r\nexport const cosh = <A extends FloatTypes>(x: DynoVal<A>): DynoVal<A> =>\r\n  new Cosh({ x });\r\nexport const tanh = <A extends FloatTypes>(x: DynoVal<A>): DynoVal<A> =>\r\n  new Tanh({ x });\r\n\r\nexport const asinh = <A extends FloatTypes>(x: DynoVal<A>): DynoVal<A> =>\r\n  new Asinh({ x });\r\nexport const acosh = <A extends FloatTypes>(x: DynoVal<A>): DynoVal<A> =>\r\n  new Acosh({ x });\r\nexport const atanh = <A extends FloatTypes>(x: DynoVal<A>): DynoVal<A> =>\r\n  new Atanh({ x });\r\n\r\nexport class Radians<A extends FloatTypes> extends UnaryOp<A, A, \"radians\"> {\r\n  constructor({ degrees }: { degrees: DynoVal<A> }) {\r\n    super({ a: degrees, outTypeFunc: (aType) => aType, outKey: \"radians\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.radians} = radians(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Degrees<A extends FloatTypes> extends UnaryOp<A, A, \"degrees\"> {\r\n  constructor({ radians }: { radians: DynoVal<A> }) {\r\n    super({ a: radians, outTypeFunc: (aType) => aType, outKey: \"degrees\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.degrees} = degrees(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Sin<A extends FloatTypes> extends UnaryOp<A, A, \"sin\"> {\r\n  constructor({ radians }: { radians: DynoVal<A> }) {\r\n    super({ a: radians, outTypeFunc: (aType) => aType, outKey: \"sin\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.sin} = sin(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Cos<A extends FloatTypes> extends UnaryOp<A, A, \"cos\"> {\r\n  constructor({ radians }: { radians: DynoVal<A> }) {\r\n    super({ a: radians, outTypeFunc: (aType) => aType, outKey: \"cos\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.cos} = cos(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Tan<A extends FloatTypes> extends UnaryOp<A, A, \"tan\"> {\r\n  constructor({ radians }: { radians: DynoVal<A> }) {\r\n    super({ a: radians, outTypeFunc: (aType) => aType, outKey: \"tan\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.tan} = tan(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Asin<A extends FloatTypes> extends UnaryOp<A, A, \"asin\"> {\r\n  constructor({ sin }: { sin: DynoVal<A> }) {\r\n    super({ a: sin, outTypeFunc: (aType) => aType, outKey: \"asin\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.asin} = asin(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Acos<A extends FloatTypes> extends UnaryOp<A, A, \"acos\"> {\r\n  constructor({ cos }: { cos: DynoVal<A> }) {\r\n    super({ a: cos, outTypeFunc: (aType) => aType, outKey: \"acos\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.acos} = acos(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Atan<A extends FloatTypes> extends UnaryOp<A, A, \"atan\"> {\r\n  constructor({ tan }: { tan: DynoVal<A> }) {\r\n    super({ a: tan, outTypeFunc: (aType) => aType, outKey: \"atan\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.atan} = atan(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Atan2<A extends FloatTypes> extends BinaryOp<A, A, A, \"atan2\"> {\r\n  constructor({ y, x }: { y: DynoVal<A>; x: DynoVal<A> }) {\r\n    super({\r\n      a: y,\r\n      b: x,\r\n      outTypeFunc: (aType, bType) => aType,\r\n      outKey: \"atan2\",\r\n    });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.atan2} = atan2(${inputs.a}, ${inputs.b});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Sinh<A extends FloatTypes> extends UnaryOp<A, A, \"sinh\"> {\r\n  constructor({ x }: { x: DynoVal<A> }) {\r\n    super({ a: x, outTypeFunc: (aType) => aType, outKey: \"sinh\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.sinh} = sinh(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Cosh<A extends FloatTypes> extends UnaryOp<A, A, \"cosh\"> {\r\n  constructor({ x }: { x: DynoVal<A> }) {\r\n    super({ a: x, outTypeFunc: (aType) => aType, outKey: \"cosh\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.cosh} = cosh(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Tanh<A extends FloatTypes> extends UnaryOp<A, A, \"tanh\"> {\r\n  constructor({ x }: { x: DynoVal<A> }) {\r\n    super({ a: x, outTypeFunc: (aType) => aType, outKey: \"tanh\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.tanh} = tanh(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Asinh<A extends FloatTypes> extends UnaryOp<A, A, \"asinh\"> {\r\n  constructor({ x }: { x: DynoVal<A> }) {\r\n    super({ a: x, outTypeFunc: (aType) => aType, outKey: \"asinh\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.asinh} = asinh(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Acosh<A extends FloatTypes> extends UnaryOp<A, A, \"acosh\"> {\r\n  constructor({ x }: { x: DynoVal<A> }) {\r\n    super({ a: x, outTypeFunc: (aType) => aType, outKey: \"acosh\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.acosh} = acosh(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n\r\nexport class Atanh<A extends FloatTypes> extends UnaryOp<A, A, \"atanh\"> {\r\n  constructor({ x }: { x: DynoVal<A> }) {\r\n    super({ a: x, outTypeFunc: (aType) => aType, outKey: \"atanh\" });\r\n    this.statements = ({ inputs, outputs }) => [\r\n      `${outputs.atanh} = atanh(${inputs.a});`,\r\n    ];\r\n  }\r\n}\r\n","precision highp float;\r\nprecision highp int;\r\nprecision highp sampler2D;\r\nprecision highp usampler2D;\r\nprecision highp isampler2D;\r\nprecision highp sampler2DArray;\r\nprecision highp usampler2DArray;\r\nprecision highp isampler2DArray;\r\nprecision highp sampler3D;\r\nprecision highp usampler3D;\r\nprecision highp isampler3D;\r\n\r\n#include <splatDefines>\r\n\r\nuniform uint targetLayer;\r\nuniform int targetBase;\r\nuniform int targetCount;\r\n\r\nout vec4 target;\r\n\r\n{{ GLOBALS }}\r\n\r\nvoid computeReadback(int index) {\r\n    {{ STATEMENTS }}\r\n}\r\n\r\nvoid main() {\r\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\r\n    int index = targetIndex - targetBase;\r\n\r\n    if ((index >= 0) && (index < targetCount)) {\r\n        computeReadback(index);\r\n    } else {\r\n        target = vec4(0.0, 0.0, 0.0, 0.0);\r\n    }\r\n}\r\n","import * as THREE from \"three\";\r\nimport { FullScreenQuad } from \"three/addons/postprocessing/Pass.js\";\r\n\r\nimport { SPLAT_TEX_HEIGHT, SPLAT_TEX_WIDTH } from \"./defines\";\r\nimport { type Dyno, OutputRgba8, dynoBlock } from \"./dyno\";\r\nimport { DynoProgram, DynoProgramTemplate } from \"./dyno/program\";\r\nimport computeVec4Template from \"./shaders/computeVec4.glsl\";\r\nimport { getTextureSize } from \"./utils\";\r\n\r\n// Readback can be used to run a Dyno program that maps an index to a 32-bit\r\n// RGBA8 value, which is the only allowed, portable readback format for WebGL2.\r\n// Using data packing and conversion you can read back any 32-bit value, which\r\n// Spark uses to read back 2 float16 Gsplat distance values per index.\r\n\r\nexport type Rgba8Readback = Dyno<{ index: \"int\" }, { rgba8: \"vec4\" }>;\r\n\r\n// Readback can be performed with various typed buffers, making it convenient\r\n// to encode readback data in a variety of formats.\r\n\r\nexport type ReadbackBuffer =\r\n  | ArrayBuffer\r\n  | Uint8Array\r\n  | Int8Array\r\n  | Uint16Array\r\n  | Int16Array\r\n  | Uint32Array\r\n  | Int32Array\r\n  | Float32Array;\r\n\r\nexport class Readback {\r\n  renderer?: THREE.WebGLRenderer;\r\n  target?: THREE.WebGLArrayRenderTarget;\r\n  capacity: number;\r\n  count: number;\r\n\r\n  constructor({ renderer }: { renderer?: THREE.WebGLRenderer } = {}) {\r\n    this.renderer = renderer;\r\n    this.capacity = 0;\r\n    this.count = 0;\r\n  }\r\n\r\n  dispose() {\r\n    if (this.target) {\r\n      this.target.dispose();\r\n      this.target = undefined;\r\n    }\r\n  }\r\n\r\n  // Ensure we have a buffer large enough for the readback of count indices.\r\n  // Pass in previous bufer of the desired type.\r\n  ensureBuffer<B extends ReadbackBuffer>(count: number, buffer: B): B {\r\n    // Readback is performed in a 2D array of pixels, so round up with SPLAT_TEX_WIDTH\r\n    const roundedCount =\r\n      Math.ceil(Math.max(1, count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\r\n    const bytes = roundedCount * 4;\r\n    if (buffer.byteLength >= bytes) {\r\n      return buffer;\r\n    }\r\n\r\n    // Need a larger buffer, create a new one of the same type\r\n    const newBuffer = new ArrayBuffer(bytes);\r\n    if (buffer instanceof ArrayBuffer) {\r\n      return newBuffer as B;\r\n    }\r\n\r\n    const ctor = buffer.constructor as { new (arrayBuffer: ArrayBuffer): B };\r\n    return new ctor(newBuffer) as B;\r\n  }\r\n\r\n  // Ensure our render target is large enough for the readback of capacity indices.\r\n  ensureCapacity(capacity: number) {\r\n    const { width, height, depth, maxSplats } = getTextureSize(capacity);\r\n    if (!this.target || maxSplats > this.capacity) {\r\n      this.dispose();\r\n      this.capacity = maxSplats;\r\n\r\n      // The only portable readback format for WebGL2 is RGBA8\r\n      this.target = new THREE.WebGLArrayRenderTarget(width, height, depth, {\r\n        depthBuffer: false,\r\n        stencilBuffer: false,\r\n        generateMipmaps: false,\r\n        magFilter: THREE.NearestFilter,\r\n        minFilter: THREE.NearestFilter,\r\n      });\r\n      this.target.texture.format = THREE.RGBAFormat;\r\n      this.target.texture.type = THREE.UnsignedByteType;\r\n      this.target.texture.internalFormat = \"RGBA8\";\r\n      this.target.scissorTest = true;\r\n    }\r\n  }\r\n\r\n  // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,\r\n  // generating it if necessary and caching the result.\r\n  prepareProgramMaterial(reader: Rgba8Readback): {\r\n    program: DynoProgram;\r\n    material: THREE.RawShaderMaterial;\r\n  } {\r\n    let program = Readback.readbackProgram.get(reader);\r\n    if (!program) {\r\n      const graph = dynoBlock(\r\n        { index: \"int\" },\r\n        { rgba8: \"vec4\" },\r\n        ({ index }) => {\r\n          reader.inputs.index = index;\r\n          const rgba8 = new OutputRgba8({ rgba8: reader.outputs.rgba8 });\r\n          return { rgba8 };\r\n        },\r\n      );\r\n      if (!Readback.programTemplate) {\r\n        Readback.programTemplate = new DynoProgramTemplate(computeVec4Template);\r\n      }\r\n      // Create a program from the template and graph\r\n      program = new DynoProgram({\r\n        graph,\r\n        inputs: { index: \"index\" },\r\n        outputs: { rgba8: \"target\" },\r\n        template: Readback.programTemplate,\r\n      });\r\n      Object.assign(program.uniforms, {\r\n        targetLayer: { value: 0 },\r\n        targetBase: { value: 0 },\r\n        targetCount: { value: 0 },\r\n      });\r\n      Readback.readbackProgram.set(reader, program);\r\n    }\r\n\r\n    const material = program.prepareMaterial();\r\n    Readback.fullScreenQuad.material = material;\r\n    return { program, material };\r\n  }\r\n\r\n  private saveRenderState(renderer: THREE.WebGLRenderer) {\r\n    return {\r\n      xrEnabled: renderer.xr.enabled,\r\n      autoClear: renderer.autoClear,\r\n    };\r\n  }\r\n\r\n  private resetRenderState(\r\n    renderer: THREE.WebGLRenderer,\r\n    state: {\r\n      xrEnabled: boolean;\r\n      autoClear: boolean;\r\n    },\r\n  ) {\r\n    renderer.setRenderTarget(null);\r\n    renderer.xr.enabled = state.xrEnabled;\r\n    renderer.autoClear = state.autoClear;\r\n  }\r\n\r\n  private process({\r\n    count,\r\n    material,\r\n  }: { count: number; material: THREE.RawShaderMaterial }) {\r\n    const renderer = this.renderer;\r\n    if (!renderer) {\r\n      throw new Error(\"No renderer\");\r\n    }\r\n    if (!this.target) {\r\n      throw new Error(\"No target\");\r\n    }\r\n\r\n    // Run the program in \"layer\" chunks, in horizontal row ranges,\r\n    // that cover the total count of indices.\r\n    const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\r\n    material.uniforms.targetBase.value = 0;\r\n    material.uniforms.targetCount.value = count;\r\n    let baseIndex = 0;\r\n\r\n    // Keep generating layers until completed count items\r\n    while (baseIndex < count) {\r\n      const layer = Math.floor(baseIndex / layerSize);\r\n      const layerBase = layer * layerSize;\r\n      const layerYEnd = Math.min(\r\n        SPLAT_TEX_HEIGHT,\r\n        Math.ceil((count - layerBase) / SPLAT_TEX_WIDTH),\r\n      );\r\n      material.uniforms.targetLayer.value = layer;\r\n\r\n      // Render the desired portion of the layer\r\n      this.target.scissor.set(0, 0, SPLAT_TEX_WIDTH, layerYEnd);\r\n      renderer.setRenderTarget(this.target, layer);\r\n      renderer.xr.enabled = false;\r\n      renderer.autoClear = false;\r\n      Readback.fullScreenQuad.render(renderer);\r\n\r\n      baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\r\n    }\r\n\r\n    this.count = count;\r\n  }\r\n\r\n  private async read<B extends ReadbackBuffer>({\r\n    readback,\r\n  }: { readback: B }): Promise<B> {\r\n    const renderer = this.renderer;\r\n    if (!renderer) {\r\n      throw new Error(\"No renderer\");\r\n    }\r\n    if (!this.target) {\r\n      throw new Error(\"No target\");\r\n    }\r\n\r\n    const roundedCount =\r\n      Math.ceil(this.count / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\r\n    if (readback.byteLength < roundedCount * 4) {\r\n      throw new Error(\r\n        `Readback buffer too small: ${readback.byteLength} < ${roundedCount * 4}`,\r\n      );\r\n    }\r\n    const readbackUint8 = new Uint8Array(\r\n      readback instanceof ArrayBuffer ? readback : readback.buffer,\r\n    );\r\n\r\n    // We can only read back one 2D array layer of pixels at a time,\r\n    // so loop through them, initiate the readback, and collect the\r\n    // completion promises.\r\n\r\n    const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\r\n    let baseIndex = 0;\r\n    const promises = [];\r\n\r\n    while (baseIndex < this.count) {\r\n      const layer = Math.floor(baseIndex / layerSize);\r\n      const layerBase = layer * layerSize;\r\n      const layerYEnd = Math.min(\r\n        SPLAT_TEX_HEIGHT,\r\n        Math.ceil((this.count - layerBase) / SPLAT_TEX_WIDTH),\r\n      );\r\n\r\n      renderer.setRenderTarget(this.target, layer);\r\n\r\n      // Compute the subarray that this layer of readback corresponds to\r\n      const readbackSize = SPLAT_TEX_WIDTH * layerYEnd * 4;\r\n      const subReadback = readbackUint8.subarray(\r\n        layerBase * 4,\r\n        layerBase * 4 + readbackSize,\r\n      );\r\n      const promise = renderer?.readRenderTargetPixelsAsync(\r\n        this.target,\r\n        0,\r\n        0,\r\n        SPLAT_TEX_WIDTH,\r\n        layerYEnd,\r\n        subReadback,\r\n      );\r\n      promises.push(promise);\r\n\r\n      baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\r\n    }\r\n    return Promise.all(promises).then(() => readback);\r\n  }\r\n\r\n  // Perform render operation to run the Rgba8Readback program\r\n  // but don't perform the readback yet.\r\n  render({\r\n    reader,\r\n    count,\r\n    renderer,\r\n  }: { reader: Rgba8Readback; count: number; renderer?: THREE.WebGLRenderer }) {\r\n    this.renderer = renderer || this.renderer;\r\n    if (!this.renderer) {\r\n      throw new Error(\"No renderer\");\r\n    }\r\n\r\n    this.ensureCapacity(count);\r\n\r\n    const { program, material } = this.prepareProgramMaterial(reader);\r\n    program.update();\r\n\r\n    const renderState = this.saveRenderState(this.renderer);\r\n    this.process({ count, material });\r\n    this.resetRenderState(this.renderer, renderState);\r\n  }\r\n\r\n  // Perform a readback of the render target, returning a buffer of the\r\n  // given type.\r\n  async readback<B extends ReadbackBuffer>({\r\n    readback,\r\n  }: { readback: B }): Promise<B> {\r\n    if (!this.renderer) {\r\n      throw new Error(\"No renderer\");\r\n    }\r\n    const renderState = this.saveRenderState(this.renderer);\r\n    const promise = this.read({ readback });\r\n    this.resetRenderState(this.renderer, renderState);\r\n    return promise;\r\n  }\r\n\r\n  // Perform a render and readback operation for the given Rgba8Readback,\r\n  // and readback buffer (call ensureBuffer first).\r\n  async renderReadback<B extends ReadbackBuffer>({\r\n    reader,\r\n    count,\r\n    renderer,\r\n    readback,\r\n  }: {\r\n    reader: Rgba8Readback;\r\n    count: number;\r\n    renderer?: THREE.WebGLRenderer;\r\n    readback: B;\r\n  }): Promise<B> {\r\n    this.renderer = renderer || this.renderer;\r\n    if (!this.renderer) {\r\n      throw new Error(\"No renderer\");\r\n    }\r\n\r\n    this.ensureCapacity(count);\r\n\r\n    const { program, material } = this.prepareProgramMaterial(reader);\r\n    program.update();\r\n\r\n    const renderState = this.saveRenderState(this.renderer);\r\n\r\n    // Generate output\r\n    this.process({ count, material });\r\n\r\n    // Initiate readback\r\n    const promise = this.read({ readback });\r\n\r\n    this.resetRenderState(this.renderer, renderState);\r\n    return promise;\r\n  }\r\n\r\n  getTexture(): THREE.DataArrayTexture | undefined {\r\n    return this.target?.texture;\r\n  }\r\n\r\n  static programTemplate: DynoProgramTemplate | null = null;\r\n\r\n  // Cache for Rgba8Readback programs\r\n  static readbackProgram = new Map<Rgba8Readback, DynoProgram>();\r\n\r\n  // Static full-screen quad for pseudo-compute shader rendering\r\n  static fullScreenQuad = new FullScreenQuad(\r\n    new THREE.RawShaderMaterial({ visible: false }),\r\n  );\r\n}\r\n","import * as THREE from \"three\";\r\n\r\nimport { DynoPackedSplats, type PackedSplats } from \"./PackedSplats\";\r\nimport { Readback, type Rgba8Readback } from \"./Readback\";\r\nimport { SPLAT_TEX_WIDTH } from \"./defines\";\r\nimport {\r\n  Dyno,\r\n  type DynoBlock,\r\n  DynoInt,\r\n  DynoUniform,\r\n  type DynoVal,\r\n  add,\r\n  dynoBlock,\r\n  readPackedSplatRange,\r\n  splitGsplat,\r\n  unindent,\r\n  unindentLines,\r\n} from \"./dyno\";\r\nimport { getTextureSize } from \"./utils\";\r\n\r\n// An RgbaArray is a collection of ordered RGBA8 values, which can be used as a dyno\r\n// data source, for example for recoloring Gsplats via SplatMesh.splatRgba.\r\n// It can be instantiated from a Uint8Array of RGBA8 values, or it can be\r\n// generated using a Rgba8Readback dyno program.\r\n\r\nexport type RgbaArrayOptions = {\r\n  // Reserve space for at least this many RGBA values.\r\n  capacity?: number;\r\n  // Use the provided array of RGBA8 values as the source.\r\n  array?: Uint8Array;\r\n  // The number of actual RGBA8 values in the array.\r\n  count?: number;\r\n};\r\n\r\nexport class RgbaArray {\r\n  capacity = 0;\r\n  count = 0;\r\n  array: Uint8Array | null = null;\r\n\r\n  readback: Readback | null = null;\r\n  source: THREE.DataArrayTexture | null = null;\r\n  // Set to true if source array is updated to have it upload to GPU\r\n  needsUpdate = true;\r\n\r\n  // Use this as a TRgbaArray in a dyno graph\r\n  dyno: DynoUniform<typeof TRgbaArray, \"rgbaArray\">;\r\n\r\n  constructor(options: RgbaArrayOptions = {}) {\r\n    this.dyno = new DynoUniform({\r\n      key: \"rgbaArray\",\r\n      type: TRgbaArray,\r\n      globals: () => [defineRgbaArray],\r\n      value: {\r\n        texture: RgbaArray.getEmpty(),\r\n        count: 0,\r\n      },\r\n      update: (value) => {\r\n        value.texture =\r\n          this.readback?.getTexture() ?? this.source ?? RgbaArray.getEmpty();\r\n        value.count = this.count;\r\n        return value;\r\n      },\r\n    });\r\n\r\n    if (options.array) {\r\n      // Initialize with given array\r\n      this.array = options.array;\r\n      this.capacity = Math.floor(this.array.length / 4);\r\n      this.capacity =\r\n        Math.floor(this.capacity / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\r\n      this.count = Math.min(\r\n        this.capacity,\r\n        options.count ?? Number.POSITIVE_INFINITY,\r\n      );\r\n    } else {\r\n      this.capacity = options.capacity ?? 0;\r\n      this.count = 0;\r\n    }\r\n  }\r\n\r\n  // Free up resources\r\n  dispose() {\r\n    if (this.readback) {\r\n      this.readback.dispose();\r\n      this.readback = null;\r\n    }\r\n    if (this.source) {\r\n      this.source.dispose();\r\n      this.source = null;\r\n    }\r\n  }\r\n\r\n  // Ensure that our array is large enough to hold capacity RGBA8 values.\r\n  ensureCapacity(capacity: number): Uint8Array {\r\n    if (!this.array || capacity > (this.array?.length ?? 0) / 4) {\r\n      this.capacity = getTextureSize(capacity).maxSplats;\r\n      const newArray = new Uint8Array(this.capacity * 4);\r\n      if (this.array) {\r\n        // Copy over existing data\r\n        newArray.set(this.array);\r\n      }\r\n      this.array = newArray;\r\n    }\r\n    return this.array;\r\n  }\r\n\r\n  // Get the THREE.DataArrayTexture from either the readback or the source.\r\n  getTexture(): THREE.DataArrayTexture {\r\n    let texture = this.readback?.getTexture();\r\n    if (this.source || this.array) {\r\n      texture = this.maybeUpdateSource();\r\n    }\r\n    return texture ?? RgbaArray.getEmpty();\r\n  }\r\n\r\n  // Create or get a THREE.DataArrayTexture from the data array.\r\n  private maybeUpdateSource(): THREE.DataArrayTexture {\r\n    if (!this.array) {\r\n      throw new Error(\"No array\");\r\n    }\r\n\r\n    if (this.needsUpdate || !this.source) {\r\n      this.needsUpdate = false;\r\n\r\n      if (this.source) {\r\n        const { width, height, depth } = this.source.image;\r\n        if (this.capacity !== width * height * depth) {\r\n          this.source.dispose();\r\n          this.source = null;\r\n        }\r\n      }\r\n      if (!this.source) {\r\n        const { width, height, depth } = getTextureSize(this.capacity);\r\n        this.source = new THREE.DataArrayTexture(\r\n          this.array,\r\n          width,\r\n          height,\r\n          depth,\r\n        );\r\n        this.source.format = THREE.RGBAFormat;\r\n        this.source.type = THREE.UnsignedByteType;\r\n        this.source.internalFormat = \"RGBA8\";\r\n        this.source.needsUpdate = true;\r\n      } else if (this.array.buffer !== this.source.image.data.buffer) {\r\n        this.source.image.data = new Uint8Array(this.array.buffer);\r\n      }\r\n      this.source.needsUpdate = true;\r\n    }\r\n    return this.source;\r\n  }\r\n\r\n  // Generate the RGBA8 values from a Rgba8Readback dyno program.\r\n  render({\r\n    reader,\r\n    count,\r\n    renderer,\r\n  }: { reader: Rgba8Readback; count: number; renderer: THREE.WebGLRenderer }) {\r\n    if (!this.readback) {\r\n      this.readback = new Readback({ renderer });\r\n    }\r\n    this.readback.render({ reader, count, renderer });\r\n    this.capacity = this.readback.capacity;\r\n    this.count = this.readback.count;\r\n  }\r\n\r\n  // Extract the RGBA8 values from a PackedSplats collection.\r\n  fromPackedSplats({\r\n    packedSplats,\r\n    base,\r\n    count,\r\n    renderer,\r\n  }: {\r\n    packedSplats: PackedSplats;\r\n    base: number;\r\n    count: number;\r\n    renderer: THREE.WebGLRenderer;\r\n  }) {\r\n    const { dynoSplats, dynoBase, dynoCount, reader } = RgbaArray.makeDynos();\r\n    dynoSplats.packedSplats = packedSplats;\r\n    dynoBase.value = base;\r\n    dynoCount.value = count;\r\n    this.render({ reader, count, renderer });\r\n    return this;\r\n  }\r\n\r\n  // Read back the RGBA8 values from the readback buffer.\r\n  async read(): Promise<Uint8Array> {\r\n    if (!this.readback) {\r\n      throw new Error(\"No readback\");\r\n    }\r\n    if (!this.array || this.array.length < this.count * 4) {\r\n      this.array = new Uint8Array(this.capacity * 4);\r\n    }\r\n    const result = await this.readback.readback({ readback: this.array });\r\n    return result.subarray(0, this.count * 4);\r\n  }\r\n\r\n  private static emptySource: THREE.DataArrayTexture | null = null;\r\n\r\n  // Can be used where you need an uninitialized THREE.DataArrayTexture like\r\n  // a uniform you will update with the result of this.getTexture() later.\r\n  static getEmpty(): THREE.DataArrayTexture {\r\n    if (!RgbaArray.emptySource) {\r\n      const emptyArray = new Uint8Array(1 * 4);\r\n      RgbaArray.emptySource = new THREE.DataArrayTexture(emptyArray, 1, 1, 1);\r\n      RgbaArray.emptySource.format = THREE.RGBAFormat;\r\n      RgbaArray.emptySource.type = THREE.UnsignedByteType;\r\n      RgbaArray.emptySource.internalFormat = \"RGBA8\";\r\n      RgbaArray.emptySource.needsUpdate = true;\r\n    }\r\n    return RgbaArray.emptySource;\r\n  }\r\n\r\n  private static dynos: {\r\n    dynoSplats: DynoPackedSplats;\r\n    dynoBase: DynoInt<string>;\r\n    dynoCount: DynoInt<string>;\r\n    reader: DynoBlock<{ index: \"int\" }, { rgba8: \"vec4\" }>;\r\n  } | null = null;\r\n\r\n  // Create a dyno program that can extract RGBA8 values from a PackedSplats\r\n  private static makeDynos() {\r\n    if (!RgbaArray.dynos) {\r\n      const dynoSplats = new DynoPackedSplats();\r\n      const dynoBase = new DynoInt({ value: 0 });\r\n      const dynoCount = new DynoInt({ value: 0 });\r\n      const reader = dynoBlock(\r\n        { index: \"int\" },\r\n        { rgba8: \"vec4\" },\r\n        ({ index }) => {\r\n          if (!index) {\r\n            throw new Error(\"index is undefined\");\r\n          }\r\n          index = add(index, dynoBase);\r\n          const gsplat = readPackedSplatRange(\r\n            dynoSplats,\r\n            index,\r\n            dynoBase,\r\n            dynoCount,\r\n          );\r\n          return { rgba8: splitGsplat(gsplat).outputs.rgba };\r\n        },\r\n      );\r\n      RgbaArray.dynos = { dynoSplats, dynoBase, dynoCount, reader };\r\n    }\r\n    return RgbaArray.dynos;\r\n  }\r\n}\r\n\r\n// Dyno types and definitions\r\n\r\nexport const TRgbaArray = { type: \"RgbaArray\" } as { type: \"RgbaArray\" };\r\n\r\nexport const defineRgbaArray = unindent(`\r\n  struct RgbaArray {\r\n    sampler2DArray texture;\r\n    int count;\r\n  };\r\n`);\r\n\r\nexport function readRgbaArray(\r\n  rgba: DynoVal<typeof TRgbaArray>,\r\n  index: DynoVal<\"int\">,\r\n): DynoVal<\"vec4\"> {\r\n  const dyno = new Dyno<\r\n    { rgba: typeof TRgbaArray; index: \"int\" },\r\n    { rgba: \"vec4\" }\r\n  >({\r\n    inTypes: { rgba: TRgbaArray, index: \"int\" },\r\n    outTypes: { rgba: \"vec4\" },\r\n    inputs: { rgba, index },\r\n    globals: () => [defineRgbaArray],\r\n    statements: ({ inputs, outputs }) =>\r\n      unindentLines(`\r\n        if ((index >= 0) && (index < ${inputs.rgba}.count)) {\r\n          ${outputs.rgba} = texelFetch(${inputs.rgba}.texture, splatTexCoord(index), 0);\r\n        } else {\r\n          ${outputs.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\r\n        }\r\n      `),\r\n  });\r\n  return dyno.outputs.rgba;\r\n}\r\n","import * as THREE from \"three\";\r\n\r\nimport {\r\n  Dyno,\r\n  DynoInt,\r\n  DynoUniform,\r\n  type DynoVal,\r\n  Gsplat,\r\n  unindent,\r\n  unindentLines,\r\n} from \"./dyno\";\r\nimport { newArray } from \"./utils\";\r\n\r\n// Spark provides the ability to apply \"edits\" to Gsplats as part of the standard\r\n// SplatMesh pipeline. These edits take the form of a sequence of operations,\r\n// applied one at a time to the set of Gsplats in its packedSplats. Each operation\r\n// evaluates a 7-dimensional field (RGBA and XYZ displacement) at each point in\r\n// space that derives from N=1 or more Signed Distance Field shapes (such as spheres,\r\n// boxes, planes, etc.), blended together and across inside-outisde boundaries.\r\n\r\n// The result is a an RGBA,XYZ value for each point in space, which combined with\r\n// SplatEditRgbaBlendMode.MULTIPLY/SET_RGB/ADD_RGBA can be used to create special\r\n// effects, for example simulating simple lighting or applying deformations in space,\r\n// whose parameters can be updated each frame to create animated effects.\r\n\r\n// RGBA-XYZ values are computed by blending together values from all SDF shapes using\r\n// the exponential \"softmax\" function, which is commutative (so blending order within\r\n// a SplatEdit operation doesn't matter). The parameter SplatEdit.sdfSmooth controls\r\n// the blending scale between SDF shapes, while SplatEdit.softEdge controls the scale\r\n// of soft inside-outside shape edit blending. Their default values start at 0.0 and\r\n// should be increased to soften the effect.\r\n\r\n// Note that XYZ displacement values are blended in the same way as RGBA, with a\r\n// resulting displacement field that can be quite complex but \"softly\" blending\r\n// between shapes. These RGBA-XYZ edits, along with time-based and overlapping\r\n// fields can create many interesting animations and special effects, such as\r\n// rippling leaves in the wind, an angry fire, or a looping water effects. Simply\r\n// update the SplatEdit and SplatEditSdf objects and the operations will be applied\r\n// immediately to the Gsplats in the scene.\r\n\r\nexport enum SplatEditSdfType {\r\n  // ALL: Affects all points in space\r\n  ALL = \"all\",\r\n  // PLANE: Infinite plane (position, rotation)\r\n  PLANE = \"plane\",\r\n  // SPHERE: Sphere (position, radius)\r\n  SPHERE = \"sphere\",\r\n  // BOX: Rounded box (position, rotation, sizes, radius)\r\n  BOX = \"box\",\r\n  // ELLIPSOID: Ellipsoid (position, rotation, sizes)\r\n  ELLIPSOID = \"ellipsoid\",\r\n  // CYLINDER: Cylinder (position, rotation, radius, size_y)\r\n  CYLINDER = \"cylinder\",\r\n  // CAPSULE: Capsule (position, rotation, radius, size_y)\r\n  CAPSULE = \"capsule\",\r\n  // INFINITE_CONE: Infinite cone (position, rotation, radius=angle)\r\n  INFINITE_CONE = \"infinite_cone\",\r\n}\r\n\r\nfunction sdfTypeToNumber(type: SplatEditSdfType) {\r\n  switch (type) {\r\n    case SplatEditSdfType.ALL:\r\n      return 0;\r\n    case SplatEditSdfType.PLANE:\r\n      return 1;\r\n    case SplatEditSdfType.SPHERE:\r\n      return 2;\r\n    case SplatEditSdfType.BOX:\r\n      return 3;\r\n    case SplatEditSdfType.ELLIPSOID:\r\n      return 4;\r\n    case SplatEditSdfType.CYLINDER:\r\n      return 5;\r\n    case SplatEditSdfType.CAPSULE:\r\n      return 6;\r\n    case SplatEditSdfType.INFINITE_CONE:\r\n      return 7;\r\n    default:\r\n      throw new Error(`Unknown SDF type: ${type}`);\r\n  }\r\n}\r\n\r\nexport enum SplatEditRgbaBlendMode {\r\n  // The RGBA of the splat is multiplied component-wise by the SDFs\r\n  // RGBA value at that point in space.\r\n  MULTIPLY = \"multiply\",\r\n  // Ignore the Alpha value in the SDF, but set the splats RGB to\r\n  // equal the SDFs RGB value at that point.\r\n  SET_RGB = \"set_rgb\",\r\n  // Add the SDFs RGBA value at that point to the RGBA value of\r\n  // the Gsplat. This can produce hyper-saturated results, but is useful\r\n  // to easily light up areas.\r\n  ADD_RGBA = \"add_rgba\",\r\n}\r\n\r\nfunction rgbaBlendModeToNumber(mode: SplatEditRgbaBlendMode) {\r\n  switch (mode) {\r\n    case SplatEditRgbaBlendMode.MULTIPLY:\r\n      return 0;\r\n    case SplatEditRgbaBlendMode.SET_RGB:\r\n      return 1;\r\n    case SplatEditRgbaBlendMode.ADD_RGBA:\r\n      return 2;\r\n    default:\r\n      throw new Error(`Unknown blend mode: ${mode}`);\r\n  }\r\n}\r\n\r\nexport type SplatEditSdfOptions = {\r\n  // The SDF shape type: ALL, PLANE, SPHERE, BOX, ELLIPSOID, CYLINDER, CAPSULE,\r\n  // or INFINITE_CONE. (default: SplatEditSdfType.SPHERE)\r\n  type?: SplatEditSdfType;\r\n  // Invert the SDF evaluation, swapping inside and outside regions. (default: false)\r\n  invert?: boolean;\r\n  // Opacity / \"alpha\" value used differently by blending modes (default: 1.0)\r\n  opacity?: number;\r\n  // RGB color applied within the shape. (default: new THREE.Color(1.0, 1.0, 1.0))\r\n  color?: THREE.Color;\r\n  // XYZ displacement applied to splat positions inside the shape.\r\n  // (default: new THREE.Vector3(0.0, 0.0, 0.0))\r\n  displace?: THREE.Vector3;\r\n  // Shape-specific size parameter: sphere radius, box corner rounding,\r\n  // cylinder/capsule radius, or for the infinite cone the angle factor\r\n  // (opening half-angle = /4  radius).\r\n  radius?: number;\r\n};\r\n\r\nexport class SplatEditSdf extends THREE.Object3D {\r\n  type: SplatEditSdfType;\r\n  invert: boolean;\r\n  opacity: number;\r\n  color: THREE.Color;\r\n  displace: THREE.Vector3;\r\n  radius: number;\r\n\r\n  constructor(options: SplatEditSdfOptions = {}) {\r\n    super();\r\n    const { type, invert, opacity, color, displace, radius } = options;\r\n    this.type = type ?? SplatEditSdfType.SPHERE;\r\n    this.invert = invert ?? false;\r\n    this.opacity = opacity ?? 1.0;\r\n    this.color = color ?? new THREE.Color(1.0, 1.0, 1.0);\r\n    this.displace = displace ?? new THREE.Vector3(0.0, 0.0, 0.0);\r\n    this.radius = radius ?? 0.0;\r\n  }\r\n}\r\n\r\nexport type SplatEditOptions = {\r\n  // Name of this edit operation. If you omit it, a default \"Edit 1\", \"Edit 2\", ...\r\n  // is assigned.\r\n  name?: string;\r\n  // How the SDFs RGBA modifies each splats RGBA: multiply, overwrite RGB,\r\n  // or add RGBA. (default: MULTIPLY)\r\n  rgbaBlendMode?: SplatEditRgbaBlendMode;\r\n  // Smoothing (in worldspace units) for blending between multiple SDF shapes\r\n  // at their boundaries. (default: 0.0)\r\n  sdfSmooth?: number;\r\n  // Softedge falloff radius (in worldspace units) around each SDF shapes surface.\r\n  // (default: 0.0)\r\n  softEdge?: number;\r\n  // Invert the SDF evaluation (inside/outside swap). (default: false)\r\n  invert?: boolean;\r\n  // Explicit array of SplatEditSdf objects to include. If null, any child\r\n  // SplatEditSdf instances are used.\r\n  sdfs?: SplatEditSdf[];\r\n};\r\n\r\nexport class SplatEdit extends THREE.Object3D {\r\n  // ordering used to apply SplatEdit operations to Gsplats. This is implicitly\r\n  // increased with each new SplatEdit. Reassigning ordering can be used to\r\n  // reorder the operations.\r\n  ordering: number;\r\n  rgbaBlendMode: SplatEditRgbaBlendMode;\r\n  sdfSmooth: number;\r\n  softEdge: number;\r\n  invert: boolean;\r\n\r\n  // Optional list of explicit SDFs to including in this edit. If it is null, then\r\n  // any SplatEditSdf children in the scene graph will be added automatically.\r\n  sdfs: SplatEditSdf[] | null;\r\n\r\n  // The next ordering number to use for a new SplatEdit, auto-incremented\r\n  static nextOrdering = 1;\r\n\r\n  constructor(options: SplatEditOptions = {}) {\r\n    const {\r\n      name,\r\n      rgbaBlendMode = SplatEditRgbaBlendMode.MULTIPLY,\r\n      sdfSmooth = 0.0,\r\n      softEdge = 0.0,\r\n      invert = false,\r\n      sdfs = null,\r\n    } = options;\r\n\r\n    super();\r\n    this.rgbaBlendMode = rgbaBlendMode;\r\n    this.sdfSmooth = sdfSmooth;\r\n    this.softEdge = softEdge;\r\n    this.invert = invert;\r\n    this.sdfs = sdfs;\r\n    // Assign and auto-increment unique ordering number for this edit\r\n    this.ordering = SplatEdit.nextOrdering++;\r\n    // Automatically assign a default name if not provided\r\n    this.name = name ?? `Edit ${this.ordering}`;\r\n  }\r\n\r\n  addSdf(sdf: SplatEditSdf) {\r\n    if (this.sdfs == null) {\r\n      this.sdfs = [];\r\n    }\r\n    if (!this.sdfs.includes(sdf)) {\r\n      this.sdfs.push(sdf);\r\n    }\r\n  }\r\n\r\n  removeSdf(sdf: SplatEditSdf) {\r\n    if (this.sdfs == null) {\r\n      return;\r\n    }\r\n    this.sdfs = this.sdfs.filter((s) => s !== sdf);\r\n  }\r\n}\r\n\r\n// Dyno implementation of RGBA-XYZ SDF editing.\r\n// The SDFs are encoded in a texture while the edits are encoded\r\n// as a uniform uvec4 array.\r\n\r\nexport class SplatEdits {\r\n  // Maximum number of SDFs allocated\r\n  maxSdfs: number;\r\n  // Number of SDFs currently in use\r\n  numSdfs: number;\r\n  // Encoded SDF data\r\n  sdfData: Uint32Array;\r\n  // Float interpretation of SDF data\r\n  sdfFloatData: Float32Array;\r\n  // Texture with encoded SDF data\r\n  sdfTexture: THREE.DataTexture;\r\n  // An SdfArray dyno uniform\r\n  dynoSdfArray: DynoUniform<typeof SdfArray, \"sdfArray\">;\r\n\r\n  // Maximum number of edits allocated\r\n  maxEdits: number;\r\n  // Number of edits currently in use\r\n  numEdits: number;\r\n  // Encoded edit data\r\n  editData: Uint32Array;\r\n  // Float interpretation of edit data\r\n  editFloatData: Float32Array;\r\n  // A dyno uniform for the number of edits\r\n  dynoNumEdits: DynoUniform<\"int\", \"numEdits\">;\r\n  // A dyno uniform for the encoded edits, one uvec4 per edit\r\n  dynoEdits: DynoUniform<\"uvec4\", \"edits\">;\r\n\r\n  constructor({ maxSdfs, maxEdits }: { maxSdfs?: number; maxEdits?: number }) {\r\n    // Allocate at least 16 SDFs for efficiency\r\n    this.maxSdfs = Math.max(16, maxSdfs ?? 0);\r\n    this.numSdfs = 0;\r\n\r\n    // Allocate space: 8 x (u)vec4 values per SDF, Uint32 and Float32 arrays\r\n    this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\r\n    this.sdfFloatData = new Float32Array(this.sdfData.buffer);\r\n    this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\r\n    this.dynoSdfArray = new DynoUniform({\r\n      key: \"sdfArray\",\r\n      type: SdfArray,\r\n      globals: () => [defineSdfArray],\r\n      value: {\r\n        numSdfs: 0,\r\n        sdfTexture: this.sdfTexture,\r\n      },\r\n      update: (uniform) => {\r\n        uniform.numSdfs = this.numSdfs;\r\n        uniform.sdfTexture = this.sdfTexture;\r\n        return uniform;\r\n      },\r\n    });\r\n\r\n    // Allocate at least 16 edits slots for efficiency\r\n    this.maxEdits = Math.max(16, maxEdits ?? 0);\r\n    this.numEdits = 0;\r\n    // Allocate space: 1 uvec4 per edit\r\n    this.editData = new Uint32Array(this.maxEdits * 4);\r\n    this.editFloatData = new Float32Array(this.editData.buffer);\r\n    this.dynoNumEdits = new DynoInt({ value: 0 });\r\n    this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\r\n  }\r\n\r\n  private newSdfTexture(data: Uint32Array, maxSdfs: number) {\r\n    const texture = new THREE.DataTexture(\r\n      data,\r\n      8,\r\n      maxSdfs,\r\n      THREE.RGBAIntegerFormat,\r\n      THREE.UnsignedIntType,\r\n    );\r\n    texture.internalFormat = \"RGBA32UI\";\r\n    texture.needsUpdate = true;\r\n    return texture;\r\n  }\r\n\r\n  private newEdits(data: Uint32Array, maxEdits: number) {\r\n    return new DynoUniform({\r\n      key: \"edits\",\r\n      type: \"uvec4\",\r\n      count: maxEdits,\r\n      globals: () => [defineEdit],\r\n      value: data,\r\n    });\r\n  }\r\n\r\n  // Ensure our SDF texture and edits uniform array have enough capacity.\r\n  // Reallocate if not.\r\n  private ensureCapacity({\r\n    maxSdfs,\r\n    maxEdits,\r\n  }: { maxSdfs: number; maxEdits: number }): boolean {\r\n    let dynoUpdated = false;\r\n    if (maxSdfs > this.sdfTexture.image.height) {\r\n      this.sdfTexture.dispose();\r\n      // At least double the size to avoid frequent reallocations\r\n      this.maxSdfs = Math.max(this.maxSdfs * 2, maxSdfs);\r\n      this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\r\n      this.sdfFloatData = new Float32Array(this.sdfData.buffer);\r\n      this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\r\n    }\r\n    if (maxEdits > (this.dynoEdits.count ?? 0)) {\r\n      // At least double the size to avoid frequent reallocations\r\n      this.maxEdits = Math.max(this.maxEdits * 2, maxEdits);\r\n      this.editData = new Uint32Array(this.maxEdits * 4);\r\n      this.editFloatData = new Float32Array(this.editData.buffer);\r\n      this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\r\n      dynoUpdated = true;\r\n    }\r\n    return dynoUpdated;\r\n  }\r\n\r\n  private updateEditData(offset: number, value: number): boolean {\r\n    // Update an edit uint32 value and return true if it changed\r\n    const updated = this.editData[offset] !== value;\r\n    this.editData[offset] = value;\r\n    return updated;\r\n  }\r\n\r\n  private updateEditFloatData(offset: number, value: number): boolean {\r\n    // Update an edit float32 value and return true if it changed\r\n    tempFloat32[0] = value;\r\n    const updated = this.editFloatData[offset] !== tempFloat32[0];\r\n    if (updated) {\r\n      this.editFloatData[offset] = tempFloat32[0];\r\n    }\r\n    return updated;\r\n  }\r\n\r\n  private encodeEdit(\r\n    editIndex: number,\r\n    {\r\n      sdfFirst,\r\n      sdfCount,\r\n      invert,\r\n      rgbaBlendMode,\r\n      softEdge,\r\n      sdfSmooth,\r\n    }: {\r\n      sdfFirst: number;\r\n      sdfCount: number;\r\n      invert: boolean;\r\n      rgbaBlendMode: number;\r\n      softEdge: number;\r\n      sdfSmooth: number;\r\n    },\r\n  ): boolean {\r\n    const base = editIndex * 4;\r\n    let updated = false;\r\n    // Encode the edit fields into the editData array and check if any changed\r\n    updated =\r\n      this.updateEditData(base + 0, rgbaBlendMode | (invert ? 1 << 8 : 0)) ||\r\n      updated;\r\n    updated =\r\n      this.updateEditData(base + 1, sdfFirst | (sdfCount << 16)) || updated;\r\n    updated = this.updateEditFloatData(base + 2, softEdge) || updated;\r\n    updated = this.updateEditFloatData(base + 3, sdfSmooth) || updated;\r\n    return updated;\r\n  }\r\n\r\n  private updateSdfData(offset: number, value: number): boolean {\r\n    // Update an SDF uint32 value and return true if it changed\r\n    const updated = this.sdfData[offset] !== value;\r\n    this.sdfData[offset] = value;\r\n    return updated;\r\n  }\r\n\r\n  private updateSdfFloatData(offset: number, value: number): boolean {\r\n    // Update an SDF float32 value and return true if it changed\r\n    tempFloat32[0] = value;\r\n    const updated = this.sdfFloatData[offset] !== tempFloat32[0];\r\n    if (updated) {\r\n      this.sdfFloatData[offset] = tempFloat32[0];\r\n    }\r\n    return updated;\r\n  }\r\n\r\n  private encodeSdf(\r\n    sdfIndex: number,\r\n    {\r\n      sdfType,\r\n      invert,\r\n      center,\r\n      quaternion,\r\n      scale,\r\n      sizes,\r\n    }: {\r\n      sdfType: number;\r\n      invert?: boolean;\r\n      center?: THREE.Vector3;\r\n      quaternion?: THREE.Quaternion;\r\n      scale?: THREE.Vector3;\r\n      sizes?: THREE.Vector4;\r\n    },\r\n    values: THREE.Vector4[],\r\n  ): boolean {\r\n    // Encode the SDF fields into the sdfData array and check if any changed\r\n    const base = sdfIndex * (8 * 4);\r\n    const flags = sdfType | (invert ? 1 << 8 : 0);\r\n    let updated = false;\r\n\r\n    updated = this.updateSdfFloatData(base + 0, center?.x ?? 0) || updated;\r\n    updated = this.updateSdfFloatData(base + 1, center?.y ?? 0) || updated;\r\n    updated = this.updateSdfFloatData(base + 2, center?.z ?? 0) || updated;\r\n    updated = this.updateSdfData(base + 3, flags) || updated;\r\n\r\n    updated = this.updateSdfFloatData(base + 4, quaternion?.x ?? 0) || updated;\r\n    updated = this.updateSdfFloatData(base + 5, quaternion?.y ?? 0) || updated;\r\n    updated = this.updateSdfFloatData(base + 6, quaternion?.z ?? 0) || updated;\r\n    updated = this.updateSdfFloatData(base + 7, quaternion?.w ?? 0) || updated;\r\n\r\n    updated = this.updateSdfFloatData(base + 8, scale?.x ?? 0) || updated;\r\n    updated = this.updateSdfFloatData(base + 9, scale?.y ?? 0) || updated;\r\n    updated = this.updateSdfFloatData(base + 10, scale?.z ?? 0) || updated;\r\n    updated = this.updateSdfData(base + 11, 0) || updated;\r\n\r\n    updated = this.updateSdfFloatData(base + 12, sizes?.x ?? 0) || updated;\r\n    updated = this.updateSdfFloatData(base + 13, sizes?.y ?? 0) || updated;\r\n    updated = this.updateSdfFloatData(base + 14, sizes?.z ?? 0) || updated;\r\n    updated = this.updateSdfFloatData(base + 15, sizes?.w ?? 0) || updated;\r\n\r\n    const nValues = Math.min(4, values.length);\r\n    for (let i = 0; i < nValues; ++i) {\r\n      const vBase = base + 16 + i * 4;\r\n      updated = this.updateSdfFloatData(vBase + 0, values[i].x) || updated;\r\n      updated = this.updateSdfFloatData(vBase + 1, values[i].y) || updated;\r\n      updated = this.updateSdfFloatData(vBase + 2, values[i].z) || updated;\r\n      updated = this.updateSdfFloatData(vBase + 3, values[i].w) || updated;\r\n    }\r\n    return updated;\r\n  }\r\n\r\n  // Update the SDFs and edits from an array of SplatEdits and their\r\n  // associated SplatEditSdfs, updating it for the dyno shader program.\r\n  update(edits: { edit: SplatEdit; sdfs: SplatEditSdf[] }[]): {\r\n    updated: boolean;\r\n    dynoUpdated: boolean;\r\n  } {\r\n    const sdfCount = edits.reduce((total, { sdfs }) => total + sdfs.length, 0);\r\n    const dynoUpdated = this.ensureCapacity({\r\n      maxEdits: edits.length,\r\n      maxSdfs: sdfCount,\r\n    });\r\n\r\n    const values = [new THREE.Vector4(), new THREE.Vector4()];\r\n    const center = new THREE.Vector3();\r\n    const quaternion = new THREE.Quaternion();\r\n    const scale = new THREE.Vector3();\r\n    const sizes = new THREE.Vector4();\r\n\r\n    let sdfIndex = 0;\r\n    let updated = dynoUpdated;\r\n\r\n    if (edits.length !== this.dynoNumEdits.value) {\r\n      this.dynoNumEdits.value = edits.length;\r\n      this.numEdits = edits.length;\r\n      updated = true;\r\n    }\r\n\r\n    for (const [editIndex, { edit, sdfs }] of edits.entries()) {\r\n      updated =\r\n        this.encodeEdit(editIndex, {\r\n          sdfFirst: sdfIndex,\r\n          sdfCount: sdfs.length,\r\n          invert: edit.invert,\r\n          rgbaBlendMode: rgbaBlendModeToNumber(edit.rgbaBlendMode),\r\n          softEdge: edit.softEdge,\r\n          sdfSmooth: edit.sdfSmooth,\r\n        }) || updated;\r\n\r\n      let sdfUpdated = false;\r\n      for (const sdf of sdfs) {\r\n        sizes.set(sdf.scale.x, sdf.scale.y, sdf.scale.z, sdf.radius);\r\n        // Temporarily set the SDF scale to 1.0 to get the world-to-SDF\r\n        // transform without scaling. The SDF treats the scale separately.\r\n        sdf.scale.setScalar(1.0);\r\n        sdf.updateMatrixWorld();\r\n        const worldToSdf = sdf.matrixWorld.clone().invert();\r\n        worldToSdf.decompose(center, quaternion, scale);\r\n\r\n        sdf.scale.set(sizes.x, sizes.y, sizes.z);\r\n        sdf.updateMatrixWorld();\r\n\r\n        values[0].set(sdf.color.r, sdf.color.g, sdf.color.b, sdf.opacity);\r\n        values[1].set(sdf.displace.x, sdf.displace.y, sdf.displace.z, 1.0);\r\n\r\n        sdfUpdated =\r\n          this.encodeSdf(\r\n            sdfIndex,\r\n            {\r\n              sdfType: sdfTypeToNumber(sdf.type),\r\n              invert: sdf.invert,\r\n              center,\r\n              quaternion,\r\n              scale,\r\n              sizes,\r\n            },\r\n            values,\r\n          ) || sdfUpdated;\r\n\r\n        sdfIndex += 1;\r\n      }\r\n      this.numSdfs = sdfIndex;\r\n      if (sdfUpdated) {\r\n        this.sdfTexture.needsUpdate = true;\r\n      }\r\n      updated ||= sdfUpdated;\r\n    }\r\n    return { updated, dynoUpdated };\r\n  }\r\n\r\n  // Modify a Gsplat in a dyno shader program using the current edits and SDFs.\r\n  modify(gsplat: DynoVal<typeof Gsplat>): DynoVal<typeof Gsplat> {\r\n    return applyGsplatRgbaDisplaceEdits(\r\n      gsplat,\r\n      this.dynoSdfArray,\r\n      this.dynoNumEdits,\r\n      this.dynoEdits,\r\n    );\r\n  }\r\n}\r\n\r\n// Dyno types and components:\r\n\r\n// An SdfArray contains a collection of SDFs encoded in a texture.\r\n// Each SDF has a type and geometric parameters, but also encodes\r\n// 4 x vec4 values, which can all be blended across multiple SDFs.\r\n// The SplatEdit system uses 7 of these 16 values to encode RGBA-XYZ edits,\r\n// but more can be added, and these SDFs can be used for entirely different\r\n// purposes as well.\r\n\r\nexport const SdfArray = { type: \"SdfArray\" } as { type: \"SdfArray\" };\r\n\r\nexport const defineSdfArray = unindent(`\r\n  struct SdfArray {\r\n    int numSdfs;\r\n    usampler2D sdfTexture;\r\n  };\r\n\r\n  void unpackSdfArray(\r\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\r\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\r\n    int numValues, out vec4 values[4]\r\n  ) {\r\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\r\n    flags = temp.w;\r\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\r\n\r\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\r\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\r\n\r\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\r\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\r\n\r\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\r\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\r\n\r\n    for (int i = 0; i < numValues; ++i) {\r\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\r\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\r\n    }\r\n  }\r\n\r\n  const uint SDF_FLAG_TYPE = 0xFFu;\r\n  const uint SDF_FLAG_INVERT = 1u << 8u;\r\n\r\n  const uint SDF_TYPE_ALL = 0u;\r\n  const uint SDF_TYPE_PLANE = 1u;\r\n  const uint SDF_TYPE_SPHERE = 2u;\r\n  const uint SDF_TYPE_BOX = 3u;\r\n  const uint SDF_TYPE_ELLIPSOID = 4u;\r\n  const uint SDF_TYPE_CYLINDER = 5u;\r\n  const uint SDF_TYPE_CAPSULE = 6u;\r\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\r\n\r\n  float evaluateSdfArray(\r\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\r\n    float smoothK, int numValues, out vec4 outValues[4]\r\n  ) {\r\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\r\n    float maxExp = -1.0 / 0.0;\r\n    for (int i = 0; i < numValues; ++i) {\r\n        outValues[i] = vec4(0.0);\r\n    }\r\n\r\n    uint flags;\r\n    vec3 center, scale;\r\n    vec4 quaternion, sizes;\r\n    vec4 values[4];\r\n\r\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\r\n    for (int index = sdfFirst; index < sdfLast; ++index) {\r\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\r\n      uint sdfType = flags & SDF_FLAG_TYPE;\r\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\r\n\r\n      float distance;\r\n      switch (sdfType) {\r\n        case SDF_TYPE_ALL:\r\n          distance = -1.0 / 0.0;\r\n          break;\r\n        case SDF_TYPE_PLANE: {\r\n          distance = sdfPos.z;\r\n          break;\r\n        }\r\n        case SDF_TYPE_SPHERE: {\r\n          distance = length(sdfPos) - sizes.w;\r\n          break;\r\n        }\r\n        case SDF_TYPE_BOX: {\r\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\r\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\r\n          break;\r\n        }\r\n        case SDF_TYPE_ELLIPSOID: {\r\n          vec3 sizes = sizes.xyz;\r\n          float k0 = length(sdfPos / sizes);\r\n          float k1 = length(sdfPos / dot(sizes, sizes));\r\n          distance = k0 * (k0 - 1.0) / k1;\r\n          break;\r\n        }\r\n        case SDF_TYPE_CYLINDER: {\r\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\r\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\r\n          break;\r\n        }\r\n        case SDF_TYPE_CAPSULE: {\r\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\r\n          distance = length(sdfPos) - sizes.w;\r\n          break;\r\n        }\r\n        case SDF_TYPE_INFINITE_CONE: {\r\n          float angle = 0.25 * PI * sizes.w;\r\n          vec2 c = vec2(sin(angle), cos(angle));\r\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\r\n          float d = length(q - c * max(dot(q, c), 0.0));\r\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\r\n          break;\r\n        }\r\n      }\r\n\r\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\r\n        distance = -distance;\r\n      }\r\n\r\n      if (smoothK == 0.0) {\r\n        if (distance < distanceAccum) {\r\n          distanceAccum = distance;\r\n          for (int i = 0; i < numValues; ++i) {\r\n            outValues[i] = values[i];\r\n          }\r\n        }\r\n      } else {\r\n        float scaledDistance = -distance / smoothK;\r\n        if (scaledDistance > maxExp) {\r\n          float scale = exp(maxExp - scaledDistance);\r\n          distanceAccum *= scale;\r\n          for (int i = 0; i < numValues; ++i) {\r\n            outValues[i] *= scale;\r\n          }\r\n          maxExp = scaledDistance;\r\n        }\r\n\r\n        float weight = exp(scaledDistance - maxExp);\r\n        distanceAccum += weight;\r\n        for (int i = 0; i < numValues; ++i) {\r\n          outValues[i] += weight * values[i];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (smoothK == 0.0) {\r\n      return distanceAccum;\r\n    } else {\r\n      // Very distant SDFs may result in 0 accumulation\r\n      if (distanceAccum == 0.0) {\r\n        return 1.0 / 0.0;\r\n      }\r\n      for (int i = 0; i < numValues; ++i) {\r\n        outValues[i] /= distanceAccum;\r\n      }\r\n      return (-log(distanceAccum) - maxExp) * smoothK;\r\n    }\r\n  }\r\n\r\n  float modulateSdfArray(\r\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\r\n    float smoothK, int numValues, out vec4 values[4],\r\n    float softEdge, bool invert\r\n  ) {\r\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\r\n    if (invert) {\r\n      distance = -distance;\r\n    }\r\n\r\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\r\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\r\n  }\r\n`);\r\n\r\nexport const defineEdit = unindent(`\r\n  const uint EDIT_FLAG_BLEND = 0xFFu;\r\n  const uint EDIT_BLEND_MULTIPLY = 0u;\r\n  const uint EDIT_BLEND_SET_RGB = 1u;\r\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\r\n  const uint EDIT_FLAG_INVERT = 0x100u;\r\n\r\n  void decodeEdit(\r\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\r\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\r\n  ) {\r\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\r\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\r\n\r\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\r\n    sdfCount = int(packedEdit.y >> 16u);\r\n\r\n    softEdge = uintBitsToFloat(packedEdit.z);\r\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\r\n  }\r\n\r\n  void applyRgbaDisplaceEdit(\r\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\r\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\r\n  ) {\r\n    vec4 values[4];\r\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\r\n    // On Android, moving values[0] is necessary to work around a compiler bug.\r\n    vec4 sdfRgba = values[0];\r\n    vec4 sdfDisplaceScale = values[1];\r\n\r\n    vec4 target;\r\n    switch (rgbaBlendMode) {\r\n      case EDIT_BLEND_MULTIPLY:\r\n        target = rgba * sdfRgba;\r\n        break;\r\n      case EDIT_BLEND_SET_RGB:\r\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\r\n        break;\r\n      case EDIT_BLEND_ADD_RGBA:\r\n        target = rgba + sdfRgba;\r\n        break;\r\n      default:\r\n        // Debug output if blend mode not set\r\n        target = vec4(fract(pos), 1.0);\r\n    }\r\n    rgba = mix(rgba, target, modulate);\r\n    pos += sdfDisplaceScale.xyz * modulate;\r\n  }\r\n\r\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\r\n    int sdfFirst, sdfCount;\r\n    bool invert;\r\n    uint rgbaBlendMode;\r\n    float softEdge, sdfSmooth;\r\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\r\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\r\n  }\r\n`);\r\n\r\nfunction applyGsplatRgbaDisplaceEdits(\r\n  gsplat: DynoVal<typeof Gsplat>,\r\n  sdfArray: DynoVal<typeof SdfArray>,\r\n  numEdits: DynoVal<\"int\">,\r\n  rgbaDisplaceEdits: DynoVal<\"uvec4\">,\r\n): DynoVal<typeof Gsplat> {\r\n  const dyno = new Dyno<\r\n    {\r\n      gsplat: typeof Gsplat;\r\n      sdfArray: typeof SdfArray;\r\n      numEdits: \"int\";\r\n      rgbaDisplaceEdits: \"uvec4\";\r\n    },\r\n    { gsplat: typeof Gsplat }\r\n  >({\r\n    inTypes: {\r\n      gsplat: Gsplat,\r\n      sdfArray: SdfArray,\r\n      numEdits: \"int\",\r\n      rgbaDisplaceEdits: \"uvec4\",\r\n    },\r\n    outTypes: { gsplat: Gsplat },\r\n    globals: () => [defineSdfArray, defineEdit],\r\n    inputs: { gsplat, sdfArray, numEdits, rgbaDisplaceEdits },\r\n    statements: ({ inputs, outputs }) => {\r\n      const { sdfArray, numEdits, rgbaDisplaceEdits } = inputs;\r\n      const { gsplat } = outputs;\r\n      return unindentLines(`\r\n        ${gsplat} = ${inputs.gsplat};\r\n        if (isGsplatActive(${gsplat}.flags)) {\r\n          for (int editIndex = 0; editIndex < ${numEdits}; ++editIndex) {\r\n            applyPackedRgbaDisplaceEdit(\r\n              ${rgbaDisplaceEdits}[editIndex], ${sdfArray}.sdfTexture, ${sdfArray}.numSdfs,\r\n              ${gsplat}.center, ${gsplat}.rgba\r\n            );\r\n          }\r\n        }\r\n      `);\r\n    },\r\n  });\r\n  return dyno.outputs.gsplat;\r\n}\r\n\r\nconst tempFloat32 = new Float32Array(1);\r\n","import * as THREE from \"three\";\r\nimport type { SplatEdit } from \"./SplatEdit\";\r\nimport {\r\n  type Dyno,\r\n  DynoFloat,\r\n  type DynoVal,\r\n  DynoVec3,\r\n  DynoVec4,\r\n  Gsplat,\r\n  dynoBlock,\r\n  transformDir,\r\n  transformGsplat,\r\n  transformPos,\r\n} from \"./dyno\";\r\n\r\n// A GsplatGenerator is a dyno program that maps an index to a Gsplat's properties\r\n\r\nexport type GsplatGenerator = Dyno<{ index: \"int\" }, { gsplat: typeof Gsplat }>;\r\n\r\n// A GsplatModifier is a dyno program that inputs a Gsplat, modifies, and outputs it\r\n\r\nexport type GsplatModifier = Dyno<\r\n  { gsplat: typeof Gsplat },\r\n  { gsplat: typeof Gsplat }\r\n>;\r\n\r\n// A SplatModifier is a utility class to apply a GsplatModifier to\r\n// a GsplatGenerator pipeline, caching the combined result for efficiency.\r\n\r\nexport class SplatModifier {\r\n  modifier: GsplatModifier;\r\n  cache: Map<GsplatGenerator, GsplatGenerator>;\r\n\r\n  constructor(modifier: GsplatModifier) {\r\n    this.modifier = modifier;\r\n    this.cache = new Map();\r\n  }\r\n\r\n  apply(generator: GsplatGenerator): GsplatGenerator {\r\n    let modified = this.cache.get(generator);\r\n    if (!modified) {\r\n      modified = dynoBlock(\r\n        { index: \"int\" },\r\n        { gsplat: Gsplat },\r\n        ({ index }) => {\r\n          const { gsplat } = generator.apply({ index });\r\n          return this.modifier.apply({ gsplat });\r\n        },\r\n      );\r\n      this.cache.set(generator, modified);\r\n    }\r\n    return modified;\r\n  }\r\n}\r\n\r\n// A SplatTransformer is a utility class to apply a transform to a Gsplat\r\n// via a scale, rotation, and translation. Scale is a single float because\r\n// anisotropic scaling of Gsplats is not supported.\r\n\r\nexport class SplatTransformer {\r\n  scale: DynoFloat;\r\n  rotate: DynoVec4<THREE.Quaternion>;\r\n  translate: DynoVec3<THREE.Vector3>;\r\n\r\n  // Create the dyno uniforms that parameterize the transform, setting them\r\n  // to initial values that are different from any valid transform.\r\n  constructor() {\r\n    this.scale = new DynoFloat({ value: Number.NEGATIVE_INFINITY });\r\n    this.rotate = new DynoVec4({\r\n      value: new THREE.Quaternion(\r\n        Number.POSITIVE_INFINITY,\r\n        Number.POSITIVE_INFINITY,\r\n        Number.POSITIVE_INFINITY,\r\n        Number.POSITIVE_INFINITY,\r\n      ),\r\n    });\r\n    this.translate = new DynoVec3({\r\n      value: new THREE.Vector3(\r\n        Number.POSITIVE_INFINITY,\r\n        Number.POSITIVE_INFINITY,\r\n        Number.POSITIVE_INFINITY,\r\n      ),\r\n    });\r\n  }\r\n\r\n  // Apply the transform to a Vec3 position in a dyno program.\r\n  apply(position: DynoVal<\"vec3\">): DynoVal<\"vec3\"> {\r\n    return transformPos(position, {\r\n      scale: this.scale,\r\n      rotate: this.rotate,\r\n      translate: this.translate,\r\n    });\r\n  }\r\n\r\n  applyDir(dir: DynoVal<\"vec3\">): DynoVal<\"vec3\"> {\r\n    return transformDir(dir, {\r\n      rotate: this.rotate,\r\n    });\r\n  }\r\n\r\n  // Apply the transform to a Gsplat in a dyno program.\r\n  applyGsplat(gsplat: DynoVal<typeof Gsplat>): DynoVal<typeof Gsplat> {\r\n    return transformGsplat(gsplat, {\r\n      scale: this.scale,\r\n      rotate: this.rotate,\r\n      translate: this.translate,\r\n    });\r\n  }\r\n\r\n  // Update the uniforms to match the given transform matrix.\r\n  updateFromMatrix(transform: THREE.Matrix4) {\r\n    const scale = new THREE.Vector3();\r\n    const quaternion = new THREE.Quaternion();\r\n    const position = new THREE.Vector3();\r\n    transform.decompose(position, quaternion, scale);\r\n    const newScale = (scale.x + scale.y + scale.z) / 3;\r\n\r\n    let updated = false;\r\n    if (newScale !== this.scale.value) {\r\n      this.scale.value = newScale;\r\n      updated = true;\r\n    }\r\n    if (!position.equals(this.translate.value)) {\r\n      this.translate.value.copy(position);\r\n      updated = true;\r\n    }\r\n    if (!quaternion.equals(this.rotate.value)) {\r\n      this.rotate.value.copy(quaternion);\r\n      updated = true;\r\n    }\r\n    return updated;\r\n  }\r\n\r\n  // Update this transform to match the object's to-world transform.\r\n  update(object: THREE.Object3D): boolean {\r\n    object.updateMatrixWorld();\r\n    return this.updateFromMatrix(object.matrixWorld);\r\n  }\r\n}\r\n\r\n// SplatGenerator is an Object3D that can be placed anywhere in the scene\r\n// to generate Gsplats into the world for SparkRenderer. All Gsplats from\r\n// SplatGenerators across the scene will be accumulated into a single\r\n// SplatAccumulator, which are sorted and rendered together.\r\n//\r\n// Each SplatGenerator has two main properties:\r\n// - numSplats: the number of Gsplats to generate\r\n// - generator: a GsplatGenerator dyno program that maps a splat index\r\n//   to a Gsplat's properties\r\n// Each of these properties can be changed at anytime, however changing\r\n// numSplats means we no longer have a correspondence between Gsplats\r\n// in successive frames, meaning we can't reuse the previous Gsplat sort\r\n// order. Similarly, changing the generator requires re-generating the\r\n// shader program, which will trigger a GPU shader compilation the first\r\n// time (possibly a perceptible \"hickup\" in the framerate) but is cached\r\n// subsequence times if the generator is the same as one that was used previously.\r\n//\r\n// A SplatGenerator also has a custom frameUpdate function that is called\r\n// on each execution, allowing you to update uniforms or other parameters that\r\n// affect the generation. If the Gsplats are changed, you must call\r\n// updateVersion() (alternatively, set needsUpdate to true) to trigger a\r\n// re-generation of the Gsplats for this SplatGenerator.\r\n\r\nexport class SplatGenerator extends THREE.Object3D {\r\n  numSplats: number;\r\n  generator?: GsplatGenerator;\r\n  generatorError?: unknown;\r\n  frameUpdate?: ({\r\n    object,\r\n    time,\r\n    deltaTime,\r\n    viewToWorld,\r\n    globalEdits,\r\n  }: {\r\n    object: SplatGenerator;\r\n    time: number;\r\n    deltaTime: number;\r\n    viewToWorld: THREE.Matrix4;\r\n    globalEdits: SplatEdit[];\r\n  }) => void;\r\n  version: number;\r\n\r\n  constructor({\r\n    numSplats,\r\n    generator,\r\n    construct,\r\n    update,\r\n  }: {\r\n    numSplats?: number;\r\n    generator?: GsplatGenerator;\r\n    construct?: (object: SplatGenerator) => {\r\n      generator?: GsplatGenerator;\r\n      numSplats?: number;\r\n      frameUpdate?: (object: SplatGenerator) => void;\r\n    };\r\n    update?: ({\r\n      object,\r\n      time,\r\n      deltaTime,\r\n      viewToWorld,\r\n      globalEdits,\r\n    }: {\r\n      object: SplatGenerator;\r\n      time: number;\r\n      deltaTime: number;\r\n      viewToWorld: THREE.Matrix4;\r\n      globalEdits: SplatEdit[];\r\n    }) => void;\r\n  }) {\r\n    super();\r\n\r\n    this.numSplats = numSplats ?? 0;\r\n    this.generator = generator;\r\n    this.frameUpdate = update;\r\n    this.version = 0;\r\n\r\n    if (construct) {\r\n      const constructed = construct(this);\r\n      // If we returned something, update our properties\r\n      Object.assign(this, constructed);\r\n    }\r\n  }\r\n\r\n  updateVersion() {\r\n    this.version += 1;\r\n  }\r\n\r\n  set needsUpdate(value: boolean) {\r\n    if (value) {\r\n      this.updateVersion();\r\n    }\r\n  }\r\n}\r\n","import * as THREE from \"three\";\r\n\r\nimport init_wasm, { raycast_splats } from \"spark-internal-rs\";\r\nimport {\r\n  DEFAULT_SPLAT_ENCODING,\r\n  PackedSplats,\r\n  type SplatEncoding,\r\n} from \"./PackedSplats\";\r\nimport { type RgbaArray, readRgbaArray } from \"./RgbaArray\";\r\nimport { SparkRenderer } from \"./SparkRenderer\";\r\nimport { SplatEdit, SplatEditSdf, SplatEdits } from \"./SplatEdit\";\r\nimport {\r\n  type GsplatModifier,\r\n  SplatGenerator,\r\n  SplatTransformer,\r\n} from \"./SplatGenerator\";\r\nimport type { SplatFileType } from \"./SplatLoader\";\r\nimport type { SplatSkinning } from \"./SplatSkinning\";\r\nimport { LN_SCALE_MAX, LN_SCALE_MIN } from \"./defines\";\r\nimport {\r\n  DynoFloat,\r\n  DynoUsampler2DArray,\r\n  type DynoVal,\r\n  DynoVec4,\r\n  Gsplat,\r\n  add,\r\n  combineGsplat,\r\n  defineGsplat,\r\n  dyno,\r\n  dynoBlock,\r\n  dynoConst,\r\n  extendVec,\r\n  mul,\r\n  normalize,\r\n  readPackedSplat,\r\n  split,\r\n  splitGsplat,\r\n  sub,\r\n  unindent,\r\n  unindentLines,\r\n} from \"./dyno\";\r\nimport { getTextureSize } from \"./utils\";\r\n\r\nexport type SplatMeshOptions = {\r\n  // URL to fetch a Gaussian splat file from(supports .ply, .splat, .ksplat,\r\n  // .spz formats). (default: undefined)\r\n  url?: string;\r\n  // Raw bytes of a Gaussian splat file to decode directly instead of fetching\r\n  // from URL. (default: undefined)\r\n  fileBytes?: Uint8Array | ArrayBuffer;\r\n  // Override the file type detection for formats that can't be reliably\r\n  // auto-detected (.splat, .ksplat). (default: undefined auto-detects other\r\n  // formats from file contents)\r\n  fileType?: SplatFileType;\r\n  // File name to use for type detection. (default: undefined)\r\n  fileName?: string;\r\n  // Use an existing PackedSplats object as the source instead of loading from\r\n  // a file. Can be used to share a collection of Gsplats among multiple SplatMeshes\r\n  // (default: undefined creates a new empty PackedSplats or decoded from a\r\n  // data source above)\r\n  packedSplats?: PackedSplats;\r\n  // Reserve space for at least this many splats when constructing the mesh\r\n  // initially. (default: determined by file)\r\n  maxSplats?: number;\r\n  // Callback function to programmatically create splats at initialization\r\n  // in provided PackedSplats. (default: undefined)\r\n  constructSplats?: (splats: PackedSplats) => Promise<void> | void;\r\n  // Callback function that is called when mesh initialization is complete.\r\n  // (default: undefined)\r\n  onLoad?: (mesh: SplatMesh) => Promise<void> | void;\r\n  // Controls whether SplatEdits have any effect on this mesh. (default: true)\r\n  editable?: boolean;\r\n  // Callback function that is called every frame to update the mesh.\r\n  // Call mesh.updateVersion() if splats need to be regenerated due to some change.\r\n  // Calling updateVersion() is not necessary for object transformations, recoloring,\r\n  // or opacity adjustments as these are auto-detected. (default: undefined)\r\n  onFrame?: ({\r\n    mesh,\r\n    time,\r\n    deltaTime,\r\n  }: { mesh: SplatMesh; time: number; deltaTime: number }) => void;\r\n  // Gsplat modifier to apply in object-space before any transformations.\r\n  // A GsplatModifier is a dyno shader-graph block that transforms an input\r\n  // gsplat: DynoVal<Gsplat> to an output gsplat: DynoVal<Gsplat> with gsplat.center\r\n  // coordinate in object-space. (default: undefined)\r\n  objectModifier?: GsplatModifier;\r\n  // Gsplat modifier to apply in world-space after transformations.\r\n  // (default: undefined)\r\n  worldModifier?: GsplatModifier;\r\n  // Override the default splat encoding ranges for the PackedSplats.\r\n  // (default: undefined)\r\n  splatEncoding?: SplatEncoding;\r\n};\r\n\r\nexport type SplatMeshContext = {\r\n  transform: SplatTransformer;\r\n  viewToWorld: SplatTransformer;\r\n  worldToView: SplatTransformer;\r\n  viewToObject: SplatTransformer;\r\n  recolor: DynoVec4<THREE.Vector4>;\r\n  time: DynoFloat;\r\n  deltaTime: DynoFloat;\r\n};\r\n\r\nexport class SplatMesh extends SplatGenerator {\r\n  // A Promise<SplatMesh> you can await to ensure fetching, parsing,\r\n  // and initialization has completed\r\n  initialized: Promise<SplatMesh>;\r\n  // A boolean indicating whether initialization is complete\r\n  isInitialized = false;\r\n\r\n  // If you modify packedSplats you should set\r\n  // splatMesh.packedSplats.needsUpdate = true to signal to Three.js that it\r\n  // should re-upload the data to the underlying texture. Use this sparingly with\r\n  // objects with smaller Gsplat counts as it requires a CPU-GPU data transfer for\r\n  // each frame. Thousands to tens of thousands of Gsplats ir fine. (See hands.ts\r\n  // for an example of rendering \"Gsplat hands\" in WebXR using this technique.)\r\n  packedSplats: PackedSplats;\r\n\r\n  // A THREE.Color that can be used to tint all splats in the mesh.\r\n  // (default: new THREE.Color(1, 1, 1))\r\n  recolor: THREE.Color = new THREE.Color(1, 1, 1);\r\n  // Global opacity multiplier for all splats in the mesh. (default: 1)\r\n  opacity = 1;\r\n\r\n  // A SplatMeshContext consisting of useful scene and object dyno uniforms that can\r\n  // be used to in the Gsplat processing pipeline, for example via objectModifier and\r\n  // worldModifier. (created on construction)\r\n  context: SplatMeshContext;\r\n  onFrame?: ({\r\n    mesh,\r\n    time,\r\n    deltaTime,\r\n  }: { mesh: SplatMesh; time: number; deltaTime: number }) => void;\r\n\r\n  objectModifier?: GsplatModifier;\r\n  worldModifier?: GsplatModifier;\r\n  // Set to true to have the viewToObject property in context be updated each frame.\r\n  // If the mesh has extra.sh1 (first order spherical harmonics directional lighting)\r\n  // this property will always be updated. (default: false)\r\n  enableViewToObject = false;\r\n  // Set to true to have context.viewToWorld updated each frame. (default: false)\r\n  enableViewToWorld = false;\r\n  // Set to true to have context.worldToView updated each frame. (default: false)\r\n  enableWorldToView = false;\r\n\r\n  // Optional SplatSkinning instance for animating splats with dual-quaternion\r\n  // skeletal animation. (default: null)\r\n  skinning: SplatSkinning | null = null;\r\n\r\n  // Optional list of SplatEdits to apply to the mesh. If null, any SplatEdit\r\n  // children in the scene graph will be added automatically. (default: null)\r\n  edits: SplatEdit[] | null = null;\r\n  editable: boolean;\r\n  // Compiled SplatEdits for applying SDF edits to splat RGBA + centers\r\n  private rgbaDisplaceEdits: SplatEdits | null = null;\r\n  // Optional RgbaArray to overwrite splat RGBA values with custom values.\r\n  // Useful for \"baking\" RGB and opacity edits into the SplatMesh. (default: null)\r\n  splatRgba: RgbaArray | null = null;\r\n\r\n  // Maximum Spherical Harmonics level to use. Call updateGenerator()\r\n  // after changing. (default: 3)\r\n  maxSh = 3;\r\n\r\n  constructor(options: SplatMeshOptions = {}) {\r\n    const transform = new SplatTransformer();\r\n    const viewToWorld = new SplatTransformer();\r\n    const worldToView = new SplatTransformer();\r\n    const viewToObject = new SplatTransformer();\r\n    const recolor = new DynoVec4({\r\n      value: new THREE.Vector4(\r\n        Number.NEGATIVE_INFINITY,\r\n        Number.NEGATIVE_INFINITY,\r\n        Number.NEGATIVE_INFINITY,\r\n        Number.NEGATIVE_INFINITY,\r\n      ),\r\n    });\r\n    const time = new DynoFloat({ value: 0 });\r\n    const deltaTime = new DynoFloat({ value: 0 });\r\n    const context = {\r\n      transform,\r\n      viewToWorld,\r\n      worldToView,\r\n      viewToObject,\r\n      recolor,\r\n      time,\r\n      deltaTime,\r\n    };\r\n\r\n    super({\r\n      update: ({ time, deltaTime, viewToWorld, globalEdits }) =>\r\n        this.update({ time, deltaTime, viewToWorld, globalEdits }),\r\n    });\r\n\r\n    this.packedSplats = options.packedSplats ?? new PackedSplats();\r\n    this.packedSplats.splatEncoding = options.splatEncoding ?? {\r\n      ...DEFAULT_SPLAT_ENCODING,\r\n    };\r\n    this.numSplats = this.packedSplats.numSplats;\r\n    this.editable = options.editable ?? true;\r\n    this.onFrame = options.onFrame;\r\n\r\n    this.context = context;\r\n    this.objectModifier = options.objectModifier;\r\n    this.worldModifier = options.worldModifier;\r\n\r\n    this.updateGenerator();\r\n\r\n    if (\r\n      options.url ||\r\n      options.fileBytes ||\r\n      options.constructSplats ||\r\n      (options.packedSplats && !options.packedSplats.isInitialized)\r\n    ) {\r\n      // We need to initialize asynchronously given the options\r\n      this.initialized = this.asyncInitialize(options).then(async () => {\r\n        this.updateGenerator();\r\n\r\n        this.isInitialized = true;\r\n        if (options.onLoad) {\r\n          const maybePromise = options.onLoad(this);\r\n          if (maybePromise instanceof Promise) {\r\n            await maybePromise;\r\n          }\r\n        }\r\n        return this;\r\n      });\r\n    } else {\r\n      this.isInitialized = true;\r\n      this.initialized = Promise.resolve(this);\r\n      if (options.onLoad) {\r\n        const maybePromise = options.onLoad(this);\r\n        // If onLoad returns a promise, wait for it to complete\r\n        if (maybePromise instanceof Promise) {\r\n          this.initialized = maybePromise.then(() => this);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.add(createRendererDetectionMesh());\r\n  }\r\n\r\n  async asyncInitialize(options: SplatMeshOptions) {\r\n    const {\r\n      url,\r\n      fileBytes,\r\n      fileType,\r\n      fileName,\r\n      maxSplats,\r\n      constructSplats,\r\n      splatEncoding,\r\n    } = options;\r\n    if (url || fileBytes || constructSplats) {\r\n      const packedSplatsOptions = {\r\n        url,\r\n        fileBytes,\r\n        fileType,\r\n        fileName,\r\n        maxSplats,\r\n        construct: constructSplats,\r\n        splatEncoding,\r\n      };\r\n      this.packedSplats.reinitialize(packedSplatsOptions);\r\n    }\r\n    if (this.packedSplats) {\r\n      await this.packedSplats.initialized;\r\n      this.numSplats = this.packedSplats.numSplats;\r\n      this.updateGenerator();\r\n    }\r\n  }\r\n\r\n  static staticInitialized = SplatMesh.staticInitialize();\r\n  static isStaticInitialized = false;\r\n\r\n  static dynoTime = new DynoFloat({ value: 0 });\r\n\r\n  static async staticInitialize() {\r\n    await init_wasm();\r\n    SplatMesh.isStaticInitialized = true;\r\n  }\r\n\r\n  // Creates a new Gsplat with the provided parameters (all values in \"float\" space,\r\n  // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,\r\n  // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential\r\n  // doubling strategy to fit the new data, so it's fairly efficient to just\r\n  // pushSplat(...) each Gsplat you want to create in a loop.\r\n  pushSplat(\r\n    center: THREE.Vector3,\r\n    scales: THREE.Vector3,\r\n    quaternion: THREE.Quaternion,\r\n    opacity: number,\r\n    color: THREE.Color,\r\n  ) {\r\n    this.packedSplats.pushSplat(center, scales, quaternion, opacity, color);\r\n  }\r\n\r\n  // This method iterates over all Gsplats in this instance's packedSplats,\r\n  // invoking the provided callback with index: number in 0..=(this.numSplats-1) and\r\n  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\r\n  // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).\r\n  // Note that the objects passed in as center etc. are the same for every callback\r\n  // invocation: these objects are reused for efficiency. Changing these values has\r\n  // no effect as they are decoded/unpacked copies of the underlying data. To update\r\n  // the packedSplats, call .packedSplats.setSplat(index, center, scales,\r\n  // quaternion, opacity, color).\r\n  forEachSplat(\r\n    callback: (\r\n      index: number,\r\n      center: THREE.Vector3,\r\n      scales: THREE.Vector3,\r\n      quaternion: THREE.Quaternion,\r\n      opacity: number,\r\n      color: THREE.Color,\r\n    ) => void,\r\n  ) {\r\n    this.packedSplats.forEachSplat(callback);\r\n  }\r\n\r\n  // Call this when you are finished with the SplatMesh and want to free\r\n  // any buffers it holds (via packedSplats).\r\n  dispose() {\r\n    this.packedSplats.dispose();\r\n  }\r\n\r\n  // Returns axis-aligned bounding box of the SplatMesh. If centers_only is true,\r\n  // only the centers of the splats are used to compute the bounding box.\r\n  // IMPORTANT: This should only be called after the SplatMesh is initialized.\r\n  getBoundingBox(centers_only = true) {\r\n    if (!this.initialized) {\r\n      throw new Error(\r\n        \"Cannot get bounding box before SplatMesh is initialized\",\r\n      );\r\n    }\r\n    const minVec = new THREE.Vector3(\r\n      Number.POSITIVE_INFINITY,\r\n      Number.POSITIVE_INFINITY,\r\n      Number.POSITIVE_INFINITY,\r\n    );\r\n    const maxVec = new THREE.Vector3(\r\n      Number.NEGATIVE_INFINITY,\r\n      Number.NEGATIVE_INFINITY,\r\n      Number.NEGATIVE_INFINITY,\r\n    );\r\n    const corners = new THREE.Vector3();\r\n    const signs = [-1, 1];\r\n    this.packedSplats.forEachSplat(\r\n      (_index, center, scales, quaternion, _opacity, _color) => {\r\n        if (centers_only) {\r\n          minVec.min(center);\r\n          maxVec.max(center);\r\n        } else {\r\n          // Get the 8 corners of the AABB in local space\r\n          for (const x of signs) {\r\n            for (const y of signs) {\r\n              for (const z of signs) {\r\n                corners.set(x * scales.x, y * scales.y, z * scales.z);\r\n                // Transform corner by rotation and position\r\n                corners.applyQuaternion(quaternion);\r\n                corners.add(center);\r\n                minVec.min(corners);\r\n                maxVec.max(corners);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      },\r\n    );\r\n    const box = new THREE.Box3(minVec, maxVec);\r\n    return box;\r\n  }\r\n\r\n  constructGenerator(context: SplatMeshContext) {\r\n    const { transform, viewToObject, recolor } = context;\r\n    const generator = dynoBlock(\r\n      { index: \"int\" },\r\n      { gsplat: Gsplat },\r\n      ({ index }) => {\r\n        if (!index) {\r\n          throw new Error(\"index is undefined\");\r\n        }\r\n        // Read a Gsplat from the PackedSplats template\r\n        let gsplat = readPackedSplat(this.packedSplats.dyno, index);\r\n\r\n        if (this.maxSh >= 1) {\r\n          // Inject lighting from SH1..SH3\r\n          const { sh1Texture, sh2Texture, sh3Texture } =\r\n            this.ensureShTextures();\r\n          if (sh1Texture) {\r\n            //Calculate view direction in object space\r\n            const viewCenterInObject = viewToObject.translate;\r\n            const { center } = splitGsplat(gsplat).outputs;\r\n            const viewDir = normalize(sub(center, viewCenterInObject));\r\n\r\n            function rescaleSh(\r\n              sNorm: DynoVal<\"vec3\">,\r\n              minMax: DynoVal<\"vec2\">,\r\n            ) {\r\n              const { x: min, y: max } = split(minMax).outputs;\r\n              const mid = mul(add(min, max), dynoConst(\"float\", 0.5));\r\n              const scale = mul(sub(max, min), dynoConst(\"float\", 0.5));\r\n              return add(mid, mul(sNorm, scale));\r\n            }\r\n\r\n            // Evaluate Spherical Harmonics\r\n            const sh1Snorm = evaluateSH1(gsplat, sh1Texture, viewDir);\r\n            let rgb = rescaleSh(sh1Snorm, this.packedSplats.dynoSh1MinMax);\r\n            if (this.maxSh >= 2 && sh2Texture) {\r\n              const sh2Snorm = evaluateSH2(gsplat, sh2Texture, viewDir);\r\n              rgb = add(\r\n                rgb,\r\n                rescaleSh(sh2Snorm, this.packedSplats.dynoSh2MinMax),\r\n              );\r\n            }\r\n            if (this.maxSh >= 3 && sh3Texture) {\r\n              const sh3Snorm = evaluateSH3(gsplat, sh3Texture, viewDir);\r\n              rgb = add(\r\n                rgb,\r\n                rescaleSh(sh3Snorm, this.packedSplats.dynoSh3MinMax),\r\n              );\r\n            }\r\n\r\n            // Flash off for 0.3 / 1.0 sec for debugging\r\n            // const fractTime = fract(SplatMesh.dynoTime);\r\n            // const lessThan05 = lessThan(fractTime, dynoConst(\"float\", 0.3));\r\n            // rgb = select(lessThan05, dynoConst(\"vec3\", new THREE.Vector3()), rgb);\r\n\r\n            // Add SH lighting to RGBA\r\n            let { rgba } = splitGsplat(gsplat).outputs;\r\n            rgba = add(rgba, extendVec(rgb, dynoConst(\"float\", 0.0)));\r\n            gsplat = combineGsplat({ gsplat, rgba });\r\n          }\r\n        }\r\n\r\n        if (this.splatRgba) {\r\n          // Overwrite RGBA with baked RGBA values\r\n          const rgba = readRgbaArray(this.splatRgba.dyno, index);\r\n          gsplat = combineGsplat({ gsplat, rgba });\r\n        }\r\n\r\n        if (this.skinning) {\r\n          // Transform according to bones + skinning weights\r\n          gsplat = this.skinning.modify(gsplat);\r\n        }\r\n\r\n        if (this.objectModifier) {\r\n          // Inject object-space Gsplat modifier dyno\r\n          gsplat = this.objectModifier.apply({ gsplat }).gsplat;\r\n        }\r\n\r\n        // Transform from object to world-space\r\n        gsplat = transform.applyGsplat(gsplat);\r\n\r\n        // Apply any global recoloring and opacity\r\n        const recolorRgba = mul(recolor, splitGsplat(gsplat).outputs.rgba);\r\n        gsplat = combineGsplat({ gsplat, rgba: recolorRgba });\r\n\r\n        if (this.rgbaDisplaceEdits) {\r\n          // Apply RGBA edit layer SDFs\r\n          gsplat = this.rgbaDisplaceEdits.modify(gsplat);\r\n        }\r\n        if (this.worldModifier) {\r\n          // Inject world-space Gsplat modifier dyno\r\n          gsplat = this.worldModifier.apply({ gsplat }).gsplat;\r\n        }\r\n\r\n        // We're done! Output resulting Gsplat\r\n        return { gsplat };\r\n      },\r\n    );\r\n    this.generator = generator;\r\n  }\r\n\r\n  // Call this whenever something changes in the Gsplat processing pipeline,\r\n  // for example changing maxSh or updating objectModifier or worldModifier.\r\n  // Compiled generators are cached for efficiency and re-use when the same\r\n  // pipeline structure emerges after successive changes.\r\n  updateGenerator() {\r\n    this.constructGenerator(this.context);\r\n  }\r\n\r\n  // This is called automatically by SparkRenderer and you should not have to\r\n  // call it. It updates parameters for the generated pipeline and calls\r\n  // updateGenerator() if the pipeline needs to change.\r\n  update({\r\n    time,\r\n    viewToWorld,\r\n    deltaTime,\r\n    globalEdits,\r\n  }: {\r\n    time: number;\r\n    viewToWorld: THREE.Matrix4;\r\n    deltaTime: number;\r\n    globalEdits: SplatEdit[];\r\n  }) {\r\n    this.numSplats = this.packedSplats.numSplats;\r\n    this.context.time.value = time;\r\n    this.context.deltaTime.value = deltaTime;\r\n    SplatMesh.dynoTime.value = time;\r\n\r\n    const { transform, viewToObject, recolor } = this.context;\r\n    let updated = transform.update(this);\r\n\r\n    if (\r\n      this.context.viewToWorld.updateFromMatrix(viewToWorld) &&\r\n      this.enableViewToWorld\r\n    ) {\r\n      updated = true;\r\n    }\r\n    const worldToView = viewToWorld.clone().invert();\r\n    if (\r\n      this.context.worldToView.updateFromMatrix(worldToView) &&\r\n      this.enableWorldToView\r\n    ) {\r\n      updated = true;\r\n    }\r\n\r\n    const objectToWorld = new THREE.Matrix4().compose(\r\n      transform.translate.value,\r\n      transform.rotate.value,\r\n      new THREE.Vector3().setScalar(transform.scale.value),\r\n    );\r\n    const worldToObject = objectToWorld.invert();\r\n    const viewToObjectMatrix = worldToObject.multiply(viewToWorld);\r\n    if (\r\n      viewToObject.updateFromMatrix(viewToObjectMatrix) &&\r\n      (this.enableViewToObject || this.packedSplats.extra.sh1)\r\n    ) {\r\n      // Only trigger update if we have view-dependent spherical harmonics\r\n      updated = true;\r\n    }\r\n\r\n    const newRecolor = new THREE.Vector4(\r\n      this.recolor.r,\r\n      this.recolor.g,\r\n      this.recolor.b,\r\n      this.opacity,\r\n    );\r\n    if (!newRecolor.equals(recolor.value)) {\r\n      recolor.value.copy(newRecolor);\r\n      updated = true;\r\n    }\r\n\r\n    const edits = this.editable ? (this.edits ?? []).concat(globalEdits) : [];\r\n    if (this.editable && !this.edits) {\r\n      // If we haven't set any explicit edits, add any child SplatEdits\r\n      this.traverseVisible((node) => {\r\n        if (node instanceof SplatEdit) {\r\n          edits.push(node);\r\n        }\r\n      });\r\n    }\r\n\r\n    edits.sort((a, b) => a.ordering - b.ordering);\r\n    const editsSdfs = edits.map((edit) => {\r\n      if (edit.sdfs != null) {\r\n        return { edit, sdfs: edit.sdfs };\r\n      }\r\n      const sdfs: SplatEditSdf[] = [];\r\n      edit.traverseVisible((node) => {\r\n        if (node instanceof SplatEditSdf) {\r\n          sdfs.push(node);\r\n        }\r\n      });\r\n      return { edit, sdfs };\r\n    });\r\n\r\n    if (editsSdfs.length > 0 && !this.rgbaDisplaceEdits) {\r\n      const edits = editsSdfs.length;\r\n      const sdfs = editsSdfs.reduce(\r\n        (total, edit) => total + edit.sdfs.length,\r\n        0,\r\n      );\r\n      this.rgbaDisplaceEdits = new SplatEdits({\r\n        maxEdits: edits,\r\n        maxSdfs: sdfs,\r\n      });\r\n      this.updateGenerator();\r\n    }\r\n    if (this.rgbaDisplaceEdits) {\r\n      const editResult = this.rgbaDisplaceEdits.update(editsSdfs);\r\n      updated ||= editResult.updated;\r\n      if (editResult.dynoUpdated) {\r\n        this.updateGenerator();\r\n      }\r\n    }\r\n\r\n    if (updated) {\r\n      this.updateVersion();\r\n    }\r\n\r\n    this.onFrame?.({ mesh: this, time, deltaTime });\r\n  }\r\n\r\n  // This method conforms to the standard THREE.Raycaster API, performing object-ray\r\n  // intersections using this method to populate the provided intersects[] array\r\n  // with each intersection point.\r\n  raycast(\r\n    raycaster: THREE.Raycaster,\r\n    intersects: {\r\n      distance: number;\r\n      point: THREE.Vector3;\r\n      object: THREE.Object3D;\r\n    }[],\r\n  ) {\r\n    if (!this.packedSplats.packedArray || !this.packedSplats.numSplats) {\r\n      return;\r\n    }\r\n\r\n    const { near, far, ray } = raycaster;\r\n    const worldToMesh = this.matrixWorld.clone().invert();\r\n    const worldToMeshRot = new THREE.Matrix3().setFromMatrix4(worldToMesh);\r\n    const origin = ray.origin.clone().applyMatrix4(worldToMesh);\r\n    const direction = ray.direction.clone().applyMatrix3(worldToMeshRot);\r\n    const scales = new THREE.Vector3();\r\n    worldToMesh.decompose(new THREE.Vector3(), new THREE.Quaternion(), scales);\r\n    const scale = (scales.x * scales.y * scales.z) ** (1.0 / 3.0);\r\n\r\n    const RAYCAST_ELLIPSOID = true;\r\n    const distances = raycast_splats(\r\n      origin.x,\r\n      origin.y,\r\n      origin.z,\r\n      direction.x,\r\n      direction.y,\r\n      direction.z,\r\n      near,\r\n      far,\r\n      this.packedSplats.numSplats,\r\n      this.packedSplats.packedArray,\r\n      RAYCAST_ELLIPSOID,\r\n      this.packedSplats.splatEncoding?.lnScaleMin ?? LN_SCALE_MIN,\r\n      this.packedSplats.splatEncoding?.lnScaleMax ?? LN_SCALE_MAX,\r\n    );\r\n\r\n    for (const distance of distances) {\r\n      const point = ray.direction\r\n        .clone()\r\n        .multiplyScalar(distance)\r\n        .add(ray.origin);\r\n      intersects.push({\r\n        distance,\r\n        point,\r\n        object: this,\r\n      });\r\n    }\r\n  }\r\n\r\n  private ensureShTextures(): {\r\n    sh1Texture?: DynoUsampler2DArray<\"sh1\", THREE.DataArrayTexture>;\r\n    sh2Texture?: DynoUsampler2DArray<\"sh2\", THREE.DataArrayTexture>;\r\n    sh3Texture?: DynoUsampler2DArray<\"sh3\", THREE.DataArrayTexture>;\r\n  } {\r\n    // Ensure we have textures for SH1..SH3 if we have data\r\n    if (!this.packedSplats.extra.sh1) {\r\n      return {};\r\n    }\r\n\r\n    let sh1Texture = this.packedSplats.extra.sh1Texture as\r\n      | DynoUsampler2DArray<\"sh1\", THREE.DataArrayTexture>\r\n      | undefined;\r\n    if (!sh1Texture) {\r\n      let sh1 = this.packedSplats.extra.sh1 as Uint32Array;\r\n      const { width, height, depth, maxSplats } = getTextureSize(\r\n        sh1.length / 2,\r\n      );\r\n      if (sh1.length < maxSplats * 2) {\r\n        const newSh1 = new Uint32Array(maxSplats * 2);\r\n        newSh1.set(sh1);\r\n        this.packedSplats.extra.sh1 = newSh1;\r\n        sh1 = newSh1;\r\n      }\r\n\r\n      const texture = new THREE.DataArrayTexture(sh1, width, height, depth);\r\n      texture.format = THREE.RGIntegerFormat;\r\n      texture.type = THREE.UnsignedIntType;\r\n      texture.internalFormat = \"RG32UI\";\r\n      texture.needsUpdate = true;\r\n\r\n      sh1Texture = new DynoUsampler2DArray({\r\n        value: texture,\r\n        key: \"sh1\",\r\n      });\r\n      this.packedSplats.extra.sh1Texture = sh1Texture;\r\n    }\r\n\r\n    if (!this.packedSplats.extra.sh2) {\r\n      return { sh1Texture };\r\n    }\r\n\r\n    let sh2Texture = this.packedSplats.extra.sh2Texture as\r\n      | DynoUsampler2DArray<\"sh2\", THREE.DataArrayTexture>\r\n      | undefined;\r\n    if (!sh2Texture) {\r\n      let sh2 = this.packedSplats.extra.sh2 as Uint32Array;\r\n      const { width, height, depth, maxSplats } = getTextureSize(\r\n        sh2.length / 4,\r\n      );\r\n      if (sh2.length < maxSplats * 4) {\r\n        const newSh2 = new Uint32Array(maxSplats * 4);\r\n        newSh2.set(sh2);\r\n        this.packedSplats.extra.sh2 = newSh2;\r\n        sh2 = newSh2;\r\n      }\r\n\r\n      const texture = new THREE.DataArrayTexture(sh2, width, height, depth);\r\n      texture.format = THREE.RGBAIntegerFormat;\r\n      texture.type = THREE.UnsignedIntType;\r\n      texture.internalFormat = \"RGBA32UI\";\r\n      texture.needsUpdate = true;\r\n\r\n      sh2Texture = new DynoUsampler2DArray({\r\n        value: texture,\r\n        key: \"sh2\",\r\n      });\r\n      this.packedSplats.extra.sh2Texture = sh2Texture;\r\n    }\r\n\r\n    if (!this.packedSplats.extra.sh3) {\r\n      return { sh1Texture, sh2Texture };\r\n    }\r\n\r\n    let sh3Texture = this.packedSplats.extra.sh3Texture as\r\n      | DynoUsampler2DArray<\"sh3\", THREE.DataArrayTexture>\r\n      | undefined;\r\n    if (!sh3Texture) {\r\n      let sh3 = this.packedSplats.extra.sh3 as Uint32Array;\r\n      const { width, height, depth, maxSplats } = getTextureSize(\r\n        sh3.length / 4,\r\n      );\r\n      if (sh3.length < maxSplats * 4) {\r\n        const newSh3 = new Uint32Array(maxSplats * 4);\r\n        newSh3.set(sh3);\r\n        this.packedSplats.extra.sh3 = newSh3;\r\n        sh3 = newSh3;\r\n      }\r\n\r\n      const texture = new THREE.DataArrayTexture(sh3, width, height, depth);\r\n      texture.format = THREE.RGBAIntegerFormat;\r\n      texture.type = THREE.UnsignedIntType;\r\n      texture.internalFormat = \"RGBA32UI\";\r\n      texture.needsUpdate = true;\r\n\r\n      sh3Texture = new DynoUsampler2DArray({\r\n        value: texture,\r\n        key: \"sh3\",\r\n      });\r\n      this.packedSplats.extra.sh3Texture = sh3Texture;\r\n    }\r\n\r\n    return { sh1Texture, sh2Texture, sh3Texture };\r\n  }\r\n}\r\n\r\nconst defineEvaluateSH1 = unindent(`\r\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\r\n    // Extract sint7 values packed into 2 x uint32\r\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\r\n    vec3 sh1_0 = vec3(ivec3(\r\n      int(packed.x << 25u) >> 25,\r\n      int(packed.x << 18u) >> 25,\r\n      int(packed.x << 11u) >> 25\r\n    )) / 63.0;\r\n    vec3 sh1_1 = vec3(ivec3(\r\n      int(packed.x << 4u) >> 25,\r\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\r\n      int(packed.y << 22u) >> 25\r\n    )) / 63.0;\r\n    vec3 sh1_2 = vec3(ivec3(\r\n      int(packed.y << 15u) >> 25,\r\n      int(packed.y << 8u) >> 25,\r\n      int(packed.y << 1u) >> 25\r\n    )) / 63.0;\r\n\r\n    return sh1_0 * (-0.4886025 * viewDir.y)\r\n      + sh1_1 * (0.4886025 * viewDir.z)\r\n      + sh1_2 * (-0.4886025 * viewDir.x);\r\n  }\r\n`);\r\n\r\nconst defineEvaluateSH2 = unindent(`\r\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\r\n    // Extract sint8 values packed into 4 x uint32\r\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\r\n    vec3 sh2_0 = vec3(ivec3(\r\n      int(packed.x << 24u) >> 24,\r\n      int(packed.x << 16u) >> 24,\r\n      int(packed.x << 8u) >> 24\r\n    )) / 127.0;\r\n    vec3 sh2_1 = vec3(ivec3(\r\n      int(packed.x) >> 24,\r\n      int(packed.y << 24u) >> 24,\r\n      int(packed.y << 16u) >> 24\r\n    )) / 127.0;\r\n    vec3 sh2_2 = vec3(ivec3(\r\n      int(packed.y << 8u) >> 24,\r\n      int(packed.y) >> 24,\r\n      int(packed.z << 24u) >> 24\r\n    )) / 127.0;\r\n    vec3 sh2_3 = vec3(ivec3(\r\n      int(packed.z << 16u) >> 24,\r\n      int(packed.z << 8u) >> 24,\r\n      int(packed.z) >> 24\r\n    )) / 127.0;\r\n    vec3 sh2_4 = vec3(ivec3(\r\n      int(packed.w << 24u) >> 24,\r\n      int(packed.w << 16u) >> 24,\r\n      int(packed.w << 8u) >> 24\r\n    )) / 127.0;\r\n\r\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\r\n      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)\r\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\r\n      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)\r\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\r\n  }\r\n`);\r\n\r\nconst defineEvaluateSH3 = unindent(`\r\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\r\n    // Extract sint6 values packed into 4 x uint32\r\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\r\n    vec3 sh3_0 = vec3(ivec3(\r\n      int(packed.x << 26u) >> 26,\r\n      int(packed.x << 20u) >> 26,\r\n      int(packed.x << 14u) >> 26\r\n    )) / 31.0;\r\n    vec3 sh3_1 = vec3(ivec3(\r\n      int(packed.x << 8u) >> 26,\r\n      int(packed.x << 2u) >> 26,\r\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\r\n    )) / 31.0;\r\n    vec3 sh3_2 = vec3(ivec3(\r\n      int(packed.y << 22u) >> 26,\r\n      int(packed.y << 16u) >> 26,\r\n      int(packed.y << 10u) >> 26\r\n    )) / 31.0;\r\n    vec3 sh3_3 = vec3(ivec3(\r\n      int(packed.y << 4u) >> 26,\r\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\r\n      int(packed.z << 24u) >> 26\r\n    )) / 31.0;\r\n    vec3 sh3_4 = vec3(ivec3(\r\n      int(packed.z << 18u) >> 26,\r\n      int(packed.z << 12u) >> 26,\r\n      int(packed.z << 6u) >> 26\r\n    )) / 31.0;\r\n    vec3 sh3_5 = vec3(ivec3(\r\n      int(packed.z) >> 26,\r\n      int(packed.w << 26u) >> 26,\r\n      int(packed.w << 20u) >> 26\r\n    )) / 31.0;\r\n    vec3 sh3_6 = vec3(ivec3(\r\n      int(packed.w << 14u) >> 26,\r\n      int(packed.w << 8u) >> 26,\r\n      int(packed.w << 2u) >> 26\r\n    )) / 31.0;\r\n\r\n    float xx = viewDir.x * viewDir.x;\r\n    float yy = viewDir.y * viewDir.y;\r\n    float zz = viewDir.z * viewDir.z;\r\n    float xy = viewDir.x * viewDir.y;\r\n    float yz = viewDir.y * viewDir.z;\r\n    float zx = viewDir.z * viewDir.x;\r\n\r\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\r\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\r\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\r\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\r\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\r\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\r\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\r\n  }\r\n`);\r\n\r\nexport function evaluateSH1(\r\n  gsplat: DynoVal<typeof Gsplat>,\r\n  sh1: DynoUsampler2DArray<\"sh1\", THREE.DataArrayTexture>,\r\n  viewDir: DynoVal<\"vec3\">,\r\n): DynoVal<\"vec3\"> {\r\n  return dyno({\r\n    inTypes: { gsplat: Gsplat, sh1: \"usampler2DArray\", viewDir: \"vec3\" },\r\n    outTypes: { rgb: \"vec3\" },\r\n    inputs: { gsplat, sh1, viewDir },\r\n    globals: () => [defineGsplat, defineEvaluateSH1],\r\n    statements: ({ inputs, outputs }) => {\r\n      const statements = unindentLines(`\r\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\r\n          ${outputs.rgb} = evaluateSH1(${inputs.gsplat}, ${inputs.sh1}, ${inputs.viewDir});\r\n        } else {\r\n          ${outputs.rgb} = vec3(0.0);\r\n        }\r\n      `);\r\n      return statements;\r\n    },\r\n  }).outputs.rgb;\r\n}\r\n\r\nexport function evaluateSH2(\r\n  gsplat: DynoVal<typeof Gsplat>,\r\n  sh2: DynoVal<\"usampler2DArray\">,\r\n  viewDir: DynoVal<\"vec3\">,\r\n): DynoVal<\"vec3\"> {\r\n  return dyno({\r\n    inTypes: { gsplat: Gsplat, sh2: \"usampler2DArray\", viewDir: \"vec3\" },\r\n    outTypes: { rgb: \"vec3\" },\r\n    inputs: { gsplat, sh2, viewDir },\r\n    globals: () => [defineGsplat, defineEvaluateSH2],\r\n    statements: ({ inputs, outputs }) =>\r\n      unindentLines(`\r\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\r\n          ${outputs.rgb} = evaluateSH2(${inputs.gsplat}, ${inputs.sh2}, ${inputs.viewDir});\r\n        } else {\r\n          ${outputs.rgb} = vec3(0.0);\r\n        }\r\n      `),\r\n  }).outputs.rgb;\r\n}\r\n\r\nexport function evaluateSH3(\r\n  gsplat: DynoVal<typeof Gsplat>,\r\n  sh3: DynoVal<\"usampler2DArray\">,\r\n  viewDir: DynoVal<\"vec3\">,\r\n): DynoVal<\"vec3\"> {\r\n  return dyno({\r\n    inTypes: { gsplat: Gsplat, sh3: \"usampler2DArray\", viewDir: \"vec3\" },\r\n    outTypes: { rgb: \"vec3\" },\r\n    inputs: { gsplat, sh3, viewDir },\r\n    globals: () => [defineGsplat, defineEvaluateSH3],\r\n    statements: ({ inputs, outputs }) =>\r\n      unindentLines(`\r\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\r\n          ${outputs.rgb} = evaluateSH3(${inputs.gsplat}, ${inputs.sh3}, ${inputs.viewDir});\r\n        } else {\r\n          ${outputs.rgb} = vec3(0.0);\r\n        }\r\n      `),\r\n  }).outputs.rgb;\r\n}\r\n\r\nconst EMPTY_GEOMETRY = new THREE.BufferGeometry();\r\nconst EMPTY_MATERIAL = new THREE.ShaderMaterial();\r\n\r\n// Creates an empty mesh to hook into Three.js rendering.\r\n// This is used to detect if a SparkRenderer is present in the scene.\r\n// If not, one will be injected automatically.\r\nfunction createRendererDetectionMesh(): THREE.Mesh {\r\n  const mesh = new THREE.Mesh(EMPTY_GEOMETRY, EMPTY_MATERIAL);\r\n  mesh.frustumCulled = false;\r\n  mesh.onBeforeRender = function (renderer, scene) {\r\n    if (!scene.isScene) {\r\n      // The SplatMesh is part of render call that doesn't have a Scene at its root\r\n      // Don't auto-inject a renderer.\r\n      this.removeFromParent();\r\n      return;\r\n    }\r\n\r\n    // Check if the scene has a SparkRenderer instance\r\n    let hasSparkRenderer = false;\r\n    scene.traverse((c) => {\r\n      if (c instanceof SparkRenderer) {\r\n        hasSparkRenderer = true;\r\n      }\r\n    });\r\n\r\n    if (!hasSparkRenderer) {\r\n      // No spark renderer present in the scene, inject one.\r\n      scene.add(new SparkRenderer({ renderer }));\r\n    }\r\n\r\n    // Remove mesh to stop checking\r\n    this.removeFromParent();\r\n  };\r\n  return mesh;\r\n}\r\n","// PLY file format reader\r\n\r\nimport { USE_COMPILED_PARSER_FUNCTION } from \"./defines\";\r\n\r\nconst PLY_PROPERTY_TYPES = [\r\n  \"char\",\r\n  \"uchar\",\r\n  \"short\",\r\n  \"ushort\",\r\n  \"int\",\r\n  \"uint\",\r\n  \"float\",\r\n  \"double\",\r\n] as const;\r\nexport type PlyPropertyType = (typeof PLY_PROPERTY_TYPES)[number];\r\n\r\nexport type PlyElement = {\r\n  name: string;\r\n  count: number;\r\n  properties: Record<string, PlyProperty>;\r\n};\r\n\r\nexport type PlyProperty = {\r\n  isList: boolean;\r\n  type: PlyPropertyType;\r\n  countType?: PlyPropertyType;\r\n};\r\n\r\n// Callback for parseSplats base Gsplat data\r\nexport type SplatCallback = (\r\n  index: number,\r\n  x: number,\r\n  y: number,\r\n  z: number,\r\n  scaleX: number,\r\n  scaleY: number,\r\n  scaleZ: number,\r\n  quatX: number,\r\n  quatY: number,\r\n  quatZ: number,\r\n  quatW: number,\r\n  opacity: number,\r\n  r: number,\r\n  g: number,\r\n  b: number,\r\n) => void;\r\n\r\n// Callback for parseSplats SH coefficients\r\nexport type SplatShCallback = (\r\n  index: number,\r\n  sh1: Float32Array,\r\n  sh2?: Float32Array,\r\n  sh3?: Float32Array,\r\n) => void;\r\n\r\n// A PlyReader is used to parse PLY files for Gsplat data.\r\n// It takes a Uint8Array/ArrayBuffer as input fileBytes, parses the text header,\r\n// and provides a method parseData to iterate over the entire binary data\r\n// efficiently, or parseSplats to iterate over Gsplat data.\r\n\r\nexport class PlyReader {\r\n  fileBytes: Uint8Array;\r\n  header = \"\";\r\n  littleEndian = true;\r\n  elements: Record<string, PlyElement> = {};\r\n  comments: string[] = [];\r\n  data: DataView | null = null;\r\n  static defaultPointScale = 0.001;\r\n\r\n  numSplats = 0;\r\n\r\n  // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\r\n  constructor({ fileBytes }: { fileBytes: Uint8Array | ArrayBuffer }) {\r\n    this.fileBytes =\r\n      fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\r\n  }\r\n\r\n  // Identify and parse the PLY text header (assumed to be <64KB in size).\r\n  // this.elements will contain all the elements in the file, typically\r\n  // \"vertex\" contains the Gsplat data.\r\n  async parseHeader() {\r\n    const bufferStream = new ReadableStream({\r\n      start: (controller: ReadableStreamController<Uint8Array>) => {\r\n        // Assume the header is less than 64KB\r\n        controller.enqueue(this.fileBytes.slice(0, 65536));\r\n        controller.close();\r\n      },\r\n    });\r\n    const decoder = bufferStream\r\n      .pipeThrough(new TextDecoderStream())\r\n      .getReader();\r\n\r\n    // Find the end of the text section of the PLY file\r\n    this.header = \"\";\r\n    const headerTerminator = \"end_header\\n\";\r\n    while (true) {\r\n      const { value, done } = await decoder.read();\r\n      if (done) {\r\n        throw new Error(\"Failed to read header\");\r\n      }\r\n\r\n      this.header += value as string;\r\n      const endHeader = this.header.indexOf(headerTerminator);\r\n      if (endHeader >= 0) {\r\n        this.header = this.header.slice(0, endHeader + headerTerminator.length);\r\n        break;\r\n      }\r\n    }\r\n    // Partition the file into header and binary data\r\n    const headerLen = new TextEncoder().encode(this.header).length;\r\n    this.data = new DataView(this.fileBytes.buffer, headerLen);\r\n\r\n    this.elements = {};\r\n    let curElement: PlyElement | null = null;\r\n    this.comments = [];\r\n\r\n    this.header\r\n      .trim()\r\n      .split(\"\\n\")\r\n      .forEach((line: string, lineIndex: number) => {\r\n        const trimmedLine = line.trim();\r\n        if (lineIndex === 0) {\r\n          if (trimmedLine !== \"ply\") {\r\n            throw new Error(\"Invalid PLY header\");\r\n          }\r\n          return;\r\n        }\r\n        if (trimmedLine.length === 0) {\r\n          return; // Skip empty lines\r\n        }\r\n\r\n        const fields = trimmedLine.split(\" \");\r\n        switch (fields[0]) {\r\n          case \"format\":\r\n            if (fields[1] === \"binary_little_endian\") {\r\n              this.littleEndian = true;\r\n            } else if (fields[1] === \"binary_big_endian\") {\r\n              this.littleEndian = false;\r\n            } else {\r\n              // ascii formats not supported\r\n              throw new Error(`Unsupported PLY format: ${fields[1]}`);\r\n            }\r\n            if (fields[2] !== \"1.0\") {\r\n              throw new Error(`Unsupported PLY version: ${fields[2]}`);\r\n            }\r\n            break;\r\n          case \"end_header\":\r\n            break;\r\n          case \"comment\":\r\n            this.comments.push(trimmedLine.slice(\"comment \".length));\r\n            break;\r\n          case \"element\": {\r\n            const name = fields[1];\r\n            curElement = {\r\n              name,\r\n              count: Number.parseInt(fields[2]),\r\n              properties: {},\r\n            };\r\n            this.elements[name] = curElement;\r\n            break;\r\n          }\r\n          case \"property\":\r\n            if (curElement == null) {\r\n              throw new Error(\"Property must be inside an element\");\r\n            }\r\n            if (fields[1] === \"list\") {\r\n              curElement.properties[fields[4]] = {\r\n                isList: true,\r\n                type: fields[3] as PlyPropertyType,\r\n                countType: fields[2] as PlyPropertyType,\r\n              };\r\n            } else {\r\n              curElement.properties[fields[2]] = {\r\n                isList: false,\r\n                type: fields[1] as PlyPropertyType,\r\n              };\r\n            }\r\n            break;\r\n          default:\r\n          // console.warn(`Skipping unsupported PLY keyword: ${fields[0]}`);\r\n        }\r\n      });\r\n\r\n    if (this.elements.vertex) {\r\n      this.numSplats = this.elements.vertex.count;\r\n    }\r\n  }\r\n\r\n  parseData(\r\n    elementCallback: (\r\n      element: PlyElement,\r\n    ) =>\r\n      | null\r\n      | ((index: number, item: Record<string, number | number[]>) => void),\r\n  ) {\r\n    // Go through the entire binary data of the PLY file, starting at offset 0\r\n    let offset = 0;\r\n    const data = this.data;\r\n    if (data == null) {\r\n      throw new Error(\"No data to parse\");\r\n    }\r\n\r\n    for (const elementName in this.elements) {\r\n      const element = this.elements[elementName];\r\n      const { count, properties } = element;\r\n      const item = createEmptyItem(properties);\r\n      // Construct a parse function\r\n      const parseFn = createParseFn(properties, this.littleEndian);\r\n\r\n      // Parse all the items in the element\r\n      const callback = elementCallback(element) ?? (() => {});\r\n      for (let index = 0; index < count; index++) {\r\n        offset = parseFn(data, offset, item);\r\n        callback(index, item);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Parse all the Gsplat data in the PLY file in go, invoking the given\r\n  // callbacks for each Gsplat.\r\n  parseSplats(splatCallback: SplatCallback, shCallback?: SplatShCallback) {\r\n    if (this.elements.vertex == null) {\r\n      throw new Error(\"No vertex element found\");\r\n    }\r\n\r\n    let isSuperSplat = false;\r\n    const ssChunks: SSChunk[] = [];\r\n\r\n    let numSh = 0;\r\n    let sh1Props: number[] = [];\r\n    let sh2Props: number[] = [];\r\n    let sh3Props: number[] = [];\r\n    let sh1: Float32Array | undefined = undefined;\r\n    let sh2: Float32Array | undefined = undefined;\r\n    let sh3: Float32Array | undefined = undefined;\r\n\r\n    function prepareSh() {\r\n      // Prepare SH coefficient names and arrays for numSh total SH levels\r\n      const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\r\n      sh1Props = new Array(3)\r\n        .fill(null)\r\n        .flatMap((_, k) => [0, 1, 2].map((_, d) => k + (d * num_f_rest) / 3));\r\n      sh2Props = new Array(5)\r\n        .fill(null)\r\n        .flatMap((_, k) =>\r\n          [0, 1, 2].map((_, d) => 3 + k + (d * num_f_rest) / 3),\r\n        );\r\n      sh3Props = new Array(7)\r\n        .fill(null)\r\n        .flatMap((_, k) =>\r\n          [0, 1, 2].map((_, d) => 8 + k + (d * num_f_rest) / 3),\r\n        );\r\n      sh1 = numSh >= 1 ? new Float32Array(3 * 3) : undefined;\r\n      sh2 = numSh >= 2 ? new Float32Array(5 * 3) : undefined;\r\n      sh3 = numSh >= 3 ? new Float32Array(7 * 3) : undefined;\r\n    }\r\n\r\n    function ssShCallback(\r\n      index: number,\r\n      item: Record<string, number | number[]>,\r\n    ) {\r\n      // Decode SH for SuperSplat compressed data\r\n      if (!sh1) {\r\n        throw new Error(\"Missing sh1\");\r\n      }\r\n      const sh = item.f_rest as number[];\r\n\r\n      for (let i = 0; i < sh1Props.length; i++) {\r\n        sh1[i] = (sh[sh1Props[i]] * 8) / 255 - 4;\r\n      }\r\n      if (sh2) {\r\n        for (let i = 0; i < sh2Props.length; i++) {\r\n          sh2[i] = (sh[sh2Props[i]] * 8) / 255 - 4;\r\n        }\r\n      }\r\n      if (sh3) {\r\n        for (let i = 0; i < sh3Props.length; i++) {\r\n          sh3[i] = (sh[sh3Props[i]] * 8) / 255 - 4;\r\n        }\r\n      }\r\n      shCallback?.(index, sh1, sh2, sh3);\r\n    }\r\n\r\n    function initSuperSplat(element: PlyElement) {\r\n      const {\r\n        min_x,\r\n        min_y,\r\n        min_z,\r\n        max_x,\r\n        max_y,\r\n        max_z,\r\n        min_scale_x,\r\n        min_scale_y,\r\n        min_scale_z,\r\n        max_scale_x,\r\n        max_scale_y,\r\n        max_scale_z,\r\n      } = element.properties;\r\n      if (\r\n        !min_x ||\r\n        !min_y ||\r\n        !min_z ||\r\n        !max_x ||\r\n        !max_y ||\r\n        !max_z ||\r\n        !min_scale_x ||\r\n        !min_scale_y ||\r\n        !min_scale_z ||\r\n        !max_scale_x ||\r\n        !max_scale_y ||\r\n        !max_scale_z\r\n      ) {\r\n        throw new Error(\"Missing PLY chunk properties\");\r\n      }\r\n\r\n      // SuperSplat chunks are used to quantize splat data, so we need to store them\r\n      isSuperSplat = true;\r\n      return (index: number, item: Record<string, number | number[]>) => {\r\n        const {\r\n          min_x,\r\n          min_y,\r\n          min_z,\r\n          max_x,\r\n          max_y,\r\n          max_z,\r\n          min_scale_x,\r\n          min_scale_y,\r\n          min_scale_z,\r\n          max_scale_x,\r\n          max_scale_y,\r\n          max_scale_z,\r\n          min_r,\r\n          min_g,\r\n          min_b,\r\n          max_r,\r\n          max_g,\r\n          max_b,\r\n        } = item as Record<string, number>;\r\n        ssChunks.push({\r\n          min_x,\r\n          min_y,\r\n          min_z,\r\n          max_x,\r\n          max_y,\r\n          max_z,\r\n          min_scale_x,\r\n          min_scale_y,\r\n          min_scale_z,\r\n          max_scale_x,\r\n          max_scale_y,\r\n          max_scale_z,\r\n          min_r,\r\n          min_g,\r\n          min_b,\r\n          max_r,\r\n          max_g,\r\n          max_b,\r\n        });\r\n      };\r\n    }\r\n\r\n    function decodeSuperSplat(element: PlyElement) {\r\n      // Decode SuperSplat compressed data in vertex and sh elements\r\n      if (shCallback && element.name === \"sh\") {\r\n        numSh = getNumSh(element.properties);\r\n        prepareSh();\r\n        return ssShCallback;\r\n      }\r\n      if (element.name !== \"vertex\") {\r\n        return null;\r\n      }\r\n\r\n      const { packed_position, packed_rotation, packed_scale, packed_color } =\r\n        element.properties;\r\n      if (\r\n        !packed_position ||\r\n        !packed_rotation ||\r\n        !packed_scale ||\r\n        !packed_color\r\n      ) {\r\n        throw new Error(\r\n          \"Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color\",\r\n        );\r\n      }\r\n\r\n      const SQRT2 = Math.sqrt(2);\r\n\r\n      return (index: number, item: Record<string, number | number[]>) => {\r\n        // SuperSplat data are quantized within chunks with 256 Gsplats each\r\n        const chunk = ssChunks[index >>> 8];\r\n        if (chunk == null) {\r\n          throw new Error(\"Missing PLY chunk\");\r\n        }\r\n        const {\r\n          min_x,\r\n          min_y,\r\n          min_z,\r\n          max_x,\r\n          max_y,\r\n          max_z,\r\n          min_scale_x,\r\n          min_scale_y,\r\n          min_scale_z,\r\n          max_scale_x,\r\n          max_scale_y,\r\n          max_scale_z,\r\n          min_r,\r\n          min_g,\r\n          min_b,\r\n          max_r,\r\n          max_g,\r\n          max_b,\r\n        } = chunk;\r\n        const { packed_position, packed_rotation, packed_scale, packed_color } =\r\n          item as Record<string, number>;\r\n\r\n        const x =\r\n          (((packed_position >>> 21) & 2047) / 2047) * (max_x - min_x) + min_x;\r\n        const y =\r\n          (((packed_position >>> 11) & 1023) / 1023) * (max_y - min_y) + min_y;\r\n        const z = ((packed_position & 2047) / 2047) * (max_z - min_z) + min_z;\r\n\r\n        const r0 = (((packed_rotation >>> 20) & 1023) / 1023 - 0.5) * SQRT2;\r\n        const r1 = (((packed_rotation >>> 10) & 1023) / 1023 - 0.5) * SQRT2;\r\n        const r2 = ((packed_rotation & 1023) / 1023 - 0.5) * SQRT2;\r\n        const rr = Math.sqrt(Math.max(0, 1.0 - r0 * r0 - r1 * r1 - r2 * r2));\r\n\r\n        const rOrder = packed_rotation >>> 30;\r\n        const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\r\n        const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\r\n        const quatZ = rOrder <= 2 ? r2 : rr;\r\n        const quatW = rOrder === 0 ? rr : r0;\r\n\r\n        const scaleX = Math.exp(\r\n          (((packed_scale >>> 21) & 2047) / 2047) *\r\n            (max_scale_x - min_scale_x) +\r\n            min_scale_x,\r\n        );\r\n        const scaleY = Math.exp(\r\n          (((packed_scale >>> 11) & 1023) / 1023) *\r\n            (max_scale_y - min_scale_y) +\r\n            min_scale_y,\r\n        );\r\n        const scaleZ = Math.exp(\r\n          ((packed_scale & 2047) / 2047) * (max_scale_z - min_scale_z) +\r\n            min_scale_z,\r\n        );\r\n\r\n        const r =\r\n          (((packed_color >>> 24) & 255) / 255) *\r\n            ((max_r ?? 1) - (min_r ?? 0)) +\r\n          (min_r ?? 0);\r\n        const g =\r\n          (((packed_color >>> 16) & 255) / 255) *\r\n            ((max_g ?? 1) - (min_g ?? 0)) +\r\n          (min_g ?? 0);\r\n        const b =\r\n          (((packed_color >>> 8) & 255) / 255) * ((max_b ?? 1) - (min_b ?? 0)) +\r\n          (min_b ?? 0);\r\n        const opacity = (packed_color & 255) / 255;\r\n\r\n        splatCallback(\r\n          index,\r\n          x,\r\n          y,\r\n          z,\r\n          scaleX,\r\n          scaleY,\r\n          scaleZ,\r\n          quatX,\r\n          quatY,\r\n          quatZ,\r\n          quatW,\r\n          opacity,\r\n          r,\r\n          g,\r\n          b,\r\n        );\r\n      };\r\n    }\r\n\r\n    const elementCallback = (element: PlyElement) => {\r\n      if (element.name === \"chunk\") {\r\n        // \"chunk\" could conceivably be used for other formats, and we would\r\n        // ideally check for the comment: Generated by SuperSplat 2.*\r\n        // but gsplat also outputs this format without such a comment.\r\n        // In order to support both, let's assume a \"chunk\" element should\r\n        // be interpreted as this format.\r\n        return initSuperSplat(element);\r\n      }\r\n      if (isSuperSplat) {\r\n        return decodeSuperSplat(element);\r\n      }\r\n\r\n      if (element.name !== \"vertex\") {\r\n        return null;\r\n      }\r\n\r\n      const {\r\n        x,\r\n        y,\r\n        z,\r\n        scale_0,\r\n        scale_1,\r\n        scale_2,\r\n        rot_0,\r\n        rot_1,\r\n        rot_2,\r\n        rot_3,\r\n        opacity,\r\n        f_dc_0,\r\n        f_dc_1,\r\n        f_dc_2,\r\n        red,\r\n        green,\r\n        blue,\r\n        alpha,\r\n      } = element.properties;\r\n\r\n      if (!x || !y || !z) {\r\n        throw new Error(\"Missing PLY properties: x, y, z\");\r\n      }\r\n      // Pure point cloud PLY files have no scales or rotations\r\n      const hasScales = scale_0 && scale_1 && scale_2;\r\n      const hasRots = rot_0 && rot_1 && rot_2 && rot_3;\r\n      // Quantization scale factor for argb values\r\n      const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;\r\n      const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\r\n      const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\r\n      const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\r\n\r\n      numSh = getNumSh(element.properties);\r\n      prepareSh();\r\n\r\n      return (index: number, item: Record<string, number | number[]>) => {\r\n        const scaleX = hasScales\r\n          ? Math.exp(item.scale_0 as number)\r\n          : PlyReader.defaultPointScale;\r\n        const scaleY = hasScales\r\n          ? Math.exp(item.scale_1 as number)\r\n          : PlyReader.defaultPointScale;\r\n        const scaleZ = hasScales\r\n          ? Math.exp(item.scale_2 as number)\r\n          : PlyReader.defaultPointScale;\r\n\r\n        const quatX = hasRots ? (item.rot_1 as number) : 0;\r\n        const quatY = hasRots ? (item.rot_2 as number) : 0;\r\n        const quatZ = hasRots ? (item.rot_3 as number) : 0;\r\n        const quatW = hasRots ? (item.rot_0 as number) : 1;\r\n\r\n        const op =\r\n          opacity != null\r\n            ? 1.0 / (1.0 + Math.exp(-item.opacity as number))\r\n            : alpha != null\r\n              ? (item.alpha as number) / alphaDiv\r\n              : 1.0;\r\n        const r =\r\n          f_dc_0 != null\r\n            ? (item.f_dc_0 as number) * SH_C0 + 0.5\r\n            : red != null\r\n              ? (item.red as number) / redDiv\r\n              : 1.0;\r\n        const g =\r\n          f_dc_1 != null\r\n            ? (item.f_dc_1 as number) * SH_C0 + 0.5\r\n            : green != null\r\n              ? (item.green as number) / greenDiv\r\n              : 1.0;\r\n        const b =\r\n          f_dc_2 != null\r\n            ? (item.f_dc_2 as number) * SH_C0 + 0.5\r\n            : blue != null\r\n              ? (item.blue as number) / blueDiv\r\n              : 1.0;\r\n\r\n        splatCallback(\r\n          index,\r\n          item.x as number,\r\n          item.y as number,\r\n          item.z as number,\r\n          scaleX,\r\n          scaleY,\r\n          scaleZ,\r\n          quatX,\r\n          quatY,\r\n          quatZ,\r\n          quatW,\r\n          op,\r\n          r,\r\n          g,\r\n          b,\r\n        );\r\n\r\n        if (shCallback && sh1) {\r\n          const sh = item.f_rest as number[];\r\n          if (sh1) {\r\n            for (let i = 0; i < sh1Props.length; i++) {\r\n              sh1[i] = sh[sh1Props[i]];\r\n            }\r\n          }\r\n          if (sh2) {\r\n            for (let i = 0; i < sh2Props.length; i++) {\r\n              sh2[i] = sh[sh2Props[i]];\r\n            }\r\n          }\r\n          if (sh3) {\r\n            for (let i = 0; i < sh3Props.length; i++) {\r\n              sh3[i] = sh[sh3Props[i]];\r\n            }\r\n          }\r\n          shCallback(index, sh1, sh2, sh3);\r\n        }\r\n      };\r\n    };\r\n\r\n    this.parseData(elementCallback);\r\n  }\r\n\r\n  // Inject RGBA values into original PLY file, which can be used to modify\r\n  // the color/opacity of the Gsplats and write out the modified PLY file.\r\n  injectRgba(rgba: Uint8Array) {\r\n    // Go through the entire binary data of the PLY file, starting at offset 0\r\n    let offset = 0;\r\n    const data = this.data;\r\n    if (data == null) {\r\n      throw new Error(\"No parsed data\");\r\n    }\r\n    if (rgba.length !== this.numSplats * 4) {\r\n      throw new Error(\"Invalid RGBA array length\");\r\n    }\r\n\r\n    for (const elementName in this.elements) {\r\n      const element = this.elements[elementName];\r\n      const { count, properties } = element;\r\n      const parsers = [];\r\n\r\n      let rgbaOffset = 0;\r\n      const isVertex = elementName === \"vertex\";\r\n      if (isVertex) {\r\n        for (const name of [\"opacity\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"]) {\r\n          if (!properties[name] || properties[name].type !== \"float\") {\r\n            throw new Error(`Can't injectRgba due to property: ${name}`);\r\n          }\r\n        }\r\n      }\r\n\r\n      for (const [propertyName, property] of Object.entries(properties)) {\r\n        if (!property.isList) {\r\n          if (isVertex) {\r\n            if (\r\n              propertyName === \"f_dc_0\" ||\r\n              propertyName === \"f_dc_1\" ||\r\n              propertyName === \"f_dc_2\"\r\n            ) {\r\n              const component = Number.parseInt(\r\n                propertyName.slice(\"f_dc_\".length),\r\n              );\r\n              parsers.push(() => {\r\n                // Inject DC coefficients\r\n                const value =\r\n                  (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0;\r\n                SET_FIELD[property.type](\r\n                  data,\r\n                  offset,\r\n                  this.littleEndian,\r\n                  value,\r\n                );\r\n              });\r\n            } else if (propertyName === \"opacity\") {\r\n              parsers.push(() => {\r\n                // Inject opacity sigmoid, clamped to [-100, 100]\r\n                const value = Math.max(\r\n                  -100,\r\n                  Math.min(\r\n                    100,\r\n                    -Math.log(1.0 / (rgba[rgbaOffset + 3] / 255) - 1.0),\r\n                  ),\r\n                );\r\n                SET_FIELD[property.type](\r\n                  data,\r\n                  offset,\r\n                  this.littleEndian,\r\n                  value,\r\n                );\r\n              });\r\n            }\r\n          }\r\n          parsers.push(() => {\r\n            offset += FIELD_BYTES[property.type];\r\n          });\r\n        } else {\r\n          parsers.push(() => {\r\n            const length = PARSE_FIELD[property.countType as PlyPropertyType](\r\n              data,\r\n              offset,\r\n              this.littleEndian,\r\n            );\r\n            offset += FIELD_BYTES[property.countType as PlyPropertyType];\r\n            offset += length * FIELD_BYTES[property.type];\r\n          });\r\n        }\r\n      }\r\n\r\n      for (let index = 0; index < count; index++) {\r\n        // Go through all the data and field parsers to compute offset\r\n        for (const parser of parsers) {\r\n          parser();\r\n        }\r\n        if (isVertex) {\r\n          rgbaOffset += 4;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const SH_C0 = 0.28209479177387814;\r\n\r\ntype FieldParser = (\r\n  data: DataView,\r\n  offset: number,\r\n  littleEndian: boolean,\r\n) => number;\r\ntype FieldSetter = (\r\n  data: DataView,\r\n  offset: number,\r\n  littleEndian: boolean,\r\n  value: number,\r\n) => void;\r\n\r\nconst PARSE_FIELD: Record<PlyPropertyType, FieldParser> = {\r\n  char: (data: DataView, offset: number, littleEndian: boolean) => {\r\n    return data.getInt8(offset);\r\n  },\r\n  uchar: (data: DataView, offset: number, littleEndian: boolean) => {\r\n    return data.getUint8(offset);\r\n  },\r\n  short: (data: DataView, offset: number, littleEndian: boolean) => {\r\n    return data.getInt16(offset, littleEndian);\r\n  },\r\n  ushort: (data: DataView, offset: number, littleEndian: boolean) => {\r\n    return data.getUint16(offset, littleEndian);\r\n  },\r\n  int: (data: DataView, offset: number, littleEndian: boolean) => {\r\n    return data.getInt32(offset, littleEndian);\r\n  },\r\n  uint: (data: DataView, offset: number, littleEndian: boolean) => {\r\n    return data.getUint32(offset, littleEndian);\r\n  },\r\n  float: (data: DataView, offset: number, littleEndian: boolean) => {\r\n    return data.getFloat32(offset, littleEndian);\r\n  },\r\n  double: (data: DataView, offset: number, littleEndian: boolean) => {\r\n    return data.getFloat64(offset, littleEndian);\r\n  },\r\n};\r\n\r\nconst SET_FIELD: Record<PlyPropertyType, FieldSetter> = {\r\n  char: (\r\n    data: DataView,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n    value: number,\r\n  ) => {\r\n    data.setInt8(offset, value);\r\n  },\r\n  uchar: (\r\n    data: DataView,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n    value: number,\r\n  ) => {\r\n    data.setUint8(offset, value);\r\n  },\r\n  short: (\r\n    data: DataView,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n    value: number,\r\n  ) => {\r\n    data.setInt16(offset, value, littleEndian);\r\n  },\r\n  ushort: (\r\n    data: DataView,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n    value: number,\r\n  ) => {\r\n    data.setUint16(offset, value, littleEndian);\r\n  },\r\n  int: (\r\n    data: DataView,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n    value: number,\r\n  ) => {\r\n    data.setInt32(offset, value, littleEndian);\r\n  },\r\n  uint: (\r\n    data: DataView,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n    value: number,\r\n  ) => {\r\n    data.setUint32(offset, value, littleEndian);\r\n  },\r\n  float: (\r\n    data: DataView,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n    value: number,\r\n  ) => {\r\n    data.setFloat32(offset, value, littleEndian);\r\n  },\r\n  double: (\r\n    data: DataView,\r\n    offset: number,\r\n    littleEndian: boolean,\r\n    value: number,\r\n  ) => {\r\n    data.setFloat64(offset, value, littleEndian);\r\n  },\r\n};\r\n\r\nconst FIELD_BYTES: Record<PlyPropertyType, number> = {\r\n  char: 1,\r\n  uchar: 1,\r\n  short: 2,\r\n  ushort: 2,\r\n  int: 4,\r\n  uint: 4,\r\n  float: 4,\r\n  double: 8,\r\n};\r\n\r\nconst FIELD_SCALE: Record<PlyPropertyType, number> = {\r\n  char: 127,\r\n  uchar: 255,\r\n  short: 32767,\r\n  ushort: 65535,\r\n  int: 2147483647,\r\n  uint: 4294967295,\r\n  float: 1,\r\n  double: 1,\r\n};\r\n\r\nconst NUM_F_REST_TO_NUM_SH: Record<number, number> = {\r\n  0: 0,\r\n  9: 1,\r\n  24: 2,\r\n  45: 3,\r\n};\r\nconst NUM_SH_TO_NUM_F_REST: Record<number, number> = {\r\n  0: 0,\r\n  1: 9,\r\n  2: 24,\r\n  3: 45,\r\n};\r\n\r\nconst F_REST_REGEX = /^f_rest_([0-9]{1,2})$/;\r\n\r\nfunction createEmptyItem(\r\n  properties: Record<string, PlyProperty>,\r\n): Record<string, number | number[]> {\r\n  const item: Record<string, number | number[]> = {};\r\n  for (const [propertyName, property] of Object.entries(properties)) {\r\n    // Treat f_rest properties as a single array for performance\r\n    if (F_REST_REGEX.test(propertyName)) {\r\n      item.f_rest = new Array(getNumSh(properties));\r\n    } else {\r\n      item[propertyName] = property.isList ? [] : 0;\r\n    }\r\n  }\r\n  return item;\r\n}\r\n\r\nfunction createParseFn(\r\n  properties: Record<string, PlyProperty>,\r\n  littleEndian: boolean,\r\n) {\r\n  if (USE_COMPILED_PARSER_FUNCTION && safeToCompile(properties)) {\r\n    return createCompiledParserFn(properties, littleEndian);\r\n  }\r\n  return createDynamicParserFn(properties, littleEndian);\r\n}\r\n\r\n// Detect if unsafe eval is allowed in the current execution context\r\nconst UNSAFE_EVAL_ALLOWED = (() => {\r\n  try {\r\n    new Function(\"return 42;\");\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n  return true;\r\n})();\r\nconst PROPERTY_NAME_REGEX = /^[a-zA-Z0-9_]+$/;\r\n\r\nfunction safeToCompile(properties: Record<string, PlyProperty>) {\r\n  if (!UNSAFE_EVAL_ALLOWED) {\r\n    return false;\r\n  }\r\n\r\n  for (const [propertyName, property] of Object.entries(properties)) {\r\n    if (!PROPERTY_NAME_REGEX.test(propertyName)) {\r\n      return false;\r\n    }\r\n\r\n    if (\r\n      property.isList &&\r\n      !PLY_PROPERTY_TYPES.includes(property.countType as PlyPropertyType)\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    if (!PLY_PROPERTY_TYPES.includes(property.type)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction createCompiledParserFn(\r\n  properties: Record<string, PlyProperty>,\r\n  littleEndian: boolean,\r\n) {\r\n  // Construct the parser function source.\r\n  const parserSrc: string[] = [\"let list;\"];\r\n  for (const [propertyName, property] of Object.entries(properties)) {\r\n    const fRestMatch = propertyName.match(F_REST_REGEX);\r\n    if (fRestMatch) {\r\n      const fRestIndex = +fRestMatch[1];\r\n      parserSrc.push(/*js*/ `\r\n        item.f_rest[${fRestIndex}] = PARSE_FIELD['${property.type}'](data, offset, ${littleEndian});\r\n        offset += ${FIELD_BYTES[property.type]};\r\n      `);\r\n    } else if (!property.isList) {\r\n      parserSrc.push(/*js*/ `\r\n        item['${propertyName}'] = PARSE_FIELD['${property.type}'](data, offset, ${littleEndian});\r\n        offset += ${FIELD_BYTES[property.type]};\r\n      `);\r\n    } else {\r\n      // Property is a list, so parse the count first\r\n      parserSrc.push(/*js*/ `\r\n        list = item['${propertyName}'];\r\n        list.length = PARSE_FIELD['${property.countType}'](data, offset, ${littleEndian});\r\n        offset += ${FIELD_BYTES[property.countType as PlyPropertyType]};\r\n        for (let i = 0; i < list.length; i++) {\r\n          list[i] = PARSE_FIELD['${property.type}'](data, offset, ${littleEndian});\r\n          offset += ${FIELD_BYTES[property.type]};\r\n        }\r\n      `);\r\n    }\r\n  }\r\n  parserSrc.push(\"return offset;\");\r\n\r\n  const fn = new Function(\r\n    \"data\",\r\n    \"offset\",\r\n    \"item\",\r\n    \"PARSE_FIELD\",\r\n    parserSrc.join(\"\\n\"),\r\n  );\r\n  return (\r\n    data: DataView,\r\n    offset: number,\r\n    item: Record<string, number | number[]>,\r\n  ) => fn(data, offset, item, PARSE_FIELD);\r\n}\r\n\r\nfunction createDynamicParserFn(\r\n  properties: Record<string, PlyProperty>,\r\n  littleEndian: boolean,\r\n) {\r\n  // Construct an array of parser function to parse each property in an item\r\n  const parsers: Array<\r\n    (\r\n      data: DataView,\r\n      offset: number,\r\n      item: Record<string, number | number[]>,\r\n    ) => number\r\n  > = [];\r\n  for (const [propertyName, property] of Object.entries(properties)) {\r\n    const fRestMatch = propertyName.match(F_REST_REGEX);\r\n    if (fRestMatch) {\r\n      const fRestIndex = +fRestMatch[1];\r\n      parsers.push(\r\n        (\r\n          data: DataView,\r\n          offset: number,\r\n          item: Record<string, number | number[]>,\r\n        ) => {\r\n          (item.f_rest as number[])[fRestIndex] = PARSE_FIELD[property.type](\r\n            data,\r\n            offset,\r\n            littleEndian,\r\n          );\r\n          return offset + FIELD_BYTES[property.type];\r\n        },\r\n      );\r\n    } else if (!property.isList) {\r\n      parsers.push(\r\n        (\r\n          data: DataView,\r\n          offset: number,\r\n          item: Record<string, number | number[]>,\r\n        ) => {\r\n          item[propertyName] = PARSE_FIELD[property.type](\r\n            data,\r\n            offset,\r\n            littleEndian,\r\n          );\r\n          return offset + FIELD_BYTES[property.type];\r\n        },\r\n      );\r\n    } else {\r\n      // Property is a list, so parse the count first\r\n      parsers.push(\r\n        (\r\n          data: DataView,\r\n          offset: number,\r\n          item: Record<string, number | number[]>,\r\n        ) => {\r\n          const list = item[propertyName] as number[];\r\n          list.length = PARSE_FIELD[property.countType as PlyPropertyType](\r\n            data,\r\n            offset,\r\n            littleEndian,\r\n          );\r\n          let currentOffset =\r\n            offset + FIELD_BYTES[property.countType as PlyPropertyType];\r\n          for (let i = 0; i < list.length; i++) {\r\n            list[i] = PARSE_FIELD[property.type](\r\n              data,\r\n              currentOffset,\r\n              littleEndian,\r\n            );\r\n            currentOffset += FIELD_BYTES[property.type];\r\n          }\r\n          return currentOffset;\r\n        },\r\n      );\r\n    }\r\n  }\r\n\r\n  return (\r\n    data: DataView,\r\n    offset: number,\r\n    item: Record<string, number | number[]>,\r\n  ) => {\r\n    let currentOffset = offset;\r\n    for (let parserIndex = 0; parserIndex < parsers.length; parserIndex++) {\r\n      currentOffset = parsers[parserIndex](data, currentOffset, item);\r\n    }\r\n    return currentOffset;\r\n  };\r\n}\r\n\r\nfunction getNumSh(properties: Record<string, PlyProperty>) {\r\n  let num_f_rest = 0;\r\n  while (properties[`f_rest_${num_f_rest}`]) {\r\n    num_f_rest += 1;\r\n  }\r\n  const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\r\n  if (numSh == null) {\r\n    throw new Error(`Unsupported number of SH coefficients: ${num_f_rest}`);\r\n  }\r\n  return numSh;\r\n}\r\n\r\ntype SSChunk = {\r\n  min_x: number;\r\n  min_y: number;\r\n  min_z: number;\r\n  max_x: number;\r\n  max_y: number;\r\n  max_z: number;\r\n  min_scale_x: number;\r\n  min_scale_y: number;\r\n  min_scale_z: number;\r\n  max_scale_x: number;\r\n  max_scale_y: number;\r\n  max_scale_z: number;\r\n  min_r?: number;\r\n  min_g?: number;\r\n  min_b?: number;\r\n  max_r?: number;\r\n  max_g?: number;\r\n  max_b?: number;\r\n};\r\n","import { getArrayBuffers } from \"./utils.js\";\r\nimport BundledWorker from \"./worker?worker&inline\";\r\n\r\n// SplatWorker is an internal class that manages a WebWorker for executing\r\n// longer running CPU tasks such as Gsplat file decoding and sorting.\r\n// Although a SplatWorker can be created and used directly, the utility\r\n// function withWorker() is recommended to allocate from a managed\r\n// pool of SplatWorkers.\r\n\r\nexport class SplatWorker {\r\n  worker: Worker;\r\n  messages: Record<\r\n    number,\r\n    { resolve: (value: unknown) => void; reject: (reason?: unknown) => void }\r\n  > = {};\r\n  messageIdNext = 0;\r\n\r\n  constructor() {\r\n    // this.worker = new Worker(new URL(\"./worker\", import.meta.url), { type: \"module\" });\r\n    this.worker = new BundledWorker();\r\n    this.worker.onmessage = (event) => this.onMessage(event);\r\n  }\r\n\r\n  makeMessageId(): number {\r\n    return ++this.messageIdNext;\r\n  }\r\n\r\n  makeMessagePromiseId(): { id: number; promise: Promise<unknown> } {\r\n    const id = this.makeMessageId();\r\n    const promise = new Promise((resolve, reject) => {\r\n      this.messages[id] = { resolve, reject };\r\n    });\r\n    return { id, promise };\r\n  }\r\n\r\n  onMessage(event: MessageEvent) {\r\n    // console.log(\"SplatWorker.onMessage:\", event);\r\n    const { id, result, error } = event.data;\r\n    // console.log(`SplatWorker.onMessage(${id}):`, result, error);\r\n    const handler = this.messages[id];\r\n    if (handler) {\r\n      delete this.messages[id];\r\n      if (error) {\r\n        handler.reject(error);\r\n      } else {\r\n        handler.resolve(result);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Invoke an RPC on the worker with the given name and arguments.\r\n  // The normal usage of a worker is to run one activity at a time,\r\n  // but this function allows for concurrent calls, tagging each request\r\n  // with a unique message Id and awaiting a response to that same Id.\r\n  // The method will automatically transfer any ArrayBuffers in the\r\n  // arguments to the worker. If you'd like to transfer a copy of a\r\n  // buffer then you must clone it before passing to this function.\r\n  async call(name: string, args: unknown): Promise<unknown> {\r\n    const { id, promise } = this.makeMessagePromiseId();\r\n    // console.log(`SplatWorker.call(${name}):`, args);\r\n    this.worker.postMessage(\r\n      { name, args, id },\r\n      { transfer: getArrayBuffers(args) },\r\n    );\r\n    return promise;\r\n  }\r\n}\r\n\r\nlet maxWorkers = 4;\r\n\r\nlet numWorkers = 0;\r\nconst freeWorkers: SplatWorker[] = [];\r\nconst workerQueue: ((worker: SplatWorker) => void)[] = [];\r\n\r\n// Set the maximum number of workers to allocate for the pool. (default: 4)\r\nexport function setWorkerPool(count = 4) {\r\n  maxWorkers = count;\r\n}\r\n\r\n// Allocate a worker from the pool. If none are available and we are below the\r\n// maximum, create a new one. Otherwise, add the request to a queue and wait\r\n// for it to be fulfilled.\r\nexport async function allocWorker(): Promise<SplatWorker> {\r\n  const worker = freeWorkers.shift();\r\n  if (worker) {\r\n    return worker;\r\n  }\r\n\r\n  if (numWorkers < maxWorkers) {\r\n    const worker = new SplatWorker();\r\n    numWorkers += 1;\r\n    return worker;\r\n  }\r\n\r\n  return new Promise((resolve) => {\r\n    workerQueue.push(resolve);\r\n  });\r\n}\r\n\r\n// Return a worker to the pool. Pass the worker to any pending waiter.\r\nexport function freeWorker(worker: SplatWorker) {\r\n  if (numWorkers > maxWorkers) {\r\n    // Worker no longer needed\r\n    numWorkers -= 1;\r\n    return;\r\n  }\r\n\r\n  const waiter = workerQueue.shift();\r\n  if (waiter) {\r\n    waiter(worker);\r\n    return;\r\n  }\r\n\r\n  freeWorkers.push(worker);\r\n}\r\n\r\n// Allocate a worker from the pool and invoke the callback with the worker.\r\n// When the callback completes, the worker will be returned to the pool.\r\nexport async function withWorker<T>(\r\n  callback: (worker: SplatWorker) => Promise<T>,\r\n): Promise<T> {\r\n  const worker = await allocWorker();\r\n  try {\r\n    return await callback(worker);\r\n  } finally {\r\n    freeWorker(worker);\r\n  }\r\n}\r\n","import { unzipSync } from \"fflate\";\r\nimport { FileLoader, Loader, type LoadingManager } from \"three\";\r\nimport {\r\n  DEFAULT_SPLAT_ENCODING,\r\n  PackedSplats,\r\n  type SplatEncoding,\r\n} from \"./PackedSplats\";\r\nimport { SplatMesh } from \"./SplatMesh\";\r\nimport { PlyReader } from \"./ply\";\r\nimport { withWorker } from \"./splatWorker\";\r\nimport { decompressPartialGzip, getTextureSize } from \"./utils\";\r\n\r\n// SplatLoader implements the THREE.Loader interface and supports loading a variety\r\n// of different Gsplat file formats. Formats .PLY and .SPZ can be auto-detected\r\n// from the file contents, while .SPLAT and .KSPLAT require either having the\r\n// appropriate file extension as part of the path, or it can be explicitly set\r\n// in the loader using the fileType property.\r\n\r\nexport class SplatLoader extends Loader {\r\n  fileLoader: FileLoader;\r\n  fileType?: SplatFileType;\r\n  packedSplats?: PackedSplats;\r\n\r\n  constructor(manager?: LoadingManager) {\r\n    super(manager);\r\n    this.fileLoader = new FileLoader(manager);\r\n  }\r\n\r\n  load(\r\n    url: string,\r\n    onLoad?: (decoded: PackedSplats) => void,\r\n    onProgress?: (event: ProgressEvent) => void,\r\n    onError?: (error: unknown) => void,\r\n  ) {\r\n    const resolvedURL = this.manager.resolveURL(\r\n      (this.path ?? \"\") + (url ?? \"\"),\r\n    );\r\n\r\n    const headers = new Headers(this.requestHeader);\r\n    const credentials = this.withCredentials ? \"include\" : \"same-origin\";\r\n    const request = new Request(resolvedURL, { headers, credentials });\r\n    let fileType = this.fileType;\r\n\r\n    this.manager.itemStart(resolvedURL);\r\n\r\n    fetchWithProgress(request, onProgress)\r\n      .then(async (input) => {\r\n        const progresses = [\r\n          new ProgressEvent(\"progress\", {\r\n            lengthComputable: true,\r\n            loaded: input.byteLength,\r\n            total: input.byteLength,\r\n          }),\r\n        ];\r\n\r\n        function updateProgresses() {\r\n          if (onProgress) {\r\n            const lengthComputable = progresses.every((p) => {\r\n              // Either it's computable or no progress yet\r\n              return p.lengthComputable || (p.loaded === 0 && p.total === 0);\r\n            });\r\n            const loaded = progresses.reduce((sum, p) => sum + p.loaded, 0);\r\n            const total = progresses.reduce((sum, p) => sum + p.total, 0);\r\n            onProgress(\r\n              new ProgressEvent(\"progress\", {\r\n                lengthComputable,\r\n                loaded,\r\n                total,\r\n              }),\r\n            );\r\n          }\r\n        }\r\n\r\n        const extraFiles: Record<string, ArrayBuffer> = {};\r\n        const promises = [];\r\n\r\n        const pcSogsJson = tryPcSogs(input);\r\n        if (fileType === SplatFileType.PCSOGS) {\r\n          if (pcSogsJson === undefined) {\r\n            throw new Error(\"Invalid PC SOGS file\");\r\n          }\r\n        }\r\n        if (pcSogsJson !== undefined) {\r\n          fileType = SplatFileType.PCSOGS;\r\n          for (const key of [\"means\", \"scales\", \"quats\", \"sh0\", \"shN\"]) {\r\n            const prop = pcSogsJson[key as keyof PcSogsJson];\r\n            if (prop) {\r\n              for (const file of prop.files) {\r\n                const fileUrl = new URL(file, resolvedURL).toString();\r\n                const progressIndex = progresses.length;\r\n                progresses.push(new ProgressEvent(\"progress\"));\r\n\r\n                this.manager.itemStart(fileUrl);\r\n                const request = new Request(fileUrl, { headers, credentials });\r\n                const promise = fetchWithProgress(request, (progress) => {\r\n                  progresses[progressIndex] = progress;\r\n                  updateProgresses();\r\n                })\r\n                  .then((data) => {\r\n                    extraFiles[file] = data;\r\n                  })\r\n                  .catch((error) => {\r\n                    this.manager.itemError(fileUrl);\r\n                    throw error;\r\n                  })\r\n                  .finally(() => {\r\n                    this.manager.itemEnd(fileUrl);\r\n                  });\r\n                promises.push(promise);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        await Promise.all(promises);\r\n        if (onLoad) {\r\n          const splatEncoding =\r\n            this.packedSplats?.splatEncoding ?? DEFAULT_SPLAT_ENCODING;\r\n          const decoded = await unpackSplats({\r\n            input,\r\n            extraFiles,\r\n            fileType,\r\n            pathOrUrl: resolvedURL,\r\n            splatEncoding,\r\n          });\r\n\r\n          if (this.packedSplats) {\r\n            this.packedSplats.initialize(decoded);\r\n            onLoad(this.packedSplats);\r\n          } else {\r\n            onLoad(new PackedSplats(decoded));\r\n          }\r\n        }\r\n      })\r\n      .catch((error) => {\r\n        this.manager.itemError(resolvedURL);\r\n        onError?.(error);\r\n      })\r\n      .finally(() => {\r\n        this.manager.itemEnd(resolvedURL);\r\n      });\r\n  }\r\n\r\n  async loadAsync(\r\n    url: string,\r\n    onProgress?: (event: ProgressEvent) => void,\r\n  ): Promise<PackedSplats> {\r\n    return new Promise((resolve, reject) => {\r\n      this.load(\r\n        url,\r\n        (decoded) => {\r\n          resolve(decoded);\r\n        },\r\n        onProgress,\r\n        reject,\r\n      );\r\n    });\r\n  }\r\n\r\n  parse(packedSplats: PackedSplats): SplatMesh {\r\n    return new SplatMesh({ packedSplats });\r\n  }\r\n}\r\n\r\nasync function fetchWithProgress(\r\n  request: Request,\r\n  onProgress?: (event: ProgressEvent) => void,\r\n) {\r\n  const response = await fetch(request);\r\n  if (!response.ok) {\r\n    throw new Error(\r\n      `${response.status} \"${response.statusText}\" fetching URL: ${request.url}`,\r\n    );\r\n  }\r\n  if (!response.body) {\r\n    throw new Error(`Response body is null for URL: ${request.url}`);\r\n  }\r\n\r\n  const reader = response.body.getReader();\r\n  const contentLength = Number.parseInt(\r\n    response.headers.get(\"Content-Length\") || \"0\",\r\n  );\r\n  const total = Number.isNaN(contentLength) ? 0 : contentLength;\r\n  let loaded = 0;\r\n  const chunks: Uint8Array[] = [];\r\n\r\n  while (true) {\r\n    const { done, value } = await reader.read();\r\n    if (done) {\r\n      break;\r\n    }\r\n    chunks.push(value);\r\n    loaded += value.length;\r\n\r\n    if (onProgress) {\r\n      onProgress(\r\n        new ProgressEvent(\"progress\", {\r\n          lengthComputable: total !== 0,\r\n          loaded,\r\n          total,\r\n        }),\r\n      );\r\n    }\r\n  }\r\n\r\n  // Combine chunks into a single buffer\r\n  const bytes = new Uint8Array(loaded);\r\n  let offset = 0;\r\n  for (const chunk of chunks) {\r\n    bytes.set(chunk, offset);\r\n    offset += chunk.length;\r\n  }\r\n  return bytes.buffer;\r\n}\r\n\r\nexport enum SplatFileType {\r\n  PLY = \"ply\",\r\n  SPZ = \"spz\",\r\n  SPLAT = \"splat\",\r\n  KSPLAT = \"ksplat\",\r\n  PCSOGS = \"pcsogs\",\r\n  PCSOGSZIP = \"pcsogszip\",\r\n}\r\n\r\nexport function getSplatFileType(\r\n  fileBytes: Uint8Array,\r\n): SplatFileType | undefined {\r\n  const view = new DataView(fileBytes.buffer);\r\n  if ((view.getUint32(0, true) & 0x00ffffff) === 0x00796c70) {\r\n    return SplatFileType.PLY;\r\n  }\r\n  if ((view.getUint32(0, true) & 0x00ffffff) === 0x00088b1f) {\r\n    // Gzipped file, unpack beginning to check magic number\r\n    const header = decompressPartialGzip(fileBytes, 4);\r\n    const gView = new DataView(header.buffer);\r\n    if (gView.getUint32(0, true) === 0x5053474e) {\r\n      return SplatFileType.SPZ;\r\n    }\r\n    // Unknown Gzipped file type\r\n    return undefined;\r\n  }\r\n  if (view.getUint32(0, true) === 0x04034b50) {\r\n    // PKZip file\r\n    if (tryPcSogsZip(fileBytes)) {\r\n      return SplatFileType.PCSOGSZIP;\r\n    }\r\n    // Unknown PKZip file type\r\n    return undefined;\r\n  }\r\n  // Unknown file type\r\n  return undefined;\r\n}\r\n\r\n// Returns the lowercased file extension from a path or URL\r\nexport function getFileExtension(pathOrUrl: string): string {\r\n  const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\r\n  const lastSlash = Math.max(\r\n    noTrailing.lastIndexOf(\"/\"),\r\n    noTrailing.lastIndexOf(\"\\\\\"),\r\n  );\r\n  const filename = noTrailing.slice(lastSlash + 1);\r\n  const lastDot = filename.lastIndexOf(\".\");\r\n  if (lastDot <= 0 || lastDot === filename.length - 1) {\r\n    return \"\"; // No extension\r\n  }\r\n  return filename.slice(lastDot + 1).toLowerCase();\r\n}\r\n\r\nexport function getSplatFileTypeFromPath(\r\n  pathOrUrl: string,\r\n): SplatFileType | undefined {\r\n  const extension = getFileExtension(pathOrUrl);\r\n  if (extension === \"ply\") {\r\n    return SplatFileType.PLY;\r\n  }\r\n  if (extension === \"spz\") {\r\n    return SplatFileType.SPZ;\r\n  }\r\n  if (extension === \"splat\") {\r\n    return SplatFileType.SPLAT;\r\n  }\r\n  if (extension === \"ksplat\") {\r\n    return SplatFileType.KSPLAT;\r\n  }\r\n  if (extension === \"sog\") {\r\n    return SplatFileType.PCSOGSZIP;\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport type PcSogsJson = {\r\n  means: {\r\n    shape: number[];\r\n    dtype: string;\r\n    mins: number[];\r\n    maxs: number[];\r\n    files: string[];\r\n  };\r\n  scales: {\r\n    shape: number[];\r\n    dtype: string;\r\n    mins: number[];\r\n    maxs: number[];\r\n    files: string[];\r\n  };\r\n  quats: { shape: number[]; dtype: string; encoding?: string; files: string[] };\r\n  sh0: {\r\n    shape: number[];\r\n    dtype: string;\r\n    mins: number[];\r\n    maxs: number[];\r\n    files: string[];\r\n  };\r\n  shN?: {\r\n    shape: number[];\r\n    dtype: string;\r\n    mins: number;\r\n    maxs: number;\r\n    quantization: number;\r\n    files: string[];\r\n  };\r\n};\r\n\r\nexport type PcSogsV2Json = {\r\n  version: 2;\r\n  count: number;\r\n  antialias?: boolean;\r\n  means: {\r\n    mins: number[];\r\n    maxs: number[];\r\n    files: string[];\r\n  };\r\n  scales: {\r\n    codebook: number[];\r\n    files: string[];\r\n  };\r\n  quats: { files: string[] };\r\n  sh0: {\r\n    codebook: number[];\r\n    files: string[];\r\n  };\r\n  shN?: {\r\n    count: number;\r\n    bands: number;\r\n    codebook: number[];\r\n    files: string[];\r\n  };\r\n};\r\n\r\nexport function isPcSogs(input: ArrayBuffer | Uint8Array | string): boolean {\r\n  // Returns true if the input seems to be a valid PC SOGS file\r\n  return tryPcSogs(input) !== undefined;\r\n}\r\n\r\nexport function tryPcSogs(\r\n  input: ArrayBuffer | Uint8Array | string,\r\n): PcSogsJson | PcSogsV2Json | undefined {\r\n  // Try to parse input as SOGS JSON and see if it's valid\r\n  try {\r\n    let text: string;\r\n    if (typeof input === \"string\") {\r\n      text = input;\r\n    } else {\r\n      const fileBytes =\r\n        input instanceof ArrayBuffer ? new Uint8Array(input) : input;\r\n      if (fileBytes.length > 65536) {\r\n        // Should be only a few KB, definitely not a SOGS JSON file\r\n        return undefined;\r\n      }\r\n      text = new TextDecoder().decode(fileBytes);\r\n    }\r\n\r\n    const json = JSON.parse(text);\r\n    if (!json || typeof json !== \"object\" || Array.isArray(json)) {\r\n      return undefined;\r\n    }\r\n    const isVersion2 = json.version === 2;\r\n\r\n    for (const key of [\"means\", \"scales\", \"quats\", \"sh0\"]) {\r\n      if (\r\n        !json[key] ||\r\n        typeof json[key] !== \"object\" ||\r\n        Array.isArray(json[key])\r\n      ) {\r\n        return undefined;\r\n      }\r\n      if (isVersion2) {\r\n        // Expect files\r\n        if (!json[key].files) {\r\n          return undefined;\r\n        }\r\n\r\n        // Scales and sh0 should have codebooks\r\n        if ((key === \"scales\" || key === \"sh0\") && !json[key].codebook) {\r\n          return undefined;\r\n        }\r\n        // Means should have mins and maxs defined\r\n        if (key === \"means\" && (!json[key].mins || !json[key].maxs)) {\r\n          return undefined;\r\n        }\r\n      } else {\r\n        // Expect shape and files\r\n        if (!json[key].shape || !json[key].files) {\r\n          return undefined;\r\n        }\r\n        // Besides 'quats' all other properties have mins and maxs\r\n        if (key !== \"quats\" && (!json[key].mins || !json[key].maxs)) {\r\n          return undefined;\r\n        }\r\n      }\r\n    }\r\n    // This is probably a PC SOGS file\r\n    return json as PcSogsJson | PcSogsV2Json;\r\n  } catch {\r\n    return undefined;\r\n  }\r\n}\r\n\r\nexport function tryPcSogsZip(\r\n  input: ArrayBuffer | Uint8Array,\r\n): { name: string; json: PcSogsJson | PcSogsV2Json } | undefined {\r\n  try {\r\n    const fileBytes =\r\n      input instanceof ArrayBuffer ? new Uint8Array(input) : input;\r\n    let metaFilename: string | null = null;\r\n\r\n    const unzipped = unzipSync(fileBytes, {\r\n      filter: ({ name }) => {\r\n        const filename = name.split(/[\\\\/]/).pop() as string;\r\n        if (filename === \"meta.json\") {\r\n          metaFilename = name;\r\n          return true;\r\n        }\r\n        return false;\r\n      },\r\n    });\r\n    if (!metaFilename) {\r\n      return undefined;\r\n    }\r\n\r\n    // Check for PC SOGS V1 and V2 (aka SOG)\r\n    const json = tryPcSogs(unzipped[metaFilename]);\r\n    if (!json) {\r\n      return undefined;\r\n    }\r\n    return { name: metaFilename, json };\r\n  } catch {\r\n    return undefined;\r\n  }\r\n}\r\n\r\nexport async function unpackSplats({\r\n  input,\r\n  extraFiles,\r\n  fileType,\r\n  pathOrUrl,\r\n  splatEncoding,\r\n}: {\r\n  input: Uint8Array | ArrayBuffer;\r\n  extraFiles?: Record<string, ArrayBuffer>;\r\n  fileType?: SplatFileType;\r\n  pathOrUrl?: string;\r\n  splatEncoding?: SplatEncoding;\r\n}): Promise<{\r\n  packedArray: Uint32Array;\r\n  numSplats: number;\r\n  extra?: Record<string, unknown>;\r\n}> {\r\n  const fileBytes =\r\n    input instanceof ArrayBuffer ? new Uint8Array(input) : input;\r\n  let splatFileType = fileType;\r\n  if (!fileType) {\r\n    splatFileType = getSplatFileType(fileBytes);\r\n    if (!splatFileType && pathOrUrl) {\r\n      splatFileType = getSplatFileTypeFromPath(pathOrUrl);\r\n    }\r\n  }\r\n\r\n  switch (splatFileType) {\r\n    case SplatFileType.PLY: {\r\n      const ply = new PlyReader({ fileBytes });\r\n      await ply.parseHeader();\r\n      const numSplats = ply.numSplats;\r\n      const maxSplats = getTextureSize(numSplats).maxSplats;\r\n      const args = {\r\n        fileBytes,\r\n        packedArray: new Uint32Array(maxSplats * 4),\r\n        splatEncoding,\r\n      };\r\n      return await withWorker(async (worker) => {\r\n        const { packedArray, numSplats, extra } = (await worker.call(\r\n          \"unpackPly\",\r\n          args,\r\n        )) as {\r\n          packedArray: Uint32Array;\r\n          numSplats: number;\r\n          extra: Record<string, unknown>;\r\n        };\r\n        return { packedArray, numSplats, extra };\r\n      });\r\n    }\r\n    case SplatFileType.SPZ: {\r\n      return await withWorker(async (worker) => {\r\n        const { packedArray, numSplats, extra } = (await worker.call(\r\n          \"decodeSpz\",\r\n          {\r\n            fileBytes,\r\n            splatEncoding,\r\n          },\r\n        )) as {\r\n          packedArray: Uint32Array;\r\n          numSplats: number;\r\n          extra: Record<string, unknown>;\r\n        };\r\n        return { packedArray, numSplats, extra };\r\n      });\r\n    }\r\n    case SplatFileType.SPLAT: {\r\n      return await withWorker(async (worker) => {\r\n        const { packedArray, numSplats } = (await worker.call(\r\n          \"decodeAntiSplat\",\r\n          {\r\n            fileBytes,\r\n            splatEncoding,\r\n          },\r\n        )) as { packedArray: Uint32Array; numSplats: number };\r\n        return { packedArray, numSplats };\r\n      });\r\n    }\r\n    case SplatFileType.KSPLAT: {\r\n      return await withWorker(async (worker) => {\r\n        const { packedArray, numSplats, extra } = (await worker.call(\r\n          \"decodeKsplat\",\r\n          { fileBytes, splatEncoding },\r\n        )) as {\r\n          packedArray: Uint32Array;\r\n          numSplats: number;\r\n          extra: Record<string, unknown>;\r\n        };\r\n        return { packedArray, numSplats, extra };\r\n      });\r\n    }\r\n    case SplatFileType.PCSOGS: {\r\n      return await withWorker(async (worker) => {\r\n        const { packedArray, numSplats, extra } = (await worker.call(\r\n          \"decodePcSogs\",\r\n          { fileBytes, extraFiles, splatEncoding },\r\n        )) as {\r\n          packedArray: Uint32Array;\r\n          numSplats: number;\r\n          extra: Record<string, unknown>;\r\n        };\r\n        return { packedArray, numSplats, extra };\r\n      });\r\n    }\r\n    case SplatFileType.PCSOGSZIP: {\r\n      return await withWorker(async (worker) => {\r\n        const { packedArray, numSplats, extra } = (await worker.call(\r\n          \"decodePcSogsZip\",\r\n          { fileBytes, splatEncoding },\r\n        )) as {\r\n          packedArray: Uint32Array;\r\n          numSplats: number;\r\n          extra: Record<string, unknown>;\r\n        };\r\n        return { packedArray, numSplats, extra };\r\n      });\r\n    }\r\n    default: {\r\n      throw new Error(`Unknown splat file type: ${splatFileType}`);\r\n    }\r\n  }\r\n}\r\n\r\nexport class SplatData {\r\n  numSplats: number;\r\n  maxSplats: number;\r\n  centers: Float32Array;\r\n  scales: Float32Array;\r\n  quaternions: Float32Array;\r\n  opacities: Float32Array;\r\n  colors: Float32Array;\r\n  sh1?: Float32Array;\r\n  sh2?: Float32Array;\r\n  sh3?: Float32Array;\r\n\r\n  constructor({ maxSplats = 1 }: { maxSplats?: number } = {}) {\r\n    this.numSplats = 0;\r\n    this.maxSplats = getTextureSize(maxSplats).maxSplats;\r\n    this.centers = new Float32Array(this.maxSplats * 3);\r\n    this.scales = new Float32Array(this.maxSplats * 3);\r\n    this.quaternions = new Float32Array(this.maxSplats * 4);\r\n    this.opacities = new Float32Array(this.maxSplats);\r\n    this.colors = new Float32Array(this.maxSplats * 3);\r\n  }\r\n\r\n  pushSplat(): number {\r\n    const index = this.numSplats;\r\n    this.ensureIndex(index);\r\n    this.numSplats += 1;\r\n    return index;\r\n  }\r\n\r\n  unpushSplat(index: number) {\r\n    if (index === this.numSplats - 1) {\r\n      this.numSplats -= 1;\r\n    } else {\r\n      throw new Error(\"Cannot unpush splat from non-last position\");\r\n    }\r\n  }\r\n\r\n  ensureCapacity(numSplats: number) {\r\n    if (numSplats > this.maxSplats) {\r\n      const targetSplats = Math.max(numSplats, this.maxSplats * 2);\r\n      const newCenters = new Float32Array(targetSplats * 3);\r\n      const newScales = new Float32Array(targetSplats * 3);\r\n      const newQuaternions = new Float32Array(targetSplats * 4);\r\n      const newOpacities = new Float32Array(targetSplats);\r\n      const newColors = new Float32Array(targetSplats * 3);\r\n      newCenters.set(this.centers);\r\n      newScales.set(this.scales);\r\n      newQuaternions.set(this.quaternions);\r\n      newOpacities.set(this.opacities);\r\n      newColors.set(this.colors);\r\n      this.centers = newCenters;\r\n      this.scales = newScales;\r\n      this.quaternions = newQuaternions;\r\n      this.opacities = newOpacities;\r\n      this.colors = newColors;\r\n\r\n      if (this.sh1) {\r\n        const newSh1 = new Float32Array(targetSplats * 9);\r\n        newSh1.set(this.sh1);\r\n        this.sh1 = newSh1;\r\n      }\r\n      if (this.sh2) {\r\n        const newSh2 = new Float32Array(targetSplats * 15);\r\n        newSh2.set(this.sh2);\r\n        this.sh2 = newSh2;\r\n      }\r\n      if (this.sh3) {\r\n        const newSh3 = new Float32Array(targetSplats * 21);\r\n        newSh3.set(this.sh3);\r\n        this.sh3 = newSh3;\r\n      }\r\n\r\n      this.maxSplats = targetSplats;\r\n    }\r\n  }\r\n\r\n  ensureIndex(index: number) {\r\n    this.ensureCapacity(index + 1);\r\n  }\r\n\r\n  setCenter(index: number, x: number, y: number, z: number) {\r\n    this.centers[index * 3] = x;\r\n    this.centers[index * 3 + 1] = y;\r\n    this.centers[index * 3 + 2] = z;\r\n  }\r\n\r\n  setScale(index: number, scaleX: number, scaleY: number, scaleZ: number) {\r\n    this.scales[index * 3] = scaleX;\r\n    this.scales[index * 3 + 1] = scaleY;\r\n    this.scales[index * 3 + 2] = scaleZ;\r\n  }\r\n\r\n  setQuaternion(index: number, x: number, y: number, z: number, w: number) {\r\n    this.quaternions[index * 4] = x;\r\n    this.quaternions[index * 4 + 1] = y;\r\n    this.quaternions[index * 4 + 2] = z;\r\n    this.quaternions[index * 4 + 3] = w;\r\n  }\r\n\r\n  setOpacity(index: number, opacity: number) {\r\n    this.opacities[index] = opacity;\r\n  }\r\n\r\n  setColor(index: number, r: number, g: number, b: number) {\r\n    this.colors[index * 3] = r;\r\n    this.colors[index * 3 + 1] = g;\r\n    this.colors[index * 3 + 2] = b;\r\n  }\r\n\r\n  setSh1(index: number, sh1: Float32Array) {\r\n    if (!this.sh1) {\r\n      this.sh1 = new Float32Array(this.maxSplats * 9);\r\n    }\r\n    for (let j = 0; j < 9; ++j) {\r\n      this.sh1[index * 9 + j] = sh1[j];\r\n    }\r\n  }\r\n\r\n  setSh2(index: number, sh2: Float32Array) {\r\n    if (!this.sh2) {\r\n      this.sh2 = new Float32Array(this.maxSplats * 15);\r\n    }\r\n    for (let j = 0; j < 15; ++j) {\r\n      this.sh2[index * 15 + j] = sh2[j];\r\n    }\r\n  }\r\n\r\n  setSh3(index: number, sh3: Float32Array) {\r\n    if (!this.sh3) {\r\n      this.sh3 = new Float32Array(this.maxSplats * 21);\r\n    }\r\n    for (let j = 0; j < 21; ++j) {\r\n      this.sh3[index * 21 + j] = sh3[j];\r\n    }\r\n  }\r\n}\r\n\r\nexport async function transcodeSpz(\r\n  input: TranscodeSpzInput,\r\n): Promise<{ input: TranscodeSpzInput; fileBytes: Uint8Array }> {\r\n  return await withWorker(async (worker) => {\r\n    const result = (await worker.call(\"transcodeSpz\", input)) as {\r\n      input: TranscodeSpzInput;\r\n      fileBytes: Uint8Array;\r\n    };\r\n    return result;\r\n  });\r\n}\r\n\r\nexport type FileInput = {\r\n  fileBytes: Uint8Array;\r\n  fileType?: SplatFileType;\r\n  pathOrUrl?: string;\r\n  transform?: { translate?: number[]; quaternion?: number[]; scale?: number };\r\n};\r\n\r\nexport type TranscodeSpzInput = {\r\n  inputs: FileInput[];\r\n  maxSh?: number;\r\n  clipXyz?: { min: number[]; max: number[] };\r\n  fractionalBits?: number;\r\n  opacityThreshold?: number;\r\n};\r\n","precision highp float;\r\nprecision highp int;\r\nprecision highp sampler2D;\r\nprecision highp usampler2D;\r\nprecision highp isampler2D;\r\nprecision highp sampler2DArray;\r\nprecision highp usampler2DArray;\r\nprecision highp isampler2DArray;\r\nprecision highp sampler3D;\r\nprecision highp usampler3D;\r\nprecision highp isampler3D;\r\n\r\n#include <splatDefines>\r\n\r\nuniform uint targetLayer;\r\nuniform int targetBase;\r\nuniform int targetCount;\r\n\r\nout uvec4 target;\r\n\r\n{{ GLOBALS }}\r\n\r\nvoid produceSplat(int index) {\r\n    {{ STATEMENTS }}\r\n}\r\n\r\nvoid main() {\r\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\r\n    int index = targetIndex - targetBase;\r\n\r\n    if ((index >= 0) && (index < targetCount)) {\r\n        produceSplat(index);\r\n    } else {\r\n        target = uvec4(0u, 0u, 0u, 0u);\r\n    }\r\n}\r\n","import * as THREE from \"three\";\r\nimport { FullScreenQuad } from \"three/addons/postprocessing/Pass.js\";\r\n\r\nimport type { GsplatGenerator } from \"./SplatGenerator\";\r\nimport { type SplatFileType, SplatLoader, unpackSplats } from \"./SplatLoader\";\r\nimport {\r\n  LN_SCALE_MAX,\r\n  LN_SCALE_MIN,\r\n  SPLAT_TEX_HEIGHT,\r\n  SPLAT_TEX_WIDTH,\r\n} from \"./defines\";\r\nimport {\r\n  DynoProgram,\r\n  DynoProgramTemplate,\r\n  DynoUniform,\r\n  DynoVec2,\r\n  DynoVec4,\r\n  dynoBlock,\r\n  outputPackedSplat,\r\n} from \"./dyno\";\r\nimport { TPackedSplats, definePackedSplats } from \"./dyno/splats\";\r\nimport computeUvec4Template from \"./shaders/computeUvec4.glsl\";\r\nimport { getTextureSize, setPackedSplat, unpackSplat } from \"./utils\";\r\n\r\nexport type SplatEncoding = {\r\n  rgbMin?: number;\r\n  rgbMax?: number;\r\n  lnScaleMin?: number;\r\n  lnScaleMax?: number;\r\n  sh1Min?: number;\r\n  sh1Max?: number;\r\n  sh2Min?: number;\r\n  sh2Max?: number;\r\n  sh3Min?: number;\r\n  sh3Max?: number;\r\n};\r\n\r\nexport const DEFAULT_SPLAT_ENCODING: SplatEncoding = {\r\n  rgbMin: 0,\r\n  rgbMax: 1,\r\n  lnScaleMin: LN_SCALE_MIN,\r\n  lnScaleMax: LN_SCALE_MAX,\r\n  sh1Min: -1,\r\n  sh1Max: 1,\r\n  sh2Min: -1,\r\n  sh2Max: 1,\r\n  sh3Min: -1,\r\n  sh3Max: 1,\r\n};\r\n\r\n// Initialize a PackedSplats collection from source data via\r\n// url, fileBytes, or packedArray. Creates an empty array if none are set,\r\n// and splat data can be constructed using pushSplat()/setSplat(). The maximum\r\n// splat size allocation will grow automatically, starting from maxSplats.\r\nexport type PackedSplatsOptions = {\r\n  // URL to fetch a Gaussian splat file from (supports .ply, .splat, .ksplat,\r\n  // .spz formats). (default: undefined)\r\n  url?: string;\r\n  // Raw bytes of a Gaussian splat file to decode directly instead of fetching\r\n  // from URL. (default: undefined)\r\n  fileBytes?: Uint8Array | ArrayBuffer;\r\n  // Override the file type detection for formats that can't be reliably\r\n  // auto-detected (.splat, .ksplat). (default: undefined auto-detects other\r\n  // formats from file contents)\r\n  fileType?: SplatFileType;\r\n  // File name to use for type detection. (default: undefined)\r\n  fileName?: string;\r\n  // Reserve space for at least this many splats when constructing the collection\r\n  // initially. The array will automatically resize past maxSplats so setting it is\r\n  // an optional optimization. (default: 0)\r\n  maxSplats?: number;\r\n  // Use provided packed data array, where each 4 consecutive uint32 values\r\n  // encode one \"packed\" Gsplat. (default: undefined)\r\n  packedArray?: Uint32Array;\r\n  // Override number of splats in packed array to use only a subset.\r\n  // (default: length of packed array / 4)\r\n  numSplats?: number;\r\n  // Callback function to programmatically create splats at initialization.\r\n  // (default: undefined)\r\n  construct?: (splats: PackedSplats) => Promise<void> | void;\r\n  // Additional splat data, such as spherical harmonics components (sh1, sh2, sh3). (default: {})\r\n  extra?: Record<string, unknown>;\r\n  // Override the default splat encoding ranges for the PackedSplats.\r\n  // (default: undefined)\r\n  splatEncoding?: SplatEncoding;\r\n};\r\n\r\n// A PackedSplats is a collection of Gaussian splats, packed into a format that\r\n// takes exactly 16 bytes per Gsplat to maximize memory and cache efficiency.\r\n// The center xyz coordinates are encoded as float16 (3 x 2 bytes), scale xyz\r\n// as 3 x uint8 that encode a log scale from e^-12 to e^9, rgba as 4 x uint8,\r\n// and quaternion encoded via axis+angle using 2 x uint8 for octahedral encoding\r\n// of the axis direction and a uint8 to encode rotation amount from 0..Pi.\r\n\r\nexport class PackedSplats {\r\n  maxSplats = 0;\r\n  numSplats = 0;\r\n  packedArray: Uint32Array | null = null;\r\n  extra: Record<string, unknown>;\r\n  splatEncoding?: SplatEncoding;\r\n\r\n  initialized: Promise<PackedSplats>;\r\n  isInitialized = false;\r\n\r\n  // Either target or source will be non-null, depending on whether the PackedSplats\r\n  // is being used as a data source or generated to.\r\n  target: THREE.WebGLArrayRenderTarget | null = null;\r\n  source: THREE.DataArrayTexture | null = null;\r\n  // Set to true if source packedArray is updated to have it upload to GPU\r\n  needsUpdate = true;\r\n\r\n  // A PackedSplats can be used in a dyno graph using the below property dyno:\r\n  // const gsplat = dyno.readPackedSplats(this.dyno, dynoIndex);\r\n  dyno: DynoUniform<typeof TPackedSplats, \"packedSplats\">;\r\n  dynoRgbMinMaxLnScaleMinMax: DynoUniform<\"vec4\", \"rgbMinMaxLnScaleMinMax\">;\r\n  dynoSh1MinMax: DynoUniform<\"vec2\", \"sh1MinMax\">;\r\n  dynoSh2MinMax: DynoUniform<\"vec2\", \"sh2MinMax\">;\r\n  dynoSh3MinMax: DynoUniform<\"vec2\", \"sh3MinMax\">;\r\n\r\n  constructor(options: PackedSplatsOptions = {}) {\r\n    this.extra = {};\r\n    this.dyno = new DynoPackedSplats({ packedSplats: this });\r\n    this.dynoRgbMinMaxLnScaleMinMax = new DynoVec4({\r\n      key: \"rgbMinMaxLnScaleMinMax\",\r\n      value: new THREE.Vector4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX),\r\n      update: (value) => {\r\n        value.set(\r\n          this.splatEncoding?.rgbMin ?? 0.0,\r\n          this.splatEncoding?.rgbMax ?? 1.0,\r\n          this.splatEncoding?.lnScaleMin ?? LN_SCALE_MIN,\r\n          this.splatEncoding?.lnScaleMax ?? LN_SCALE_MAX,\r\n        );\r\n        return value;\r\n      },\r\n    });\r\n    this.dynoSh1MinMax = new DynoVec2({\r\n      key: \"sh1MinMax\",\r\n      value: new THREE.Vector2(-1, 1),\r\n      update: (value) => {\r\n        value.set(\r\n          this.splatEncoding?.sh1Min ?? -1,\r\n          this.splatEncoding?.sh1Max ?? 1,\r\n        );\r\n        return value;\r\n      },\r\n    });\r\n    this.dynoSh2MinMax = new DynoVec2({\r\n      key: \"sh2MinMax\",\r\n      value: new THREE.Vector2(-1, 1),\r\n      update: (value) => {\r\n        value.set(\r\n          this.splatEncoding?.sh2Min ?? -1,\r\n          this.splatEncoding?.sh2Max ?? 1,\r\n        );\r\n        return value;\r\n      },\r\n    });\r\n    this.dynoSh3MinMax = new DynoVec2({\r\n      key: \"sh3MinMax\",\r\n      value: new THREE.Vector2(-1, 1),\r\n      update: (value) => {\r\n        value.set(\r\n          this.splatEncoding?.sh3Min ?? -1,\r\n          this.splatEncoding?.sh3Max ?? 1,\r\n        );\r\n        return value;\r\n      },\r\n    });\r\n\r\n    // The following line will be overridden by reinitialize()\r\n    this.initialized = Promise.resolve(this);\r\n    this.reinitialize(options);\r\n  }\r\n\r\n  reinitialize(options: PackedSplatsOptions) {\r\n    this.isInitialized = false;\r\n\r\n    this.extra = {};\r\n    this.splatEncoding = options.splatEncoding;\r\n\r\n    if (options.url || options.fileBytes || options.construct) {\r\n      // We need to initialize asynchronously given the options\r\n      this.initialized = this.asyncInitialize(options).then(() => {\r\n        this.isInitialized = true;\r\n        return this;\r\n      });\r\n    } else {\r\n      this.initialize(options);\r\n      this.isInitialized = true;\r\n      this.initialized = Promise.resolve(this);\r\n    }\r\n  }\r\n\r\n  initialize(options: PackedSplatsOptions) {\r\n    if (options.packedArray) {\r\n      this.packedArray = options.packedArray;\r\n      // Calculate number of horizontal texture rows that could fit in array.\r\n      // A properly initialized packedArray should already take into account the\r\n      // width and height of the texture and be rounded up with padding.\r\n      this.maxSplats = Math.floor(this.packedArray.length / 4);\r\n      this.maxSplats =\r\n        Math.floor(this.maxSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\r\n      this.numSplats = Math.min(\r\n        this.maxSplats,\r\n        options.numSplats ?? Number.POSITIVE_INFINITY,\r\n      );\r\n    } else {\r\n      this.maxSplats = options.maxSplats ?? 0;\r\n      this.numSplats = 0;\r\n    }\r\n    this.extra = options.extra ?? {};\r\n  }\r\n\r\n  async asyncInitialize(options: PackedSplatsOptions) {\r\n    const { url, fileBytes, construct } = options;\r\n    if (url) {\r\n      const loader = new SplatLoader();\r\n      loader.packedSplats = this;\r\n      await loader.loadAsync(url);\r\n    } else if (fileBytes) {\r\n      const unpacked = await unpackSplats({\r\n        input: fileBytes,\r\n        fileType: options.fileType,\r\n        pathOrUrl: options.fileName ?? url,\r\n        splatEncoding: options.splatEncoding ?? DEFAULT_SPLAT_ENCODING,\r\n      });\r\n      this.initialize(unpacked);\r\n    }\r\n\r\n    if (construct) {\r\n      const maybePromise = construct(this);\r\n      // If construct returns a promise, wait for it to complete\r\n      if (maybePromise instanceof Promise) {\r\n        await maybePromise;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Call this when you are finished with the PackedSplats and want to free\r\n  // any buffers it holds.\r\n  dispose() {\r\n    if (this.target) {\r\n      this.target.dispose();\r\n      this.target = null;\r\n    }\r\n    if (this.source) {\r\n      this.source.dispose();\r\n      this.source = null;\r\n    }\r\n  }\r\n\r\n  // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,\r\n  // resize exponentially and copy over the original data.\r\n  //\r\n  // Typically you don't need to call this, because calling this.setSplat(index, ...)\r\n  // and this.pushSplat(...) will automatically call ensureSplats() so we have\r\n  // enough splats.\r\n  ensureSplats(numSplats: number): Uint32Array {\r\n    const targetSize =\r\n      numSplats <= this.maxSplats\r\n        ? this.maxSplats\r\n        : // Grow exponentially to avoid frequent reallocations\r\n          Math.max(numSplats, 2 * this.maxSplats);\r\n    const currentSize = !this.packedArray ? 0 : this.packedArray.length / 4;\r\n\r\n    if (!this.packedArray || targetSize > currentSize) {\r\n      this.maxSplats = getTextureSize(targetSize).maxSplats;\r\n      const newArray = new Uint32Array(this.maxSplats * 4);\r\n      if (this.packedArray) {\r\n        // Copy over existing data\r\n        newArray.set(this.packedArray);\r\n      }\r\n      this.packedArray = newArray;\r\n    }\r\n    return this.packedArray;\r\n  }\r\n\r\n  // Ensure the extra array for the given level is large enough to hold numSplats\r\n  ensureSplatsSh(level: number, numSplats: number): Uint32Array {\r\n    let wordsPerSplat: number;\r\n    let key: string;\r\n    if (level === 0) {\r\n      return this.ensureSplats(numSplats);\r\n    }\r\n    if (level === 1) {\r\n      // 3 x 3 uint7 = 63 bits = 2 uint32\r\n      wordsPerSplat = 2;\r\n      key = \"sh1\";\r\n    } else if (level === 2) {\r\n      // 5 x 3 uint8 = 120 bits = 4 uint32\r\n      wordsPerSplat = 4;\r\n      key = \"sh2\";\r\n    } else if (level === 3) {\r\n      // 7 x 3 uint6 = 126 bits = 4 uint32\r\n      wordsPerSplat = 4;\r\n      key = \"sh3\";\r\n    } else {\r\n      throw new Error(`Invalid level: ${level}`);\r\n    }\r\n\r\n    // Figure out our current and desired maxSplats\r\n    let maxSplats: number = !this.extra[key]\r\n      ? 0\r\n      : (this.extra[key] as Uint32Array).length / wordsPerSplat;\r\n    const targetSize =\r\n      numSplats <= maxSplats ? maxSplats : Math.max(numSplats, 2 * maxSplats);\r\n\r\n    if (!this.extra[key] || targetSize > maxSplats) {\r\n      // Reallocate the array\r\n      maxSplats = getTextureSize(targetSize).maxSplats;\r\n      const newArray = new Uint32Array(maxSplats * wordsPerSplat);\r\n      if (this.extra[key]) {\r\n        // Copy over existing data\r\n        newArray.set(this.extra[key] as Uint32Array);\r\n      }\r\n      this.extra[key] = newArray;\r\n    }\r\n    return this.extra[key] as Uint32Array;\r\n  }\r\n\r\n  // Unpack the 16-byte Gsplat data at index into the Three.js components\r\n  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\r\n  // opacity: number 0..1, color: THREE.Color 0..1.\r\n  getSplat(index: number): {\r\n    center: THREE.Vector3;\r\n    scales: THREE.Vector3;\r\n    quaternion: THREE.Quaternion;\r\n    opacity: number;\r\n    color: THREE.Color;\r\n  } {\r\n    if (!this.packedArray || index >= this.numSplats) {\r\n      throw new Error(\"Invalid index\");\r\n    }\r\n    return unpackSplat(this.packedArray, index, this.splatEncoding);\r\n  }\r\n\r\n  // Set all PackedSplat components at index with the provided Gsplat attributes\r\n  // (can be the same objects returned by getSplat). Ensures there is capacity\r\n  // for at least index+1 Gsplats.\r\n  setSplat(\r\n    index: number,\r\n    center: THREE.Vector3,\r\n    scales: THREE.Vector3,\r\n    quaternion: THREE.Quaternion,\r\n    opacity: number,\r\n    color: THREE.Color,\r\n  ) {\r\n    const packedSplats = this.ensureSplats(index + 1);\r\n    setPackedSplat(\r\n      packedSplats,\r\n      index,\r\n      center.x,\r\n      center.y,\r\n      center.z,\r\n      scales.x,\r\n      scales.y,\r\n      scales.z,\r\n      quaternion.x,\r\n      quaternion.y,\r\n      quaternion.z,\r\n      quaternion.w,\r\n      opacity,\r\n      color.r,\r\n      color.g,\r\n      color.b,\r\n    );\r\n    this.numSplats = Math.max(this.numSplats, index + 1);\r\n  }\r\n\r\n  // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on\r\n  // construction where you just want to iterate and create a collection of Gsplats.\r\n  pushSplat(\r\n    center: THREE.Vector3,\r\n    scales: THREE.Vector3,\r\n    quaternion: THREE.Quaternion,\r\n    opacity: number,\r\n    color: THREE.Color,\r\n  ) {\r\n    const packedSplats = this.ensureSplats(this.numSplats + 1);\r\n    setPackedSplat(\r\n      packedSplats,\r\n      this.numSplats,\r\n      center.x,\r\n      center.y,\r\n      center.z,\r\n      scales.x,\r\n      scales.y,\r\n      scales.z,\r\n      quaternion.x,\r\n      quaternion.y,\r\n      quaternion.z,\r\n      quaternion.w,\r\n      opacity,\r\n      color.r,\r\n      color.g,\r\n      color.b,\r\n    );\r\n    ++this.numSplats;\r\n  }\r\n\r\n  // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat\r\n  // and invoke the callback function with the Gsplat attributes.\r\n  forEachSplat(\r\n    callback: (\r\n      index: number,\r\n      center: THREE.Vector3,\r\n      scales: THREE.Vector3,\r\n      quaternion: THREE.Quaternion,\r\n      opacity: number,\r\n      color: THREE.Color,\r\n    ) => void,\r\n  ) {\r\n    if (!this.packedArray || !this.numSplats) {\r\n      return;\r\n    }\r\n    for (let i = 0; i < this.numSplats; ++i) {\r\n      const unpacked = unpackSplat(this.packedArray, i, this.splatEncoding);\r\n      callback(\r\n        i,\r\n        unpacked.center,\r\n        unpacked.scales,\r\n        unpacked.quaternion,\r\n        unpacked.opacity,\r\n        unpacked.color,\r\n      );\r\n    }\r\n  }\r\n\r\n  // Ensures our PackedSplats.target render target has enough space to generate\r\n  // maxSplats total Gsplats, and reallocate if not large enough.\r\n  ensureGenerate(maxSplats: number): boolean {\r\n    if (this.target && (maxSplats ?? 1) <= this.maxSplats) {\r\n      return false;\r\n    }\r\n    this.dispose();\r\n\r\n    const textureSize = getTextureSize(maxSplats ?? 1);\r\n    const { width, height, depth } = textureSize;\r\n    this.maxSplats = textureSize.maxSplats;\r\n\r\n    // The packed Gsplats are stored in a 2D array texture of max size\r\n    // 2048 x 2048 x 2048, one RGBA32UI pixel = 4 uint32 = one Gsplat\r\n    this.target = new THREE.WebGLArrayRenderTarget(width, height, depth, {\r\n      depthBuffer: false,\r\n      stencilBuffer: false,\r\n      generateMipmaps: false,\r\n      magFilter: THREE.NearestFilter,\r\n      minFilter: THREE.NearestFilter,\r\n    });\r\n    this.target.texture.format = THREE.RGBAIntegerFormat;\r\n    this.target.texture.type = THREE.UnsignedIntType;\r\n    this.target.texture.internalFormat = \"RGBA32UI\";\r\n    this.target.scissorTest = true;\r\n    return true;\r\n  }\r\n\r\n  // Given an array of splatCounts (.numSplats for each\r\n  // SplatGenerator/SplatMesh in the scene), compute a\r\n  // \"mapping layout\" in the composite array of generated outputs.\r\n  generateMapping(splatCounts: number[]): {\r\n    maxSplats: number;\r\n    mapping: { base: number; count: number }[];\r\n  } {\r\n    let maxSplats = 0;\r\n    const mapping = splatCounts.map((numSplats) => {\r\n      const base = maxSplats;\r\n      // Generation happens in horizontal row chunks, so round up to full width\r\n      const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\r\n      maxSplats += rounded;\r\n      return { base, count: numSplats };\r\n    });\r\n    return { maxSplats, mapping };\r\n  }\r\n\r\n  // Returns a THREE.DataArrayTexture representing the PackedSplats content as\r\n  // a Uint32x4 data array texture (2048 x 2048 x depth in size)\r\n  getTexture(): THREE.DataArrayTexture {\r\n    if (this.target) {\r\n      // Return the render target's texture\r\n      return this.target.texture;\r\n    }\r\n    if (this.source || this.packedArray) {\r\n      // Update source texture if needed and return\r\n      const source = this.maybeUpdateSource();\r\n      return source;\r\n    }\r\n\r\n    return PackedSplats.getEmpty();\r\n  }\r\n\r\n  // Check if source texture needs to be created/updated\r\n  private maybeUpdateSource(): THREE.DataArrayTexture {\r\n    if (!this.packedArray) {\r\n      throw new Error(\"No packed splats\");\r\n    }\r\n\r\n    if (this.needsUpdate || !this.source) {\r\n      this.needsUpdate = false;\r\n\r\n      if (this.source) {\r\n        const { width, height, depth } = this.source.image;\r\n        if (this.maxSplats !== width * height * depth) {\r\n          // The existing source texture isn't the right size, so dispose it\r\n          this.source.dispose();\r\n          this.source = null;\r\n        }\r\n      }\r\n      if (!this.source) {\r\n        // Allocate a new source texture of the right size\r\n        const { width, height, depth } = getTextureSize(this.maxSplats);\r\n        this.source = new THREE.DataArrayTexture(\r\n          this.packedArray,\r\n          width,\r\n          height,\r\n          depth,\r\n        );\r\n        this.source.format = THREE.RGBAIntegerFormat;\r\n        this.source.type = THREE.UnsignedIntType;\r\n        this.source.internalFormat = \"RGBA32UI\";\r\n        this.source.needsUpdate = true;\r\n      } else if (this.packedArray.buffer !== this.source.image.data.buffer) {\r\n        // The source texture is the right size, update the data\r\n        this.source.image.data = new Uint8Array(this.packedArray.buffer);\r\n      }\r\n      // Indicate to Three.js that the source texture needs to be uploaded to the GPU\r\n      this.source.needsUpdate = true;\r\n    }\r\n    return this.source;\r\n  }\r\n\r\n  private static emptySource: THREE.DataArrayTexture | null = null;\r\n\r\n  // Can be used where you need an uninitialized THREE.DataArrayTexture like\r\n  // a uniform you will update with the result of this.getTexture() later.\r\n  static getEmpty(): THREE.DataArrayTexture {\r\n    if (!PackedSplats.emptySource) {\r\n      const { width, height, depth, maxSplats } = getTextureSize(1);\r\n      const emptyArray = new Uint32Array(maxSplats * 4);\r\n      PackedSplats.emptySource = new THREE.DataArrayTexture(\r\n        emptyArray,\r\n        width,\r\n        height,\r\n        depth,\r\n      );\r\n      PackedSplats.emptySource.format = THREE.RGBAIntegerFormat;\r\n      PackedSplats.emptySource.type = THREE.UnsignedIntType;\r\n      PackedSplats.emptySource.internalFormat = \"RGBA32UI\";\r\n      PackedSplats.emptySource.needsUpdate = true;\r\n    }\r\n    return PackedSplats.emptySource;\r\n  }\r\n\r\n  // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,\r\n  // generating it if necessary and caching the result.\r\n  prepareProgramMaterial(generator: GsplatGenerator): {\r\n    program: DynoProgram;\r\n    material: THREE.RawShaderMaterial;\r\n  } {\r\n    let program = PackedSplats.generatorProgram.get(generator);\r\n    if (!program) {\r\n      // A Gsplat needs to be turned into a packed uvec4 for the dyno graph\r\n      const graph = dynoBlock(\r\n        { index: \"int\" },\r\n        { output: \"uvec4\" },\r\n        ({ index }) => {\r\n          generator.inputs.index = index;\r\n          const gsplat = generator.outputs.gsplat;\r\n          const output = outputPackedSplat(\r\n            gsplat,\r\n            this.dynoRgbMinMaxLnScaleMinMax,\r\n          );\r\n          return { output };\r\n        },\r\n      );\r\n      if (!PackedSplats.programTemplate) {\r\n        PackedSplats.programTemplate = new DynoProgramTemplate(\r\n          computeUvec4Template,\r\n        );\r\n      }\r\n      // Create a program from the template and graph\r\n      program = new DynoProgram({\r\n        graph,\r\n        inputs: { index: \"index\" },\r\n        outputs: { output: \"target\" },\r\n        template: PackedSplats.programTemplate,\r\n      });\r\n      Object.assign(program.uniforms, {\r\n        targetLayer: { value: 0 },\r\n        targetBase: { value: 0 },\r\n        targetCount: { value: 0 },\r\n      });\r\n      PackedSplats.generatorProgram.set(generator, program);\r\n    }\r\n\r\n    // Prepare and update our material we'll use to render the Gsplats\r\n    const material = program.prepareMaterial();\r\n    PackedSplats.fullScreenQuad.material = material;\r\n    return { program, material };\r\n  }\r\n\r\n  private saveRenderState(renderer: THREE.WebGLRenderer) {\r\n    return {\r\n      xrEnabled: renderer.xr.enabled,\r\n      autoClear: renderer.autoClear,\r\n    };\r\n  }\r\n\r\n  private resetRenderState(\r\n    renderer: THREE.WebGLRenderer,\r\n    state: {\r\n      xrEnabled: boolean;\r\n      autoClear: boolean;\r\n    },\r\n  ) {\r\n    renderer.setRenderTarget(null);\r\n    renderer.xr.enabled = state.xrEnabled;\r\n    renderer.autoClear = state.autoClear;\r\n  }\r\n\r\n  // Executes a dyno program specified by generator which is any DynoBlock that\r\n  // maps { index: \"int\" } to { gsplat: Gsplat }. This is called in\r\n  // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for\r\n  // SplatGenerator instances whose version is newer than what was generated\r\n  // for it last time.\r\n  generate({\r\n    generator,\r\n    base,\r\n    count,\r\n    renderer,\r\n  }: {\r\n    generator: GsplatGenerator;\r\n    base: number;\r\n    count: number;\r\n    renderer: THREE.WebGLRenderer;\r\n  }): { nextBase: number } {\r\n    if (!this.target) {\r\n      throw new Error(\"Target must be initialized with ensureSplats\");\r\n    }\r\n    if (base + count > this.maxSplats) {\r\n      throw new Error(\"Base + count exceeds maxSplats\");\r\n    }\r\n\r\n    const { program, material } = this.prepareProgramMaterial(generator);\r\n    program.update();\r\n\r\n    const renderState = this.saveRenderState(renderer);\r\n\r\n    // Generate the Gsplats in \"layer\" chunks, in horizontal row ranges,\r\n    // that cover the total count of Gsplats.\r\n    const nextBase =\r\n      Math.ceil((base + count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\r\n    const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\r\n    material.uniforms.targetBase.value = base;\r\n    material.uniforms.targetCount.value = count;\r\n\r\n    // Keep generating layers until we've reached the next generation's base\r\n    while (base < nextBase) {\r\n      const layer = Math.floor(base / layerSize);\r\n      material.uniforms.targetLayer.value = layer;\r\n\r\n      const layerBase = layer * layerSize;\r\n      const layerYStart = Math.floor((base - layerBase) / SPLAT_TEX_WIDTH);\r\n      const layerYEnd = Math.min(\r\n        SPLAT_TEX_HEIGHT,\r\n        Math.ceil((nextBase - layerBase) / SPLAT_TEX_WIDTH),\r\n      );\r\n\r\n      // Render the desired portion of the layer\r\n      this.target.scissor.set(\r\n        0,\r\n        layerYStart,\r\n        SPLAT_TEX_WIDTH,\r\n        layerYEnd - layerYStart,\r\n      );\r\n      renderer.setRenderTarget(this.target, layer);\r\n      renderer.xr.enabled = false;\r\n      renderer.autoClear = false;\r\n      PackedSplats.fullScreenQuad.render(renderer);\r\n\r\n      base += SPLAT_TEX_WIDTH * (layerYEnd - layerYStart);\r\n    }\r\n\r\n    this.resetRenderState(renderer, renderState);\r\n    return { nextBase };\r\n  }\r\n\r\n  static programTemplate: DynoProgramTemplate | null = null;\r\n\r\n  // Cache for GsplatGenerator programs\r\n  static generatorProgram = new Map<GsplatGenerator, DynoProgram>();\r\n\r\n  // Static full-screen quad for pseudo-compute shader rendering\r\n  static fullScreenQuad = new FullScreenQuad(\r\n    new THREE.RawShaderMaterial({ visible: false }),\r\n  );\r\n}\r\n\r\n// You can use a PackedSplats as a dyno block using the function\r\n// dyno.readPackedSplats(packedSplats.dyno, dynoIndex) where\r\n// dynoIndex is of type DynoVal<\"int\">. If you need to be able to change\r\n// the input PackedSplats dynamically, however, you should create a\r\n// DynoPackedSplats, whose property packedSplats you can change to any\r\n// PackedSplats and that will be used in the dyno shader program.\r\n\r\nexport const dynoPackedSplats = (packedSplats?: PackedSplats) =>\r\n  new DynoPackedSplats({ packedSplats });\r\n\r\nexport class DynoPackedSplats extends DynoUniform<\r\n  typeof TPackedSplats,\r\n  \"packedSplats\",\r\n  {\r\n    texture: THREE.DataArrayTexture;\r\n    numSplats: number;\r\n    rgbMinMaxLnScaleMinMax: THREE.Vector4;\r\n  }\r\n> {\r\n  packedSplats?: PackedSplats;\r\n\r\n  constructor({ packedSplats }: { packedSplats?: PackedSplats } = {}) {\r\n    super({\r\n      key: \"packedSplats\",\r\n      type: TPackedSplats,\r\n      globals: () => [definePackedSplats],\r\n      value: {\r\n        texture: PackedSplats.getEmpty(),\r\n        numSplats: 0,\r\n        rgbMinMaxLnScaleMinMax: new THREE.Vector4(\r\n          0,\r\n          1,\r\n          LN_SCALE_MIN,\r\n          LN_SCALE_MAX,\r\n        ),\r\n      },\r\n      update: (value) => {\r\n        value.texture =\r\n          this.packedSplats?.getTexture() ?? PackedSplats.getEmpty();\r\n        value.numSplats = this.packedSplats?.numSplats ?? 0;\r\n        value.rgbMinMaxLnScaleMinMax.set(\r\n          this.packedSplats?.splatEncoding?.rgbMin ?? 0,\r\n          this.packedSplats?.splatEncoding?.rgbMax ?? 1,\r\n          this.packedSplats?.splatEncoding?.lnScaleMin ?? LN_SCALE_MIN,\r\n          this.packedSplats?.splatEncoding?.lnScaleMax ?? LN_SCALE_MAX,\r\n        );\r\n        return value;\r\n      },\r\n    });\r\n    this.packedSplats = packedSplats;\r\n  }\r\n}\r\n","import * as THREE from \"three\";\r\n\r\n// SplatGeometry is an internal class used by SparkRenderer to render a collection\r\n// of Gsplats in a single draw call by extending THREE.InstancedBufferGeometry.\r\n// Each Gsplat is drawn as two triangles, with the order of the Gsplats determined\r\n// by the instance attribute \"ordering\".\r\n\r\nexport class SplatGeometry extends THREE.InstancedBufferGeometry {\r\n  ordering: Uint32Array;\r\n  attribute: THREE.InstancedBufferAttribute;\r\n\r\n  constructor(ordering: Uint32Array, activeSplats: number) {\r\n    super();\r\n\r\n    this.ordering = ordering;\r\n\r\n    this.setAttribute(\"position\", new THREE.BufferAttribute(QUAD_VERTICES, 3));\r\n    this.setIndex(new THREE.BufferAttribute(QUAD_INDICES, 1));\r\n\r\n    // Hack to work around Three.js\r\n    // @ts-ignore\r\n    this._maxInstanceCount = ordering.length;\r\n    this.instanceCount = activeSplats;\r\n\r\n    this.attribute = new THREE.InstancedBufferAttribute(ordering, 1, false, 1);\r\n    this.attribute.setUsage(THREE.DynamicDrawUsage);\r\n    this.setAttribute(\"splatIndex\", this.attribute);\r\n  }\r\n\r\n  update(ordering: Uint32Array, activeSplats: number) {\r\n    this.ordering = ordering;\r\n    this.attribute.array = ordering;\r\n    this.instanceCount = activeSplats;\r\n    this.attribute.addUpdateRange(0, activeSplats);\r\n    this.attribute.needsUpdate = true;\r\n  }\r\n}\r\n\r\n// Each instance draws to triangles covering a quad over coords (-1,-1,0)..(1,1,0)\r\nconst QUAD_VERTICES = new Float32Array([\r\n  -1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0,\r\n]);\r\n\r\nconst QUAD_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3]);\r\n","import * as THREE from \"three\";\r\n\r\nimport { DynoPackedSplats } from \"./PackedSplats\";\r\nimport { Readback } from \"./Readback\";\r\nimport type { SparkRenderer } from \"./SparkRenderer\";\r\nimport type { SplatAccumulator } from \"./SplatAccumulator\";\r\nimport { SplatGeometry } from \"./SplatGeometry\";\r\nimport {\r\n  type DynoBlock,\r\n  DynoBool,\r\n  DynoFloat,\r\n  type DynoVal,\r\n  DynoVec3,\r\n  Gsplat,\r\n  add,\r\n  combine,\r\n  defineGsplat,\r\n  dyno,\r\n  dynoBlock,\r\n  dynoConst,\r\n  floatBitsToUint,\r\n  mul,\r\n  packHalf2x16,\r\n  readPackedSplat,\r\n  uintToRgba8,\r\n  unindent,\r\n  unindentLines,\r\n} from \"./dyno\";\r\nimport { withWorker } from \"./splatWorker\";\r\nimport { FreeList, withinCoorientDist } from \"./utils\";\r\n\r\nexport type SparkViewpointOptions = {\r\n  /**\r\n   * Controls whether to auto-update its sort order whenever the SparkRenderer\r\n   * updates the Gsplats. If you expect to render/display from this viewpoint\r\n   * most frames, set this to true.\r\n   * @default false\r\n   */\r\n  autoUpdate?: boolean;\r\n  /**\r\n   * Set a THREE.Camera for this viewpoint to follow.\r\n   * @default undefined\r\n   */\r\n  camera?: THREE.Camera;\r\n  /**\r\n   * Set an explicit view-to-world transformation matrix for this viewpoint (equivalent\r\n   * to camera.matrixWorld), overrides any camera setting.\r\n   * @default undefined\r\n   */\r\n  viewToWorld?: THREE.Matrix4;\r\n  /**\r\n   * Configure viewpoint with an off-screen render target.\r\n   * @default undefined\r\n   */\r\n  target?: {\r\n    /**\r\n     * Width of the render target in pixels.\r\n     */\r\n    width: number;\r\n    /**\r\n     * Height of the render target in pixels.\r\n     */\r\n    height: number;\r\n    /**\r\n     * If you want to be able to render a scene that depends on this target's\r\n     * output (for example, a recursive viewport), set this to true to enable\r\n     * double buffering.\r\n     * @default false\r\n     */\r\n    doubleBuffer?: boolean;\r\n    /**\r\n     * Super-sampling factor for the render target. Values 1-4 are supported.\r\n     * Note that re-sampling back down to .width x .height is done on the CPU\r\n     * with simple averaging only when calling readTarget().\r\n     * @default 1\r\n     */\r\n    superXY?: number;\r\n  };\r\n  /**\r\n   * Callback function that is called when the render target texture is updated.\r\n   * Receives the texture as a parameter. Use this to update a viewport with\r\n   * the latest viewpoint render each frame.\r\n   * @default undefined\r\n   */\r\n  onTextureUpdated?: (texture: THREE.Texture) => void;\r\n  /**\r\n   * Whether to sort splats radially (geometric distance) from the viewpoint (true)\r\n   * or by Z-depth (false). Most scenes are trained with the Z-depth sort metric\r\n   * and will render more accurately at certain viewpoints. However, radial sorting\r\n   * is more stable under viewpoint rotations.\r\n   * @default true\r\n   */\r\n  sortRadial?: boolean;\r\n  /**\r\n   * Distance threshold for re-sorting splats. If the viewpoint moves more than\r\n   * this distance, splats will be re-sorted.\r\n   * @default 0.01 units\r\n   */\r\n  sortDistance?: number;\r\n  /**\r\n   * View direction dot product threshold for re-sorting splats. For\r\n   * sortRadial: true we use 0.99 while sortRadial: false uses 0.999 because it is\r\n   * more sensitive to view direction.\r\n   * @default 0.99 if sortRadial else 0.999\r\n   */\r\n  sortCoorient?: boolean;\r\n  /**\r\n   * Constant added to Z-depth to bias values into the positive range for\r\n   * sortRadial: false, but also used for culling Gsplats \"well behind\"\r\n   * the viewpoint origin\r\n   * @default 1.0\r\n   */\r\n  depthBias?: number;\r\n  /**\r\n   * Set this to true if rendering a 360 to disable \"behind the viewpoint\"\r\n   * culling during sorting. This is set automatically when rendering 360 envMaps\r\n   * using the SparkRenderer.renderEnvMap() utility function.\r\n   * @default false\r\n   */\r\n  sort360?: boolean;\r\n  /*\r\n   * Set this to true to sort with float32 precision with two-pass sort.\r\n   * @default true\r\n   */\r\n  sort32?: boolean;\r\n  /*\r\n   * Set this to true to enable sort-free stochastic splat rendering.\r\n   * @default false\r\n   */\r\n  stochastic?: boolean;\r\n};\r\n\r\n// A SparkViewpoint is created from and tied to a SparkRenderer, and represents\r\n// an independent viewpoint of all the scene Gsplats and their sort order. Making\r\n// these viewpoints explicit allows us to have multiple, simultaneous viewpoint\r\n// renders, for example for camera preview panes or overhead map views.\r\n//\r\n// When creating a SparkRenderer it automatically creates a default viewpoint\r\n// .defaultView that is used in the normal render loop when drawing to the canvas,\r\n// and is automatically updated whenever the camera moves. Additional viewpoints\r\n// can be created and configured separately.\r\n\r\nexport class SparkViewpoint {\r\n  spark: SparkRenderer;\r\n  autoUpdate: boolean;\r\n  camera?: THREE.Camera;\r\n  viewToWorld: THREE.Matrix4;\r\n  lastTime: number | null = null;\r\n\r\n  target?: THREE.WebGLRenderTarget;\r\n  private back?: THREE.WebGLRenderTarget;\r\n  onTextureUpdated?: (texture: THREE.Texture) => void;\r\n  encodeLinear = false;\r\n  superXY = 1;\r\n  private superPixels?: Uint8Array;\r\n  private pixels?: Uint8Array;\r\n\r\n  sortRadial: boolean;\r\n  sortDistance?: number;\r\n  sortCoorient?: boolean;\r\n  depthBias?: number;\r\n  sort360?: boolean;\r\n  sort32?: boolean;\r\n  stochastic: boolean;\r\n\r\n  display: {\r\n    accumulator: SplatAccumulator;\r\n    viewToWorld: THREE.Matrix4;\r\n    geometry: SplatGeometry;\r\n  } | null = null;\r\n\r\n  private sorting: { viewToWorld: THREE.Matrix4 } | null = null;\r\n  private pending: {\r\n    accumulator?: SplatAccumulator;\r\n    viewToWorld: THREE.Matrix4;\r\n    displayed: boolean;\r\n  } | null = null;\r\n  private sortingCheck = false;\r\n\r\n  private readback16: Uint16Array = new Uint16Array(0);\r\n  private readback32: Uint32Array = new Uint32Array(0);\r\n  private orderingFreelist: FreeList<Uint32Array, number>;\r\n\r\n  constructor(options: SparkViewpointOptions & { spark: SparkRenderer }) {\r\n    this.spark = options.spark;\r\n    this.camera = options.camera;\r\n    this.viewToWorld = options.viewToWorld ?? new THREE.Matrix4();\r\n\r\n    if (options.target) {\r\n      const { width, height, doubleBuffer } = options.target;\r\n      const superXY = Math.max(1, Math.min(4, options.target.superXY ?? 1));\r\n      this.superXY = superXY;\r\n      if (width * superXY > 8192 || height * superXY > 8192) {\r\n        throw new Error(\"Target size too large\");\r\n      }\r\n\r\n      this.target = new THREE.WebGLRenderTarget(\r\n        width * superXY,\r\n        height * superXY,\r\n        {\r\n          format: THREE.RGBAFormat,\r\n          type: THREE.UnsignedByteType,\r\n          colorSpace: THREE.SRGBColorSpace,\r\n        },\r\n      );\r\n      if (doubleBuffer) {\r\n        this.back = new THREE.WebGLRenderTarget(\r\n          width * superXY,\r\n          height * superXY,\r\n          {\r\n            format: THREE.RGBAFormat,\r\n            type: THREE.UnsignedByteType,\r\n            colorSpace: THREE.SRGBColorSpace,\r\n          },\r\n        );\r\n      }\r\n      this.encodeLinear = true;\r\n    }\r\n    this.onTextureUpdated = options.onTextureUpdated;\r\n\r\n    this.sortRadial = options.sortRadial ?? true;\r\n    this.sortDistance = options.sortDistance;\r\n    this.sortCoorient = options.sortCoorient;\r\n    this.depthBias = options.depthBias;\r\n    this.sort360 = options.sort360;\r\n    this.sort32 = options.sort32;\r\n    this.stochastic = options.stochastic ?? false;\r\n\r\n    this.orderingFreelist = new FreeList({\r\n      allocate: (maxSplats) => new Uint32Array(maxSplats),\r\n      valid: (ordering, maxSplats) => ordering.length === maxSplats,\r\n    });\r\n\r\n    this.autoUpdate = false;\r\n    this.setAutoUpdate(options.autoUpdate ?? false);\r\n  }\r\n\r\n  // Call this when you are done with the SparkViewpoint and want to\r\n  // free up its resources (GPU targets, pixel buffers, etc.)\r\n  dispose() {\r\n    this.setAutoUpdate(false);\r\n    if (this.target) {\r\n      this.target.dispose();\r\n      this.target = undefined;\r\n    }\r\n    if (this.back) {\r\n      this.back.dispose();\r\n      this.back = undefined;\r\n    }\r\n    if (this.display) {\r\n      this.spark.releaseAccumulator(this.display.accumulator);\r\n      this.display.geometry.dispose();\r\n      this.display = null;\r\n    }\r\n    if (this.pending?.accumulator) {\r\n      this.spark.releaseAccumulator(this.pending.accumulator);\r\n      this.pending = null;\r\n    }\r\n  }\r\n\r\n  // Use this function to change whether this viewpoint will auto-update\r\n  // its sort order whenever the attached SparkRenderer updates the Gsplats.\r\n  // Turn this on or off depending on whether you expect to do renders from\r\n  // this viewpoint most frames.\r\n  setAutoUpdate(autoUpdate: boolean) {\r\n    if (!this.autoUpdate && autoUpdate) {\r\n      this.spark.autoViewpoints.push(this);\r\n    } else if (this.autoUpdate && !autoUpdate) {\r\n      this.spark.autoViewpoints = this.spark.autoViewpoints.filter(\r\n        (v) => v !== this,\r\n      );\r\n    }\r\n    this.autoUpdate = autoUpdate;\r\n  }\r\n\r\n  // See below async prepareRenderPixels() for explanation of parameters.\r\n  // Awaiting this method updates the Gsplats in the scene and performs a sort of the\r\n  // Gsplats from this viewpoint, preparing it for a subsequent this.renderTarget()\r\n  // call in the same tick.\r\n  async prepare({\r\n    scene,\r\n    camera,\r\n    viewToWorld,\r\n    update,\r\n    forceOrigin,\r\n  }: {\r\n    scene: THREE.Scene;\r\n    camera?: THREE.Camera;\r\n    viewToWorld?: THREE.Matrix4;\r\n    update?: boolean;\r\n    forceOrigin?: boolean;\r\n  }) {\r\n    if (viewToWorld) {\r\n      this.viewToWorld = viewToWorld;\r\n    } else {\r\n      this.camera = camera ?? this.camera;\r\n      if (this.camera) {\r\n        this.camera.updateMatrixWorld();\r\n        this.viewToWorld = this.camera.matrixWorld.clone();\r\n      }\r\n    }\r\n    while (update ?? true) {\r\n      // Force an update, possibly with origin centered at this camera\r\n      // to yield the best quality output.\r\n      const originToWorld = forceOrigin\r\n        ? this.viewToWorld\r\n        : this.spark.matrixWorld;\r\n      const updated = this.spark.updateInternal({ scene, originToWorld });\r\n      if (updated) {\r\n        break;\r\n      }\r\n      // A bit of a hack, but try again. We shouldn't be starved for long.\r\n      await new Promise((resolve) => setTimeout(resolve, 10));\r\n    }\r\n\r\n    const accumulator = this.spark.active;\r\n    // Hold reference to accumulator while sorting\r\n    accumulator.refCount += 1;\r\n    await this.sortUpdate({ accumulator, viewToWorld: this.viewToWorld });\r\n    // Release accumulator reference\r\n    this.spark.releaseAccumulator(accumulator);\r\n  }\r\n\r\n  // Render out the viewpoint to the view target RGBA buffer.\r\n  // Swaps buffers if doubleBuffer: true was set.\r\n  // Calls onTextureUpdated(texture) with the resulting texture.\r\n  renderTarget({\r\n    scene,\r\n    camera,\r\n  }: { scene: THREE.Scene; camera?: THREE.Camera }) {\r\n    const target = this.back ?? this.target;\r\n    if (!target) {\r\n      throw new Error(\"Must initialize SparkViewpoint with target\");\r\n    }\r\n\r\n    camera = camera ?? this.camera;\r\n    if (!camera) {\r\n      throw new Error(\"Must provide camera\");\r\n    }\r\n    if (camera instanceof THREE.PerspectiveCamera) {\r\n      const newCam = new THREE.PerspectiveCamera().copy(camera, false);\r\n      newCam.aspect = target.width / target.height;\r\n      newCam.updateProjectionMatrix();\r\n      camera = newCam;\r\n    }\r\n    this.viewToWorld = camera.matrixWorld.clone();\r\n\r\n    try {\r\n      this.spark.renderer.setRenderTarget(target);\r\n      this.spark.prepareViewpoint(this);\r\n\r\n      this.spark.renderer.render(scene, camera);\r\n    } finally {\r\n      this.spark.prepareViewpoint(this.spark.defaultView);\r\n      this.spark.renderer.setRenderTarget(null);\r\n    }\r\n\r\n    if (target !== this.target) {\r\n      // Swap back buffer and target\r\n      [this.target, this.back] = [this.back, this.target];\r\n    }\r\n    this.onTextureUpdated?.(target.texture);\r\n  }\r\n\r\n  // Read back the previously rendered target image as a Uint8Array of packed\r\n  // RGBA values (in that order). If superXY was set greater than 1 then\r\n  // downsampling is performed in the target pixel array with simple averaging\r\n  // to derive the returned pixel values. Subsequent calls to this.readTarget()\r\n  // will reuse the same buffers to minimize memory allocations.\r\n  async readTarget(): Promise<Uint8Array> {\r\n    if (!this.target) {\r\n      throw new Error(\"Must initialize SparkViewpoint with target\");\r\n    }\r\n    const { width, height } = this.target;\r\n    const byteSize = width * height * 4;\r\n    if (!this.superPixels || this.superPixels.length < byteSize) {\r\n      this.superPixels = new Uint8Array(byteSize);\r\n    }\r\n    await this.spark.renderer.readRenderTargetPixelsAsync(\r\n      this.target,\r\n      0,\r\n      0,\r\n      width,\r\n      height,\r\n      this.superPixels,\r\n    );\r\n\r\n    const { superXY } = this;\r\n    if (superXY === 1) {\r\n      return this.superPixels;\r\n    }\r\n\r\n    const subWidth = width / superXY;\r\n    const subHeight = height / superXY;\r\n    const subSize = subWidth * subHeight * 4;\r\n    if (!this.pixels || this.pixels.length < subSize) {\r\n      this.pixels = new Uint8Array(subSize);\r\n    }\r\n\r\n    const { superPixels, pixels } = this;\r\n    const super2 = superXY * superXY;\r\n    for (let y = 0; y < subHeight; y++) {\r\n      const row = y * subWidth;\r\n      for (let x = 0; x < subWidth; x++) {\r\n        const superCol = x * superXY;\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        let a = 0;\r\n        for (let sy = 0; sy < superXY; sy++) {\r\n          const superRow = (y * superXY + sy) * this.target.width;\r\n          for (let sx = 0; sx < superXY; sx++) {\r\n            const superIndex = (superRow + superCol + sx) * 4;\r\n            r += superPixels[superIndex];\r\n            g += superPixels[superIndex + 1];\r\n            b += superPixels[superIndex + 2];\r\n            a += superPixels[superIndex + 3];\r\n          }\r\n        }\r\n        const pixelIndex = (row + x) * 4;\r\n        pixels[pixelIndex] = r / super2;\r\n        pixels[pixelIndex + 1] = g / super2;\r\n        pixels[pixelIndex + 2] = b / super2;\r\n        pixels[pixelIndex + 3] = a / super2;\r\n      }\r\n    }\r\n    return pixels;\r\n  }\r\n\r\n  // Render out a viewpoint as a Uint8Array of RGBA values for the provided scene\r\n  // and any camera/viewToWorld viewpoint overrides. By default update is true,\r\n  // which triggers its SparkRenderer to check and potentially update the Gsplats.\r\n  // Setting update to false disables this and sorts the Gsplats as they are.\r\n  // Setting forceOrigin (default: false) to true forces the view update to\r\n  // recalculate the splats with this view origin, potentially altering any\r\n  // view-dependent effects. If you expect view-dependent effects to play a role\r\n  // in the rendering quality, enable this.\r\n  //\r\n  // Underneath, prepareRenderPixels() simply calls await this.prepare(...),\r\n  // this.renderTarget(...), and finally returns the result this.readTarget(),\r\n  // a Promise to a Uint8Array with RGBA values for all the pixels (potentially\r\n  // downsampled if the superXY parameter was used). These steps can also be called\r\n  // manually, for example if you need to alter the scene before and after\r\n  // this.renderTarget(...) to hide UI elements from being rendered.\r\n  async prepareRenderPixels({\r\n    scene,\r\n    camera,\r\n    viewToWorld,\r\n    update,\r\n    forceOrigin,\r\n  }: {\r\n    scene: THREE.Scene;\r\n    camera?: THREE.Camera;\r\n    viewToWorld?: THREE.Matrix4;\r\n    update?: boolean;\r\n    forceOrigin?: boolean;\r\n  }) {\r\n    await this.prepare({ scene, camera, viewToWorld, update, forceOrigin });\r\n    this.renderTarget({ scene, camera });\r\n    return this.readTarget();\r\n  }\r\n\r\n  // This is called automatically by SparkRenderer, there is no need to call it!\r\n  // The method cannot be private because then SparkRenderer would\r\n  // not be able to call it.\r\n  autoPoll({ accumulator }: { accumulator?: SplatAccumulator }) {\r\n    if (this.camera) {\r\n      this.camera.updateMatrixWorld();\r\n      this.viewToWorld = this.camera.matrixWorld.clone();\r\n    }\r\n\r\n    let needsSort = false;\r\n    let displayed = false;\r\n\r\n    if (!this.display) {\r\n      // Need to do first sort\r\n      needsSort = true;\r\n    } else if (accumulator) {\r\n      needsSort = true;\r\n      const { mappingVersion } = this.display.accumulator;\r\n      if (accumulator.mappingVersion === mappingVersion) {\r\n        // Splat mapping has not changed, so reuse the existing sorted\r\n        // geometry to show updates faster. We will still fire off\r\n        // a re-sort if necessary. First release old accumulator.\r\n        accumulator.refCount += 1;\r\n        this.spark.releaseAccumulator(this.display.accumulator);\r\n        this.display.accumulator = accumulator;\r\n        this.display.viewToWorld.copy(this.viewToWorld);\r\n        displayed = true;\r\n\r\n        if (this.spark.viewpoint === this) {\r\n          this.spark.prepareViewpoint(this);\r\n        }\r\n      }\r\n    }\r\n\r\n    const latestView = this.sorting?.viewToWorld ?? this.display?.viewToWorld;\r\n    if (\r\n      latestView &&\r\n      !withinCoorientDist({\r\n        matrix1: this.viewToWorld,\r\n        matrix2: latestView,\r\n        // By default update sort each 1 cm\r\n        maxDistance: this.sortDistance ?? 0.01,\r\n        // By default for radial sort, update for intermittent movement so that\r\n        // we bring back splats culled by being behind the camera.\r\n        // For depth sort, small rotations can change sort order a lot, so\r\n        // update sort for even small rotations.\r\n        minCoorient: (this.sortCoorient ?? this.sortRadial) ? 0.99 : 0.999,\r\n      })\r\n    ) {\r\n      needsSort = true;\r\n    }\r\n\r\n    if (!needsSort) {\r\n      // Stop here, no sort necessary\r\n      return;\r\n    }\r\n\r\n    if (accumulator) {\r\n      // Hold a reference to the accumulator for sorting\r\n      accumulator.refCount += 1;\r\n    }\r\n\r\n    if (this.pending?.accumulator) {\r\n      // Release the reference of the pending accumulator\r\n      this.spark.releaseAccumulator(this.pending.accumulator);\r\n    }\r\n    this.pending = { accumulator, viewToWorld: this.viewToWorld, displayed };\r\n\r\n    // Don't await this, just trigger the sort if necessary\r\n    this.driveSort();\r\n  }\r\n\r\n  private async driveSort() {\r\n    while (true) {\r\n      if (this.sorting || !this.pending) {\r\n        return; // Sort already in process or nothing to sort\r\n      }\r\n\r\n      const { viewToWorld, displayed } = this.pending;\r\n      let accumulator = this.pending.accumulator;\r\n      if (!accumulator) {\r\n        // Hold a reference to the accumulator while sorting\r\n        accumulator = this.display?.accumulator ?? this.spark.active;\r\n        accumulator.refCount += 1;\r\n      }\r\n      this.pending = null;\r\n      if (!accumulator) {\r\n        throw new Error(\"No accumulator to sort\");\r\n      }\r\n\r\n      this.sorting = { viewToWorld };\r\n      await this.sortUpdate({ accumulator, viewToWorld, displayed });\r\n      this.sorting = null;\r\n\r\n      // Release the reference to the accumulator\r\n      this.spark.releaseAccumulator(accumulator);\r\n\r\n      // Continue in loop with any queued sort\r\n    }\r\n  }\r\n\r\n  private async sortUpdate({\r\n    accumulator,\r\n    viewToWorld,\r\n    displayed = false,\r\n  }: {\r\n    accumulator?: SplatAccumulator;\r\n    viewToWorld: THREE.Matrix4;\r\n    displayed?: boolean;\r\n  }) {\r\n    if (this.sortingCheck) {\r\n      throw new Error(\"Only one sort at a time\");\r\n    }\r\n    this.sortingCheck = true;\r\n\r\n    accumulator = accumulator ?? this.spark.active;\r\n    const { numSplats, maxSplats } = accumulator.splats;\r\n    let activeSplats = 0;\r\n    let ordering = this.orderingFreelist.alloc(maxSplats);\r\n\r\n    if (this.stochastic) {\r\n      activeSplats = numSplats;\r\n      // Render all splats in order since the Z-buffer\r\n      // will handle ordering.\r\n      for (let i = 0; i < numSplats; ++i) {\r\n        ordering[i] = i;\r\n      }\r\n    } else if (numSplats > 0) {\r\n      const {\r\n        reader,\r\n        doubleSortReader,\r\n        sort32Reader,\r\n        dynoSortRadial,\r\n        dynoOrigin,\r\n        dynoDirection,\r\n        dynoDepthBias,\r\n        dynoSort360,\r\n        dynoSplats,\r\n      } = SparkViewpoint.makeSorter();\r\n      const sort32 = this.sort32 ?? false;\r\n      let readback: Uint16Array | Uint32Array;\r\n      if (sort32) {\r\n        this.readback32 = reader.ensureBuffer(maxSplats, this.readback32);\r\n        readback = this.readback32;\r\n      } else {\r\n        const halfMaxSplats = Math.ceil(maxSplats / 2);\r\n        this.readback16 = reader.ensureBuffer(halfMaxSplats, this.readback16);\r\n        readback = this.readback16;\r\n      }\r\n\r\n      const worldToOrigin = accumulator.toWorld.clone().invert();\r\n      const viewToOrigin = viewToWorld.clone().premultiply(worldToOrigin);\r\n\r\n      dynoSortRadial.value = this.sort360 ? true : this.sortRadial;\r\n      dynoOrigin.value.set(0, 0, 0).applyMatrix4(viewToOrigin);\r\n      dynoDirection.value\r\n        .set(0, 0, -1)\r\n        .applyMatrix4(viewToOrigin)\r\n        .sub(dynoOrigin.value)\r\n        .normalize();\r\n      dynoDepthBias.value = this.depthBias ?? 1.0;\r\n      dynoSort360.value = this.sort360 ?? false;\r\n      dynoSplats.packedSplats = accumulator.splats;\r\n\r\n      const sortReader = sort32 ? sort32Reader : doubleSortReader;\r\n      const count = sort32 ? numSplats : Math.ceil(numSplats / 2);\r\n      await reader.renderReadback({\r\n        renderer: this.spark.renderer,\r\n        reader: sortReader,\r\n        count,\r\n        readback,\r\n      });\r\n\r\n      const result = (await withWorker(async (worker) => {\r\n        const rpcName = sort32 ? \"sort32Splats\" : \"sortDoubleSplats\";\r\n        return worker.call(rpcName, {\r\n          maxSplats,\r\n          numSplats,\r\n          readback,\r\n          ordering,\r\n        });\r\n      })) as {\r\n        readback: Uint16Array | Uint32Array;\r\n        ordering: Uint32Array;\r\n        activeSplats: number;\r\n      };\r\n      if (sort32) {\r\n        this.readback32 = result.readback as Uint32Array;\r\n      } else {\r\n        this.readback16 = result.readback as Uint16Array;\r\n      }\r\n      ordering = result.ordering;\r\n      activeSplats = result.activeSplats;\r\n    }\r\n\r\n    this.updateDisplay({\r\n      accumulator,\r\n      viewToWorld,\r\n      ordering,\r\n      activeSplats,\r\n      displayed,\r\n    });\r\n    this.sortingCheck = false;\r\n  }\r\n\r\n  private updateDisplay({\r\n    accumulator,\r\n    viewToWorld,\r\n    ordering,\r\n    activeSplats,\r\n    displayed = false,\r\n  }: {\r\n    accumulator: SplatAccumulator;\r\n    viewToWorld: THREE.Matrix4;\r\n    ordering: Uint32Array;\r\n    activeSplats: number;\r\n    displayed?: boolean;\r\n  }) {\r\n    if (!this.display) {\r\n      // Hold a reference to the accumulator while part of display\r\n      accumulator.refCount += 1;\r\n      this.display = {\r\n        accumulator,\r\n        viewToWorld,\r\n        geometry: new SplatGeometry(ordering, activeSplats),\r\n      };\r\n    } else {\r\n      if (!displayed && accumulator !== this.display.accumulator) {\r\n        // Hold a reference to the new accumulator being displayed\r\n        accumulator.refCount += 1;\r\n        // Release the reference to the previously displayed accumulator\r\n        this.spark.releaseAccumulator(this.display.accumulator);\r\n        this.display.accumulator = accumulator;\r\n      }\r\n\r\n      this.display.viewToWorld = viewToWorld;\r\n\r\n      const oldOrdering = this.display.geometry.ordering;\r\n      if (oldOrdering.length === ordering.length) {\r\n        this.display.geometry.update(ordering, activeSplats);\r\n      } else {\r\n        this.display.geometry.dispose();\r\n        // console.log(\"*** alloc SplatGeometry\", ordering.length);\r\n        this.display.geometry = new SplatGeometry(ordering, activeSplats);\r\n      }\r\n      this.orderingFreelist.free(oldOrdering);\r\n    }\r\n    if (this.spark.viewpoint === this) {\r\n      this.spark.prepareViewpoint(this);\r\n    }\r\n  }\r\n\r\n  // If you need an empty THREE.Texture to use to initialize a uniform that is\r\n  // updated via onTextureUpdated(texture), this static texture can be handy.\r\n  static EMPTY_TEXTURE = new THREE.Texture();\r\n\r\n  private static dynos: {\r\n    dynoSortRadial: DynoBool<string>;\r\n    dynoOrigin: DynoVec3<THREE.Vector3, \"value\">;\r\n    dynoDirection: DynoVec3<THREE.Vector3, \"value\">;\r\n    dynoDepthBias: DynoFloat<string>;\r\n    dynoSort360: DynoBool<string>;\r\n    dynoSplats: DynoPackedSplats;\r\n    reader: Readback;\r\n    doubleSortReader: DynoBlock<{ index: \"int\" }, { rgba8: \"vec4\" }>;\r\n    sort32Reader: DynoBlock<{ index: \"int\" }, { rgba8: \"vec4\" }>;\r\n  } | null = null;\r\n\r\n  private static makeSorter() {\r\n    if (!SparkViewpoint.dynos) {\r\n      const dynoSortRadial = new DynoBool({ value: true });\r\n      const dynoOrigin = new DynoVec3({ value: new THREE.Vector3() });\r\n      const dynoDirection = new DynoVec3({ value: new THREE.Vector3() });\r\n      const dynoDepthBias = new DynoFloat({ value: 1.0 });\r\n      const dynoSort360 = new DynoBool({ value: false });\r\n      const dynoSplats = new DynoPackedSplats();\r\n\r\n      const reader = new Readback();\r\n      const doubleSortReader = dynoBlock(\r\n        { index: \"int\" },\r\n        { rgba8: \"vec4\" },\r\n        ({ index }) => {\r\n          if (!index) {\r\n            throw new Error(\"No index\");\r\n          }\r\n          const sortParams = {\r\n            sortRadial: dynoSortRadial,\r\n            sortOrigin: dynoOrigin,\r\n            sortDirection: dynoDirection,\r\n            sortDepthBias: dynoDepthBias,\r\n            sort360: dynoSort360,\r\n          };\r\n          const index2 = mul(index, dynoConst(\"int\", 2));\r\n\r\n          const gsplat0 = readPackedSplat(dynoSplats, index2);\r\n          const metric0 = computeSortMetric({ gsplat: gsplat0, ...sortParams });\r\n\r\n          const gsplat1 = readPackedSplat(\r\n            dynoSplats,\r\n            add(index2, dynoConst(\"int\", 1)),\r\n          );\r\n          const metric1 = computeSortMetric({ gsplat: gsplat1, ...sortParams });\r\n\r\n          const combined = combine({\r\n            vectorType: \"vec2\",\r\n            x: metric0,\r\n            y: metric1,\r\n          });\r\n          const rgba8 = uintToRgba8(packHalf2x16(combined));\r\n          return { rgba8 };\r\n        },\r\n      );\r\n\r\n      const sort32Reader = dynoBlock(\r\n        { index: \"int\" },\r\n        { rgba8: \"vec4\" },\r\n        ({ index }) => {\r\n          if (!index) {\r\n            throw new Error(\"No index\");\r\n          }\r\n          const sortParams = {\r\n            sortRadial: dynoSortRadial,\r\n            sortOrigin: dynoOrigin,\r\n            sortDirection: dynoDirection,\r\n            sortDepthBias: dynoDepthBias,\r\n            sort360: dynoSort360,\r\n          };\r\n\r\n          const gsplat = readPackedSplat(dynoSplats, index);\r\n          const metric = computeSortMetric({ gsplat, ...sortParams });\r\n          const rgba8 = uintToRgba8(floatBitsToUint(metric));\r\n          return { rgba8 };\r\n        },\r\n      );\r\n\r\n      SparkViewpoint.dynos = {\r\n        dynoSortRadial,\r\n        dynoOrigin,\r\n        dynoDirection,\r\n        dynoDepthBias,\r\n        dynoSort360,\r\n        dynoSplats,\r\n        reader,\r\n        doubleSortReader,\r\n        sort32Reader,\r\n      };\r\n    }\r\n    return SparkViewpoint.dynos;\r\n  }\r\n}\r\n\r\nconst defineComputeSortMetric = unindent(`\r\n  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {\r\n    if (!isGsplatActive(gsplat.flags)) {\r\n      return INFINITY;\r\n    }\r\n\r\n    vec3 center = gsplat.center - sortOrigin;\r\n    float biasedDepth = dot(center, sortDirection) + sortDepthBias;\r\n    if (!sort360 && (biasedDepth <= 0.0)) {\r\n      return INFINITY;\r\n    }\r\n\r\n    return sortRadial ? length(center) : biasedDepth;\r\n  }\r\n`);\r\n\r\nfunction computeSortMetric({\r\n  gsplat,\r\n  sortRadial,\r\n  sortOrigin,\r\n  sortDirection,\r\n  sortDepthBias,\r\n  sort360,\r\n}: {\r\n  gsplat: DynoVal<typeof Gsplat>;\r\n  sortRadial: DynoVal<\"bool\">;\r\n  sortOrigin: DynoVal<\"vec3\">;\r\n  sortDirection: DynoVal<\"vec3\">;\r\n  sortDepthBias: DynoVal<\"float\">;\r\n  sort360: DynoVal<\"bool\">;\r\n}) {\r\n  return dyno({\r\n    inTypes: {\r\n      gsplat: Gsplat,\r\n      sortRadial: \"bool\",\r\n      sortOrigin: \"vec3\",\r\n      sortDirection: \"vec3\",\r\n      sortDepthBias: \"float\",\r\n      sort360: \"bool\",\r\n    },\r\n    outTypes: { metric: \"float\" },\r\n    globals: () => [defineGsplat, defineComputeSortMetric],\r\n    inputs: {\r\n      gsplat,\r\n      sortRadial,\r\n      sortOrigin,\r\n      sortDirection,\r\n      sortDepthBias,\r\n      sort360,\r\n    },\r\n    statements: ({ inputs, outputs }) => {\r\n      const {\r\n        gsplat,\r\n        sortRadial,\r\n        sortOrigin,\r\n        sortDirection,\r\n        sortDepthBias,\r\n        sort360,\r\n      } = inputs;\r\n      return unindentLines(`\r\n        ${outputs.metric} = computeSort(${gsplat}, ${sortRadial}, ${sortOrigin}, ${sortDirection}, ${sortDepthBias}, ${sort360});\r\n      `);\r\n    },\r\n  }).outputs.metric;\r\n}\r\n","import * as THREE from \"three\";\r\n\r\nimport { PackedSplats } from \"./PackedSplats\";\r\nimport type {\r\n  GsplatGenerator,\r\n  SplatGenerator,\r\n  SplatModifier,\r\n} from \"./SplatGenerator\";\r\n\r\n// SplatAccumulator helps manage the generation of splats from multiple\r\n// SplatGenerators, keeping track of the splat mapping, coordinate system,\r\n// and reference count.\r\n\r\n// A GeneratorMapping describes a Gsplat range that was generated, including\r\n// which generator and its version number.\r\nexport type GeneratorMapping = {\r\n  node: SplatGenerator;\r\n  generator?: GsplatGenerator;\r\n  version: number;\r\n  base: number;\r\n  count: number;\r\n};\r\n\r\nexport class SplatAccumulator {\r\n  splats = new PackedSplats();\r\n  // The transform from Accumulator coordinate system to world coordinates.\r\n  toWorld = new THREE.Matrix4();\r\n  // An array of all Gsplat mappings that were used for generation\r\n  mapping: GeneratorMapping[] = [];\r\n  // Number of SparkViewpoints (or other) that reference this accumulator, used\r\n  // to figure out when it can be recycled for use\r\n  refCount = 0;\r\n\r\n  // Incremented every time the splats are updated/generated.\r\n  splatsVersion = -1;\r\n  // Incremented every time the splat mapping/layout is updated.\r\n  // Splat sort order can be reused between equivalent mapping versions.\r\n  mappingVersion = -1;\r\n\r\n  ensureGenerate(maxSplats: number) {\r\n    if (this.splats.ensureGenerate(maxSplats)) {\r\n      // If we had to resize our PackedSplats then clear all previous mappings\r\n      this.mapping = [];\r\n    }\r\n  }\r\n\r\n  // Generate all Gsplats from an array of generators\r\n  generateSplats({\r\n    renderer,\r\n    modifier,\r\n    generators,\r\n    forceUpdate,\r\n    originToWorld,\r\n  }: {\r\n    renderer: THREE.WebGLRenderer;\r\n    modifier: SplatModifier;\r\n    generators: GeneratorMapping[];\r\n    forceUpdate?: boolean;\r\n    originToWorld: THREE.Matrix4;\r\n  }) {\r\n    // Create a lookup from last SplatGenerator\r\n    const mapping = this.mapping.reduce((map, record) => {\r\n      map.set(record.node, record);\r\n      return map;\r\n    }, new Map<SplatGenerator, GeneratorMapping>());\r\n\r\n    // Run generators that are different from existing mapping\r\n    let updated = 0;\r\n    let numSplats = 0;\r\n    for (const { node, generator, version, base, count } of generators) {\r\n      const current = mapping.get(node);\r\n      if (\r\n        forceUpdate ||\r\n        generator !== current?.generator ||\r\n        version !== current?.version ||\r\n        base !== current?.base ||\r\n        count !== current?.count\r\n      ) {\r\n        // Something is different from before so we should generate these Gsplats\r\n        if (generator && count > 0) {\r\n          const modGenerator = modifier.apply(generator);\r\n          try {\r\n            this.splats.generate({\r\n              generator: modGenerator,\r\n              base,\r\n              count,\r\n              renderer,\r\n            });\r\n          } catch (error) {\r\n            node.generator = undefined;\r\n            node.generatorError = error;\r\n          }\r\n          updated += 1;\r\n        }\r\n      }\r\n      numSplats = Math.max(numSplats, base + count);\r\n    }\r\n\r\n    this.splats.numSplats = numSplats;\r\n    this.toWorld.copy(originToWorld);\r\n    this.mapping = generators;\r\n    return updated !== 0;\r\n  }\r\n\r\n  // Check if this accumulator has exactly the same generator mapping as\r\n  // the previous one. If so, we can reuse the Gsplat sort order.\r\n  hasCorrespondence(other: SplatAccumulator) {\r\n    if (this.mapping.length !== other.mapping.length) {\r\n      return false;\r\n    }\r\n    return this.mapping.every(({ node, base, count }, i) => {\r\n      const {\r\n        node: otherNode,\r\n        base: otherBase,\r\n        count: otherCount,\r\n      } = other.mapping[i];\r\n      return node === otherNode && base === otherBase && count === otherCount;\r\n    });\r\n  }\r\n}\r\n","const float LN_SCALE_MIN = -12.0;\r\nconst float LN_SCALE_MAX = 9.0;\r\n\r\nconst uint SPLAT_TEX_WIDTH_BITS = 11u;\r\nconst uint SPLAT_TEX_HEIGHT_BITS = 11u;\r\nconst uint SPLAT_TEX_DEPTH_BITS = 11u;\r\nconst uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\r\n\r\nconst uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;\r\nconst uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;\r\nconst uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;\r\n\r\nconst uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;\r\nconst uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;\r\nconst uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;\r\n\r\nconst uint F16_INF = 0x7c00u;\r\nconst float PI = 3.1415926535897932384626433832795;\r\n\r\nconst float INFINITY = 1.0 / 0.0;\r\nconst float NEG_INFINITY = -INFINITY;\r\n\r\nfloat sqr(float x) {\r\n    return x * x;\r\n}\r\n\r\nfloat pow4(float x) {\r\n    float x2 = x * x;\r\n    return x2 * x2;\r\n}\r\n\r\nfloat pow8(float x) {\r\n    float x4 = pow4(x);\r\n    return x4 * x4;\r\n}\r\n\r\nvec3 srgbToLinear(vec3 rgb) {\r\n    return pow(rgb, vec3(2.2));\r\n}\r\n\r\nvec3 linearToSrgb(vec3 rgb) {\r\n    return pow(rgb, vec3(1.0 / 2.2));\r\n}\r\n\r\n// uint encodeQuatXyz888(vec4 q) {\r\n//     // Encode quaternion in three int8s, flipping sign to remove ambiguity\r\n//     vec3 quat3 = (q.w < 0.0) ? -q.xyz : q.xyz;\r\n//     ivec3 iQuat3 = ivec3(round(clamp(quat3 * 127.0, -127.0, 127.0)));\r\n//     uvec3 uQuat3 = uvec3(iQuat3) & 0xffu;\r\n//     return (uQuat3.x << 16u) | (uQuat3.y << 8u) | uQuat3.z;\r\n// }\r\n\r\n// vec4 decodeQuatXyz888(uint encoded) {\r\n//     ivec3 iQuat3 = ivec3(\r\n//         int(encoded << 24u) >> 24,\r\n//         int(encoded << 16u) >> 24,\r\n//         int(encoded << 8u) >> 24\r\n//     );\r\n//     vec4 quat = vec4(vec3(iQuat3) / 127.0, 0.0);\r\n//     quat.w = sqrt(max(0.0, 1.0 - dot(quat.xyz, quat.xyz)));\r\n//     return quat;\r\n// }\r\n\r\n// Encode a quaternion (vec4) into a 24bit uint with folded octahedral mapping.\r\nuint encodeQuatOctXy88R8(vec4 q) {\r\n    // Ensure minimal representation: flip if q.w is negative.\r\n    if (q.w < 0.0) {\r\n        q = -q;\r\n    }\r\n    // Compute rotation angle:  = 2 * acos(q.w)  [0,]\r\n    float theta = 2.0 * acos(q.w);\r\n    float halfTheta = theta * 0.5;\r\n    float s = sin(halfTheta);\r\n    // Recover the rotation axis; use a default if nearly zero rotation.\r\n    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;\r\n    \r\n    // --- Folded Octahedral Mapping (inline) ---\r\n    // Compute p = (axis.x, axis.y) / (|axis.x|+|axis.y|+|axis.z|)\r\n    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);\r\n    vec2 p = vec2(axis.x, axis.y) / sum;\r\n    // If axis.z < 0, fold the mapping.\r\n    if (axis.z < 0.0) {\r\n        float oldPx = p.x;\r\n        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);\r\n        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);\r\n    }\r\n    // Remap from [-1,1] to [0,1]\r\n    float u_f = p.x * 0.5 + 0.5;\r\n    float v_f = p.y * 0.5 + 0.5;\r\n    // Quantize to 8 bits (0 to 255)\r\n    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));\r\n    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));\r\n    \r\n    // --- Angle Quantization ---\r\n    // Quantize   [0,] to 8 bits (0 to 255)\r\n    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));\r\n    \r\n    // Pack bits: bits [07]: quantU, [815]: quantV, [1623]: angleInt.\r\n    return (angleInt << 16u) | (quantV << 8u) | quantU;\r\n}\r\n\r\n// Decode a 24bit encoded uint into a quaternion (vec4) using the folded octahedral inverse.\r\nvec4 decodeQuatOctXy88R8(uint encoded) {\r\n    // Extract the fields.\r\n    uint quantU = encoded & uint(0xFFu);               // bits 07\r\n    uint quantV = (encoded >> 8u) & uint(0xFFu);         // bits 815\r\n    uint angleInt = encoded >> 16u;                      // bits 1623\r\n\r\n    // Recover u and v in [0,1], then map to [-1,1].\r\n    float u_f = float(quantU) / 255.0;\r\n    float v_f = float(quantV) / 255.0;\r\n    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);\r\n\r\n    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));\r\n    float t = max(-axis.z, 0.0);\r\n    axis.x += (axis.x >= 0.0) ? -t : t;\r\n    axis.y += (axis.y >= 0.0) ? -t : t;\r\n    axis = normalize(axis);\r\n    \r\n    // Decode the angle   [0,].\r\n    float theta = (float(angleInt) / 255.0) * 3.14159265359;\r\n    float halfTheta = theta * 0.5;\r\n    float s = sin(halfTheta);\r\n    float w = cos(halfTheta);\r\n    \r\n    return vec4(axis * s, w);\r\n}\r\n\r\n// // Encode a quaternion (vec4) into a 24bit uint by converting it to Euler angles.\r\n// // We assume the quaternion is normalized.\r\n// // Euler angles (roll, pitch, yaw) are assumed in radians in the range [-PI, PI].\r\n// // Each angle is normalized: value = (angle + PI) / (2*PI) and quantized to 8 bits.\r\n// uint encodeQuatEulerXyz888(vec4 q) {\r\n//     // Compute roll (x), pitch (y) and yaw (z) using TaitBryan angles.\r\n//     float sinr_cosp = 2.0 * (q.w * q.x + q.y * q.z);\r\n//     float cosr_cosp = 1.0 - 2.0 * (q.x * q.x + q.y * q.y);\r\n//     float roll = atan(sinr_cosp, cosr_cosp);\r\n    \r\n//     float sinp = 2.0 * (q.w * q.y - q.z * q.x);\r\n//     float pitch = abs(sinp) >= 1.0 ? (sign(sinp) * 1.57079632679) : asin(sinp);\r\n    \r\n//     float siny_cosp = 2.0 * (q.w * q.z + q.x * q.y);\r\n//     float cosy_cosp = 1.0 - 2.0 * (q.y * q.y + q.z * q.z);\r\n//     float yaw = atan(siny_cosp, cosy_cosp);\r\n    \r\n//     // Normalize each angle from [-PI, PI] to [0, 1]\r\n//     float normRoll  = (roll  + 3.14159265359) / (2.0 * 3.14159265359);\r\n//     float normPitch = (pitch + 3.14159265359) / (2.0 * 3.14159265359);\r\n//     float normYaw   = (yaw   + 3.14159265359) / (2.0 * 3.14159265359);\r\n    \r\n//     // Quantize each normalized angle to 8 bits (0..255)\r\n//     uint rollQ  = uint(round(normRoll  * 255.0));\r\n//     uint pitchQ = uint(round(normPitch * 255.0));\r\n//     uint yawQ   = uint(round(normYaw   * 255.0));\r\n    \r\n//     // Pack into a 24-bit uint:\r\n//     //   Bits 0..7   : rollQ,\r\n//     //   Bits 8..15  : pitchQ,\r\n//     //   Bits 16..23 : yawQ.\r\n//     return (yawQ << 16u) | (pitchQ << 8u) | rollQ;\r\n// }\r\n\r\n// // Decode a 24bit uint into a quaternion (vec4) by unpacking 8bit quantized Euler angles.\r\n// // The Euler angles are assumed to be stored in the order: roll, pitch, yaw (each in [0,255]) corresponding to [-PI, PI].\r\n// // Convert the Euler angles to a quaternion using the TaitBryan (roll, pitch, yaw) formula.\r\n// vec4 decodeQuatEulerXyz888(uint encoded) {\r\n//     // Unpack each 8-bit field.\r\n//     uint rollQ  = encoded & 0xFFu;\r\n//     uint pitchQ = (encoded >> 8u)  & 0xFFu;\r\n//     uint yawQ   = (encoded >> 16u) & 0xFFu;\r\n    \r\n//     // Convert back to the [0,1] range.\r\n//     float normRoll  = float(rollQ)  / 255.0;\r\n//     float normPitch = float(pitchQ) / 255.0;\r\n//     float normYaw   = float(yawQ)   / 255.0;\r\n    \r\n//     // Map from [0,1] back to [-PI, PI].\r\n//     float roll  = normRoll  * (2.0 * 3.14159265359) - 3.14159265359;\r\n//     float pitch = normPitch * (2.0 * 3.14159265359) - 3.14159265359;\r\n//     float yaw   = normYaw   * (2.0 * 3.14159265359) - 3.14159265359;\r\n    \r\n//     // Convert Euler angles (roll, pitch, yaw) to quaternion.\r\n//     float cr = cos(roll * 0.5);\r\n//     float sr = sin(roll * 0.5);\r\n//     float cp = cos(pitch * 0.5);\r\n//     float sp = sin(pitch * 0.5);\r\n//     float cy = cos(yaw * 0.5);\r\n//     float sy = sin(yaw * 0.5);\r\n    \r\n//     // Tait-Bryan (roll, pitch, yaw) to quaternion conversion.\r\n//     vec4 q;\r\n//     q.w = cr * cp * cy + sr * sp * sy;\r\n//     q.x = sr * cp * cy - cr * sp * sy;\r\n//     q.y = cr * sp * cy + sr * cp * sy;\r\n//     q.z = cr * cp * sy - sr * sp * cy;\r\n    \r\n//     return q;\r\n// }\r\n\r\n// Pack a Gsplat into a uvec4\r\nuvec4 packSplatEncoding(\r\n    vec3 center, vec3 scales, vec4 quaternion, vec4 rgba, vec4 rgbMinMaxLnScaleMinMax\r\n) {\r\n    float rgbMin = rgbMinMaxLnScaleMinMax.x;\r\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\r\n    vec3 encRgb = (rgba.rgb - vec3(rgbMin)) / (rgbMax - rgbMin);\r\n    uvec4 uRgba = uvec4(round(clamp(vec4(encRgb, rgba.a) * 255.0, 0.0, 255.0)));\r\n\r\n    uint uQuat = encodeQuatOctXy88R8(quaternion);\r\n    // uint uQuat = encodeQuatXyz888(quaternion);\r\n    // uint uQuat = encodeQuatEulerXyz888(quaternion);\r\n    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);\r\n\r\n    // Encode scales in three uint8s, where 0=>0.0 and 1..=255 stores log scale\r\n    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\r\n    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;\r\n    float lnScaleScale = 254.0 / (lnScaleMax - lnScaleMin);\r\n    uvec3 uScales = uvec3(\r\n        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,\r\n        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,\r\n        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u\r\n    );\r\n\r\n    // Pack it all into 4 x uint32\r\n    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);\r\n    uint word1 = packHalf2x16(center.xy);\r\n    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);\r\n    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);\r\n    return uvec4(word0, word1, word2, word3);\r\n}\r\n\r\n// Pack a Gsplat into a uvec4\r\nuvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {\r\n    return packSplatEncoding(center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\r\n}\r\n\r\nvoid unpackSplatEncoding(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba, vec4 rgbMinMaxLnScaleMinMax) {\r\n    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;\r\n\r\n    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);\r\n    float rgbMin = rgbMinMaxLnScaleMinMax.x;\r\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\r\n    rgba = (vec4(uRgba) / 255.0);\r\n    rgba.rgb = rgba.rgb * (rgbMax - rgbMin) + rgbMin;\r\n\r\n    center = vec4(\r\n        unpackHalf2x16(word1),\r\n        unpackHalf2x16(word2 & 0xffffu)\r\n    ).xyz;\r\n\r\n    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);\r\n    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\r\n    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;\r\n    float lnScaleScale = (lnScaleMax - lnScaleMin) / 254.0;\r\n    scales = vec3(\r\n        (uScales.x == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.x - 1u) * lnScaleScale),\r\n        (uScales.y == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.y - 1u) * lnScaleScale),\r\n        (uScales.z == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.z - 1u) * lnScaleScale)\r\n    );\r\n\r\n\r\n    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);\r\n    quaternion = decodeQuatOctXy88R8(uQuat);\r\n    // quaternion = decodeQuatXyz888(uQuat);\r\n    // quaternion = decodeQuatEulerXyz888(uQuat);\r\n}\r\n\r\n// Unpack a Gsplat from a uvec4\r\nvoid unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {\r\n    unpackSplatEncoding(packed, center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\r\n}\r\n\r\n// Rotate vector v by quaternion q\r\nvec3 quatVec(vec4 q, vec3 v) {\r\n    // Rotate vector v by quaternion q\r\n    vec3 t = 2.0 * cross(q.xyz, v);\r\n    return v + q.w * t + cross(q.xyz, t);\r\n}\r\n\r\n// Apply quaternion q1 after quaternion q2\r\nvec4 quatQuat(vec4 q1, vec4 q2) {\r\n    return vec4(\r\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\r\n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\r\n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\r\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\r\n    );\r\n}\r\n\r\nmat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {\r\n    // Compute the matrix of scaling by s then rotating by q\r\n    return mat3(\r\n        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),\r\n        s.x * (2.0 * (q.x * q.y + q.w * q.z)),\r\n        s.x * (2.0 * (q.x * q.z - q.w * q.y)),\r\n        s.y * (2.0 * (q.x * q.y - q.w * q.z)),\r\n        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),\r\n        s.y * (2.0 * (q.y * q.z + q.w * q.x)),\r\n        s.z * (2.0 * (q.x * q.z + q.w * q.y)),\r\n        s.z * (2.0 * (q.y * q.z - q.w * q.x)),\r\n        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))\r\n    );\r\n}\r\n\r\n// Spherical lerp between two quaternions\r\nvec4 slerp(vec4 q1, vec4 q2, float t) {\r\n    // Compute the cosine of the angle between the two vectors\r\n    float cosHalfTheta = dot(q1, q2);\r\n\r\n    // If q1=q2 or q1=-q2 then theta = 0 and we can return q1\r\n    if (abs(cosHalfTheta) >= 0.999) {\r\n        return q1;\r\n    }\r\n    \r\n    // If q1 and q2 are more than 180 degrees apart, \r\n    // we need to negate one to get the shortest path\r\n    if (cosHalfTheta < 0.0) {\r\n        q2 = -q2;\r\n        cosHalfTheta = -cosHalfTheta;\r\n    }\r\n\r\n    // Calculate temporary values\r\n    float halfTheta = acos(cosHalfTheta);\r\n    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\r\n\r\n    // Calculate the interpolation factors\r\n    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\r\n    float ratioB = sin(t * halfTheta) / sinHalfTheta;\r\n\r\n    // Calculate the interpolated quaternion\r\n    return q1 * ratioA + q2 * ratioB;\r\n}\r\n\r\nivec3 splatTexCoord(int index) {\r\n    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;\r\n    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;\r\n    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;\r\n    return ivec3(x, y, z);\r\n}\r\n","\r\nprecision highp float;\r\nprecision highp int;\r\n\r\n#include <splatDefines>\r\n#include <logdepthbuf_pars_fragment>\r\n\r\nuniform float near;\r\nuniform float far;\r\nuniform bool encodeLinear;\r\nuniform float time;\r\nuniform bool debugFlag;\r\nuniform float maxStdDev;\r\nuniform float minAlpha;\r\nuniform bool stochastic;\r\nuniform bool disableFalloff;\r\nuniform float falloff;\r\n\r\nuniform bool splatTexEnable;\r\nuniform sampler3D splatTexture;\r\nuniform mat2 splatTexMul;\r\nuniform vec2 splatTexAdd;\r\nuniform float splatTexNear;\r\nuniform float splatTexFar;\r\nuniform float splatTexMid;\r\n\r\nout vec4 fragColor;\r\n\r\nin vec4 vRgba;\r\nin vec2 vSplatUv;\r\nin vec3 vNdc;\r\nflat in uint vSplatIndex;\r\n\r\nvoid main() {\r\n    vec4 rgba = vRgba;\r\n\r\n    float z = dot(vSplatUv, vSplatUv);\r\n    if (!splatTexEnable) {\r\n        if (z > (maxStdDev * maxStdDev)) {\r\n            discard;\r\n        }\r\n    } else {\r\n        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;\r\n        float ndcZ = vNdc.z;\r\n        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));\r\n        float clampedFar = max(splatTexFar, splatTexNear);\r\n        float clampedDepth = clamp(depth, splatTexNear, clampedFar);\r\n        float logDepth = log2(clampedDepth + 1.0);\r\n        float logNear = log2(splatTexNear + 1.0);\r\n        float logFar = log2(clampedFar + 1.0);\r\n\r\n        float texZ;\r\n        if (splatTexMid > 0.0) {\r\n            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);\r\n            float logMid = log2(clampedMid + 1.0);\r\n            texZ = (clampedDepth <= clampedMid) ?\r\n                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :\r\n                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);\r\n        } else {\r\n            texZ = (logDepth - logNear) / (logFar - logNear);\r\n        }\r\n\r\n        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));\r\n        rgba *= modulate;\r\n    }\r\n\r\n    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);\r\n\r\n    if (rgba.a < minAlpha) {\r\n        discard;\r\n    }\r\n    if (encodeLinear) {\r\n        rgba.rgb = srgbToLinear(rgba.rgb);\r\n    }\r\n\r\n    if (stochastic) {\r\n        const bool STEADY = false;\r\n        uint uTime = STEADY ? 0u : floatBitsToUint(time);\r\n        uvec2 coord = uvec2(gl_FragCoord.xy);\r\n        uint state = uTime + 0x9e3779b9u * coord.x + 0x85ebca6bu * coord.y + 0xc2b2ae35u * uint(vSplatIndex);\r\n        state = state * 747796405u + 2891336453u;\r\n        uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\r\n        hash = (hash >> 22u) ^ hash;\r\n        float rand = float(hash) / 4294967296.0;\r\n        if (rand < rgba.a) {\r\n            fragColor = vec4(rgba.rgb, 1.0);\r\n        } else {\r\n            discard;\r\n        }\r\n    } else {\r\n        #ifdef PREMULTIPLIED_ALPHA\r\n            fragColor = vec4(rgba.rgb * rgba.a, rgba.a);\r\n        #else\r\n            fragColor = rgba;\r\n        #endif\r\n    }\r\n    #include <logdepthbuf_fragment>\r\n}\r\n","\r\nprecision highp float;\r\nprecision highp int;\r\nprecision highp usampler2DArray;\r\n\r\n#include <splatDefines>\r\n#include <logdepthbuf_pars_vertex>\r\n\r\nattribute uint splatIndex;\r\n\r\nout vec4 vRgba;\r\nout vec2 vSplatUv;\r\nout vec3 vNdc;\r\nflat out uint vSplatIndex;\r\n\r\nuniform vec2 renderSize;\r\nuniform uint numSplats;\r\nuniform vec4 renderToViewQuat;\r\nuniform vec3 renderToViewPos;\r\nuniform float maxStdDev;\r\nuniform float minPixelRadius;\r\nuniform float maxPixelRadius;\r\nuniform float time;\r\nuniform float deltaTime;\r\nuniform bool debugFlag;\r\nuniform float minAlpha;\r\nuniform bool stochastic;\r\nuniform bool enable2DGS;\r\nuniform float blurAmount;\r\nuniform float preBlurAmount;\r\nuniform float focalDistance;\r\nuniform float apertureAngle;\r\nuniform float clipXY;\r\nuniform float focalAdjustment;\r\n\r\nuniform usampler2DArray packedSplats;\r\nuniform vec4 rgbMinMaxLnScaleMinMax;\r\n\r\n#ifdef USE_LOGDEPTHBUF\r\n    bool isPerspectiveMatrix( mat4 m ) {\r\n      return m[ 2 ][ 3 ] == - 1.0;\r\n    }\r\n#endif\r\n\r\nvoid main() {\r\n    // Default to outside the frustum so it's discarded if we return early\r\n    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\r\n\r\n    if (uint(gl_InstanceID) >= numSplats) {\r\n        return;\r\n    }\r\n\r\n    ivec3 texCoord;\r\n    if (stochastic) {\r\n        texCoord = ivec3(\r\n            uint(gl_InstanceID) & SPLAT_TEX_WIDTH_MASK,\r\n            (uint(gl_InstanceID) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\r\n            (uint(gl_InstanceID) >> SPLAT_TEX_LAYER_BITS)\r\n        );\r\n    } else {\r\n        if (splatIndex == 0xffffffffu) {\r\n            // Special value reserved for \"no splat\"\r\n            return;\r\n        }\r\n        texCoord = ivec3(\r\n            splatIndex & SPLAT_TEX_WIDTH_MASK,\r\n            (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\r\n            splatIndex >> SPLAT_TEX_LAYER_BITS\r\n        );\r\n    }\r\n    uvec4 packed = texelFetch(packedSplats, texCoord, 0);\r\n\r\n    vec3 center, scales;\r\n    vec4 quaternion, rgba;\r\n    unpackSplatEncoding(packed, center, scales, quaternion, rgba, rgbMinMaxLnScaleMinMax);\r\n\r\n    if (rgba.a < minAlpha) {\r\n        return;\r\n    }\r\n    bvec3 zeroScales = equal(scales, vec3(0.0));\r\n    if (all(zeroScales)) {\r\n        return;\r\n    }\r\n\r\n    // Compute the view space center of the splat\r\n    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;\r\n\r\n    // Discard splats behind the camera\r\n    if (viewCenter.z >= 0.0) {\r\n        return;\r\n    }\r\n\r\n    // Compute the clip space center of the splat\r\n    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);\r\n\r\n    // Discard splats outside near/far planes\r\n    if (abs(clipCenter.z) >= clipCenter.w) {\r\n        return;\r\n    }\r\n\r\n    // Discard splats more than clipXY times outside the XY frustum\r\n    float clip = clipXY * clipCenter.w;\r\n    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {\r\n        return;\r\n    }\r\n\r\n    // Record the splat index for entropy\r\n    vSplatIndex = splatIndex;\r\n\r\n    // Compute view space quaternion of splat\r\n    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);\r\n\r\n    if (enable2DGS && any(zeroScales)) {\r\n        vRgba = rgba;\r\n        vSplatUv = position.xy * maxStdDev;\r\n\r\n        vec3 offset;\r\n        if (zeroScales.z) {\r\n            offset = vec3(vSplatUv.xy * scales.xy, 0.0);\r\n        } else if (zeroScales.y) {\r\n            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);\r\n        } else {\r\n            offset = vec3(0.0, vSplatUv.xy * scales.yz);\r\n        }\r\n\r\n        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);\r\n        gl_Position = projectionMatrix * vec4(viewPos, 1.0);\r\n        vNdc = gl_Position.xyz / gl_Position.w;\r\n        return;\r\n    }\r\n\r\n    // Compute NDC center of the splat\r\n    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\r\n\r\n    // Compute the 3D covariance matrix of the splat\r\n    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);\r\n    mat3 cov3D = RS * transpose(RS);\r\n\r\n    // Compute the Jacobian of the splat's projection at its center\r\n    vec2 scaledRenderSize = renderSize * focalAdjustment;\r\n    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);\r\n\r\n    mat3 J;\r\n    if(isOrthographic) {\r\n        J = mat3(\r\n            focal.x, 0.0, 0.0,\r\n            0.0, focal.y, 0.0,\r\n            0.0, 0.0, 0.0\r\n        );\r\n    } else {\r\n        float invZ = 1.0 / viewCenter.z;\r\n        vec2 J1 = focal * invZ;\r\n        vec2 J2 = -(J1 * viewCenter.xy) * invZ;\r\n        J = mat3(\r\n            J1.x, 0.0, J2.x,\r\n            0.0, J1.y, J2.y,\r\n            0.0, 0.0, 0.0\r\n        );\r\n    }\r\n\r\n    // Compute the 2D covariance by projecting the 3D covariance\r\n    // and picking out the XY plane components.\r\n    // Keeping below because we may need it in the future\r\n    // for skinning deformations.\r\n    // mat3 W = transpose(mat3(viewMatrix));\r\n    // mat3 T = W * J;\r\n    // mat3 cov2D = transpose(T) * cov3D * T;\r\n    mat3 cov2D = transpose(J) * cov3D * J;\r\n    float a = cov2D[0][0];\r\n    float d = cov2D[1][1];\r\n    float b = cov2D[0][1];\r\n\r\n    // Optionally pre-blur the splat to match non-antialias optimized splats\r\n    a += preBlurAmount;\r\n    d += preBlurAmount;\r\n\r\n    float fullBlurAmount = blurAmount;\r\n    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {\r\n        float focusRadius = maxPixelRadius;\r\n        if (viewCenter.z < 0.0) {\r\n            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);\r\n            float apertureRadius = focal.x * tan(0.5 * apertureAngle);\r\n            focusRadius = focusBlur * apertureRadius;\r\n        }\r\n        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(maxPixelRadius));\r\n    }\r\n\r\n    // Do convolution with a 0.5-pixel Gaussian for anti-aliasing: sqrt(0.3) ~= 0.5\r\n    float detOrig = a * d - b * b;\r\n    a += fullBlurAmount;\r\n    d += fullBlurAmount;\r\n    float det = a * d - b * b;\r\n\r\n    // Compute anti-aliasing intensity scaling factor\r\n    float blurAdjust = sqrt(max(0.0, detOrig / det));\r\n    rgba.a *= blurAdjust;\r\n    if (rgba.a < minAlpha) {\r\n        return;\r\n    }\r\n\r\n    // Compute the eigenvalue and eigenvectors of the 2D covariance matrix\r\n    float eigenAvg = 0.5 * (a + d);\r\n    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));\r\n    float eigen1 = eigenAvg + eigenDelta;\r\n    float eigen2 = eigenAvg - eigenDelta;\r\n\r\n    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));\r\n    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);\r\n\r\n    float scale1 = min(maxPixelRadius, maxStdDev * sqrt(eigen1));\r\n    float scale2 = min(maxPixelRadius, maxStdDev * sqrt(eigen2));\r\n    if (scale1 < minPixelRadius && scale2 < minPixelRadius) {\r\n        return;\r\n    }\r\n\r\n    // Compute the NDC coordinates for the ellipsoid's diagonal axes.\r\n    vec2 pixelOffset = position.x * eigenVec1 * scale1 + position.y * eigenVec2 * scale2;\r\n    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;\r\n    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);\r\n\r\n    vRgba = rgba;\r\n    vSplatUv = position.xy * maxStdDev;\r\n    vNdc = ndc;\r\n    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);\r\n    #include <logdepthbuf_vertex>\r\n}\r\n","import * as THREE from \"three\";\r\n\r\nimport splatDefines from \"./shaders/splatDefines.glsl\";\r\nimport splatFragment from \"./shaders/splatFragment.glsl\";\r\nimport splatVertex from \"./shaders/splatVertex.glsl\";\r\n\r\nlet shaders: Record<string, string> | null = null;\r\n\r\nexport function getShaders(): Record<string, string> {\r\n  if (!shaders) {\r\n    // @ts-ignore\r\n    THREE.ShaderChunk.splatDefines = splatDefines;\r\n    shaders = {\r\n      splatVertex,\r\n      splatFragment,\r\n    };\r\n  }\r\n  return shaders;\r\n}\r\n","import * as THREE from \"three\";\r\n\r\nimport {\r\n  DEFAULT_SPLAT_ENCODING,\r\n  PackedSplats,\r\n  type SplatEncoding,\r\n} from \"./PackedSplats\";\r\nimport { RgbaArray } from \"./RgbaArray\";\r\nimport { SparkViewpoint, type SparkViewpointOptions } from \"./SparkViewpoint\";\r\nimport { type GeneratorMapping, SplatAccumulator } from \"./SplatAccumulator\";\r\nimport { SplatEdit } from \"./SplatEdit\";\r\nimport { SplatGenerator, SplatModifier } from \"./SplatGenerator\";\r\nimport { SplatGeometry } from \"./SplatGeometry\";\r\nimport { SplatMesh } from \"./SplatMesh\";\r\nimport { LN_SCALE_MAX, LN_SCALE_MIN } from \"./defines\";\r\nimport {\r\n  DynoVec3,\r\n  DynoVec4,\r\n  Gsplat,\r\n  TPackedSplats,\r\n  dynoBlock,\r\n  readPackedSplat,\r\n  transformGsplat,\r\n} from \"./dyno\";\r\nimport { getShaders } from \"./shaders\";\r\nimport {\r\n  averagePositions,\r\n  averageQuaternions,\r\n  cloneClock,\r\n  withinCoorientDist,\r\n} from \"./utils\";\r\n\r\n// SparkRenderer aggregates splats from multiple generators into a single\r\n// accumulated collection per frame. In normal operation we only need a\r\n// maximum of 3 accumulators: One currently being viewed, one currently\r\n// being sorted, and one more for generating the next frame. Accumulators\r\n// must be \"released\" by each viewpoint using it, so in unusual cases\r\n// such as slow render-outs, we may want to allow more than 3 so the\r\n// pipeline can continue generating new frames, but we limit to a maximum\r\n// of 5 to avoid excessive memory usage.\r\nconst MAX_ACCUMULATORS = 5;\r\n\r\nexport type SparkRendererOptions = {\r\n  /**\r\n   * Pass in your THREE.WebGLRenderer instance so Spark can perform work\r\n   * outside the usual render loop. Should be created with antialias: false\r\n   * (default setting) as WebGL anti-aliasing doesn't improve Gaussian Splatting\r\n   * rendering and significantly reduces performance.\r\n   */\r\n  renderer: THREE.WebGLRenderer;\r\n  /**\r\n   * Whether to use premultiplied alpha when accumulating splat RGB\r\n   * @default true\r\n   */\r\n  premultipliedAlpha?: boolean;\r\n  /**\r\n   * Pass in a THREE.Clock to synchronize time-based effects across different\r\n   * systems. Alternatively, you can set the SparkRenderer properties time and\r\n   * deltaTime directly. (default: new THREE.Clock)\r\n   */\r\n  clock?: THREE.Clock;\r\n  /**\r\n   * Controls whether to check and automatically update Gsplat collection after\r\n   * each frame render.\r\n   * @default true\r\n   */\r\n  autoUpdate?: boolean;\r\n  /**\r\n   * Controls whether to update the Gsplats before or after rendering. For WebXR\r\n   * this must be false in order to complete rendering as soon as possible.\r\n   * @default false\r\n   */\r\n  preUpdate?: boolean;\r\n  /**\r\n   * Distance threshold for SparkRenderer movement triggering a Gsplat update at\r\n   * the new origin.\r\n   * @default 1.0\r\n   */\r\n  originDistance?: number;\r\n  /**\r\n   * Maximum standard deviations from the center to render Gaussians. Values\r\n   * Math.sqrt(5)..Math.sqrt(8) produce good results and can be tweaked for\r\n   * performance.\r\n   * @default Math.sqrt(8)\r\n   */\r\n  maxStdDev?: number;\r\n  /**\r\n   * Minimum pixel radius for splat rendering.\r\n   * @default 0.0\r\n   */\r\n  minPixelRadius?: number;\r\n  /**\r\n   * Maximum pixel radius for splat rendering.\r\n   * @default 512.0\r\n   */\r\n  maxPixelRadius?: number;\r\n  /**\r\n   * Minimum alpha value for splat rendering.\r\n   * @default 0.5 * (1.0 / 255.0)\r\n   */\r\n  minAlpha?: number;\r\n  /**\r\n   * Enable 2D Gaussian splatting rendering ability. When this mode is enabled,\r\n   * any scale x/y/z component that is exactly 0 (minimum quantized value) results\r\n   * in the other two non-0 axis being interpreted as an oriented 2D Gaussian Splat,\r\n   * rather instead of the usual projected 3DGS Z-slice. When reading PLY files,\r\n   * scale values less than e^-30 will be interpreted as 0.\r\n   * @default false\r\n   */\r\n  enable2DGS?: boolean;\r\n  /**\r\n   * Scalar value to add to 2D splat covariance diagonal, effectively blurring +\r\n   * enlarging splats. In scenes trained without the Gsplat anti-aliasing tweak\r\n   * this value was typically 0.3, but with anti-aliasing it is 0.0\r\n   * @default 0.0\r\n   */\r\n  preBlurAmount?: number;\r\n  /**\r\n   * Scalar value to add to 2D splat covarianve diagonal, with opacity adjustment\r\n   * to correctly account for \"blurring\" when anti-aliasing. Typically 0.3\r\n   * (equivalent to approx 0.5 pixel radius) in scenes trained with anti-aliasing.\r\n   */\r\n  blurAmount?: number;\r\n  /**\r\n   * Depth-of-field distance to focal plane\r\n   */\r\n  focalDistance?: number;\r\n  /**\r\n   * Full-width angle of aperture opening (in radians), 0.0 to disable\r\n   * @default 0.0\r\n   */\r\n  apertureAngle?: number;\r\n  /**\r\n   * Modulate Gaussian kernel falloff. 0 means \"no falloff, flat shading\",\r\n   * while 1 is the normal Gaussian kernel.\r\n   * @default 1.0\r\n   */\r\n  falloff?: number;\r\n  /**\r\n   * X/Y clipping boundary factor for Gsplat centers against view frustum.\r\n   * 1.0 clips any centers that are exactly out of bounds, while 1.4 clips\r\n   * centers that are 40% beyond the bounds.\r\n   * @default 1.4\r\n   */\r\n  clipXY?: number;\r\n  /**\r\n   * Parameter to adjust projected splat scale calculation to match other renderers,\r\n   * similar to the same parameter in the MKellogg 3DGS renderer. Higher values will\r\n   * tend to sharpen the splats. A value 2.0 can be used to match the behavior of\r\n   * the PlayCanvas renderer.\r\n   * @default 1.0\r\n   */\r\n  focalAdjustment?: number;\r\n  /**\r\n   * Configures the SparkViewpointOptions for the default SparkViewpoint\r\n   * associated with this SparkRenderer. Notable option: sortRadial (sort by\r\n   * radial distance or Z-depth)\r\n   */\r\n  view?: SparkViewpointOptions;\r\n  /**\r\n   * Override the default splat encoding ranges for the PackedSplats.\r\n   * (default: undefined)\r\n   */\r\n  splatEncoding?: SplatEncoding;\r\n};\r\n\r\nexport class SparkRenderer extends THREE.Mesh {\r\n  renderer: THREE.WebGLRenderer;\r\n  premultipliedAlpha: boolean;\r\n  material: THREE.ShaderMaterial;\r\n  uniforms: ReturnType<typeof SparkRenderer.makeUniforms>;\r\n\r\n  autoUpdate: boolean;\r\n  preUpdate: boolean;\r\n  needsUpdate: boolean;\r\n  originDistance: number;\r\n  maxStdDev: number;\r\n  minPixelRadius: number;\r\n  maxPixelRadius: number;\r\n  minAlpha: number;\r\n  enable2DGS: boolean;\r\n  preBlurAmount: number;\r\n  blurAmount: number;\r\n  focalDistance: number;\r\n  apertureAngle: number;\r\n  falloff: number;\r\n  clipXY: number;\r\n  focalAdjustment: number;\r\n  splatEncoding: SplatEncoding;\r\n\r\n  splatTexture: null | {\r\n    enable?: boolean;\r\n    texture?: THREE.Data3DTexture;\r\n    multiply?: THREE.Matrix2;\r\n    add?: THREE.Vector2;\r\n    near?: number;\r\n    far?: number;\r\n    mid?: number;\r\n  } = null;\r\n\r\n  time?: number;\r\n  deltaTime?: number;\r\n  clock: THREE.Clock;\r\n\r\n  // Latest Gsplat collection being displayed\r\n  active: SplatAccumulator;\r\n  // Free list of accumulators for reuse\r\n  private freeAccumulators: SplatAccumulator[];\r\n  // Total number of accumulators currently allocated\r\n  private accumulatorCount: number;\r\n  // Default SparkViewpoint used for rendering to the canvas\r\n  defaultView: SparkViewpoint;\r\n  // List of SparkViewpoints with autoUpdate enabled\r\n  autoViewpoints: SparkViewpoint[] = [];\r\n\r\n  // Dynos used to transform Gsplats to the accumulator coordinate system\r\n  private rotateToAccumulator = new DynoVec4({ value: new THREE.Quaternion() });\r\n  private translateToAccumulator = new DynoVec3({ value: new THREE.Vector3() });\r\n  private modifier: SplatModifier;\r\n\r\n  // Last rendered frame number so we know when we're rendering a new frame\r\n  private lastFrame = -1;\r\n  // Last update timestamp to compute deltaTime\r\n  private lastUpdateTime: number | null = null;\r\n  // List of cameras used for the current viewpoint (for WebXR)\r\n  private defaultCameras: THREE.Matrix4[] = [];\r\n  private lastStochastic: boolean | null = null;\r\n\r\n  // Should be set to the defaultView, but can be temporarily changed to another\r\n  // viewpoint using prepareViewpoint() for rendering from a different viewpoint.\r\n  viewpoint: SparkViewpoint;\r\n\r\n  // Holds data needed to perform a scheduled Gsplat update.\r\n  private pendingUpdate = {\r\n    scene: null as THREE.Scene | null,\r\n    originToWorld: new THREE.Matrix4(),\r\n    timeoutId: -1,\r\n  };\r\n\r\n  // Internal SparkViewpoint used for environment map rendering.\r\n  private envViewpoint: SparkViewpoint | null = null;\r\n\r\n  // Data and buffers used for environment map rendering\r\n  private static cubeRender: {\r\n    target: THREE.WebGLCubeRenderTarget;\r\n    camera: THREE.CubeCamera;\r\n    near: number;\r\n    far: number;\r\n  } | null = null;\r\n  private static pmrem: THREE.PMREMGenerator | null = null;\r\n\r\n  static EMPTY_SPLAT_TEXTURE = new THREE.Data3DTexture();\r\n\r\n  constructor(options: SparkRendererOptions) {\r\n    const uniforms = SparkRenderer.makeUniforms();\r\n    const shaders = getShaders();\r\n    const premultipliedAlpha = options.premultipliedAlpha ?? true;\r\n    const material = new THREE.ShaderMaterial({\r\n      glslVersion: THREE.GLSL3,\r\n      vertexShader: shaders.splatVertex,\r\n      fragmentShader: shaders.splatFragment,\r\n      uniforms,\r\n      premultipliedAlpha,\r\n      transparent: true,\r\n      depthTest: true,\r\n      depthWrite: false,\r\n      side: THREE.DoubleSide,\r\n    });\r\n\r\n    super(EMPTY_GEOMETRY, material);\r\n    // Disable frustum culling because we want to always draw them all\r\n    // and cull Gsplats individually in the shader\r\n    this.frustumCulled = false;\r\n\r\n    this.renderer = options.renderer;\r\n    this.material = material;\r\n    this.uniforms = uniforms;\r\n\r\n    // Create a Gsplat modifier that takes the output of any SplatGenerator\r\n    // and transforms them into the accumulator's coordinate system\r\n    const modifier = dynoBlock(\r\n      { gsplat: Gsplat },\r\n      { gsplat: Gsplat },\r\n      ({ gsplat }) => {\r\n        if (!gsplat) {\r\n          throw new Error(\"gsplat not defined\");\r\n        }\r\n        gsplat = transformGsplat(gsplat, {\r\n          rotate: this.rotateToAccumulator,\r\n          translate: this.translateToAccumulator,\r\n        });\r\n        return { gsplat };\r\n      },\r\n    );\r\n    this.modifier = new SplatModifier(modifier);\r\n\r\n    this.premultipliedAlpha = premultipliedAlpha;\r\n    this.autoUpdate = options.autoUpdate ?? true;\r\n    this.preUpdate = options.preUpdate ?? false;\r\n    this.needsUpdate = false;\r\n    this.originDistance = options.originDistance ?? 1;\r\n    this.maxStdDev = options.maxStdDev ?? Math.sqrt(8.0);\r\n    this.minPixelRadius = options.minPixelRadius ?? 0.0;\r\n    this.maxPixelRadius = options.maxPixelRadius ?? 512.0;\r\n    this.minAlpha = options.minAlpha ?? 0.5 * (1.0 / 255.0);\r\n    this.enable2DGS = options.enable2DGS ?? false;\r\n    this.preBlurAmount = options.preBlurAmount ?? 0.0;\r\n    this.blurAmount = options.blurAmount ?? 0.3;\r\n    this.focalDistance = options.focalDistance ?? 0.0;\r\n    this.apertureAngle = options.apertureAngle ?? 0.0;\r\n    this.falloff = options.falloff ?? 1.0;\r\n    this.clipXY = options.clipXY ?? 1.4;\r\n    this.focalAdjustment = options.focalAdjustment ?? 1.0;\r\n    this.splatEncoding = options.splatEncoding ?? { ...DEFAULT_SPLAT_ENCODING };\r\n\r\n    this.active = new SplatAccumulator();\r\n    this.active.refCount = 1;\r\n    this.accumulatorCount = 1;\r\n    this.freeAccumulators = [];\r\n    // Start with the minimum of 2 total accumulators\r\n    for (let count = 0; count < 1; ++count) {\r\n      this.freeAccumulators.push(new SplatAccumulator());\r\n      this.accumulatorCount += 1;\r\n    }\r\n\r\n    // Create a default SparkViewpoint that is used when we call render()\r\n    // on the scene and has the sorted Gsplat collection from that viewpoint.\r\n    this.defaultView = new SparkViewpoint({\r\n      ...options.view,\r\n      autoUpdate: true,\r\n      spark: this,\r\n    });\r\n    this.viewpoint = this.defaultView;\r\n    this.prepareViewpoint(this.viewpoint);\r\n\r\n    this.clock = options.clock ? cloneClock(options.clock) : new THREE.Clock();\r\n  }\r\n\r\n  static makeUniforms() {\r\n    // Create uniforms used for Gsplat vertex and fragment shaders\r\n    const uniforms = {\r\n      // Size of render viewport in pixels\r\n      renderSize: { value: new THREE.Vector2() },\r\n      // Near and far plane distances\r\n      near: { value: 0.1 },\r\n      far: { value: 1000.0 },\r\n      // Total number of Gsplats in packedSplats to render\r\n      numSplats: { value: 0 },\r\n      // SplatAccumulator to view transformation quaternion\r\n      renderToViewQuat: { value: new THREE.Quaternion() },\r\n      // SplatAccumulator to view transformation translation\r\n      renderToViewPos: { value: new THREE.Vector3() },\r\n      // Maximum distance (in stddevs) from Gsplat center to render\r\n      maxStdDev: { value: 1.0 },\r\n      // Minimum pixel radius for splat rendering\r\n      minPixelRadius: { value: 0.0 },\r\n      // Maximum pixel radius for splat rendering\r\n      maxPixelRadius: { value: 512.0 },\r\n      // Minimum alpha value for splat rendering\r\n      minAlpha: { value: 0.5 * (1.0 / 255.0) },\r\n      // Enable stochastic splat rendering\r\n      stochastic: { value: false },\r\n      // Enable interpreting 0-thickness Gsplats as 2DGS\r\n      enable2DGS: { value: false },\r\n      // Add to projected 2D splat covariance diagonal (thickens and brightens)\r\n      preBlurAmount: { value: 0.0 },\r\n      // Add to 2D splat covariance diagonal and adjust opacity (anti-aliasing)\r\n      blurAmount: { value: 0.3 },\r\n      // Depth-of-field distance to focal plane\r\n      focalDistance: { value: 0.0 },\r\n      // Full-width angle of aperture opening (in radians)\r\n      apertureAngle: { value: 0.0 },\r\n      // Modulate Gaussian kernal falloff. 0 means \"no falloff, flat shading\",\r\n      // 1 is normal e^-x^2 falloff.\r\n      falloff: { value: 1.0 },\r\n      // Clip Gsplats that are clipXY times beyond the +-1 frustum bounds\r\n      clipXY: { value: 1.4 },\r\n      // Debug renderSize scale factor\r\n      focalAdjustment: { value: 1.0 },\r\n      // Enable splat texture rendering\r\n      splatTexEnable: { value: false },\r\n      // Splat texture to render\r\n      splatTexture: { type: \"t\", value: SparkRenderer.EMPTY_SPLAT_TEXTURE },\r\n      // Splat texture UV transform (multiply)\r\n      splatTexMul: { value: new THREE.Matrix2() },\r\n      // Splat texture UV transform (add)\r\n      splatTexAdd: { value: new THREE.Vector2() },\r\n      // Splat texture near plane distance\r\n      splatTexNear: { value: 0.1 },\r\n      // Splat texture far plane distance\r\n      splatTexFar: { value: 1000.0 },\r\n      // Splat texture mid plane distance, or 0.0 to disable\r\n      splatTexMid: { value: 0.0 },\r\n      // Gsplat collection to render\r\n      packedSplats: { type: \"t\", value: PackedSplats.getEmpty() },\r\n      // Splat encoding ranges\r\n      rgbMinMaxLnScaleMinMax: { value: new THREE.Vector4() },\r\n      // Time in seconds for time-based effects\r\n      time: { value: 0 },\r\n      // Delta time in seconds since last frame\r\n      deltaTime: { value: 0 },\r\n      // Whether to encode Gsplat with linear RGB (for environment mapping)\r\n      encodeLinear: { value: false },\r\n      // Debug flag that alternates each frame\r\n      debugFlag: { value: false },\r\n    };\r\n    return uniforms;\r\n  }\r\n\r\n  private canAllocAccumulator(): boolean {\r\n    // Returns true if can allocate an accumulator immediately\r\n    return (\r\n      this.freeAccumulators.length > 0 ||\r\n      this.accumulatorCount < MAX_ACCUMULATORS\r\n    );\r\n  }\r\n\r\n  private maybeAllocAccumulator(): SplatAccumulator | null {\r\n    // Allocate an accumulator immediately if possible, else return null\r\n    let accumulator = this.freeAccumulators.pop();\r\n    if (accumulator === undefined) {\r\n      if (this.accumulatorCount >= MAX_ACCUMULATORS) {\r\n        return null;\r\n      }\r\n      accumulator = new SplatAccumulator();\r\n      this.accumulatorCount += 1;\r\n    }\r\n    accumulator.refCount = 1;\r\n    return accumulator;\r\n  }\r\n\r\n  releaseAccumulator(accumulator: SplatAccumulator) {\r\n    // Decrement reference count and recycle if no longer in use\r\n    accumulator.refCount -= 1;\r\n    if (accumulator.refCount === 0) {\r\n      this.freeAccumulators.push(accumulator);\r\n    }\r\n  }\r\n\r\n  newViewpoint(options: SparkViewpointOptions) {\r\n    // Create a new SparkViewpoint for this SparkRenderer.\r\n    // Note that every SparkRenderer has an initial spark.defaultView: SparkViewpoint\r\n    // from construction, which is used for the default canvas render loop.\r\n    // Calling this method allows you to create additional viewpoints, which can be\r\n    // updated automatically each frame (performing Gsplat sorting every time there\r\n    // is an update), or updated on-demand for controlled rendering for video render\r\n    // or similar applications.\r\n    return new SparkViewpoint({ ...options, spark: this });\r\n  }\r\n\r\n  onBeforeRender(\r\n    renderer: THREE.WebGLRenderer,\r\n    scene: THREE.Scene,\r\n    camera: THREE.Camera,\r\n  ) {\r\n    // Called by Three.js before rendering this SparkRenderer.\r\n    // At this point we can't modify the geometry or material, all these must\r\n    // be set in the scene already before this is called. Update the uniforms\r\n    // to render the Gsplats from the current active viewpoint.\r\n    const time = this.time ?? this.clock.getElapsedTime();\r\n    const deltaTime = time - (this.viewpoint.lastTime ?? time);\r\n    this.viewpoint.lastTime = time;\r\n\r\n    const frame = renderer.info.render.frame;\r\n    const isNewFrame = frame !== this.lastFrame;\r\n    this.lastFrame = frame;\r\n\r\n    const viewpoint = this.viewpoint;\r\n    if (viewpoint === this.defaultView) {\r\n      // When rendering is triggered on the default viewpoint,\r\n      // perform automatic updates.\r\n      if (isNewFrame) {\r\n        if (!renderer.xr.isPresenting) {\r\n          // Non-WebXR mode, just a single camera\r\n          this.defaultView.viewToWorld = camera.matrixWorld.clone();\r\n          this.defaultCameras = [this.defaultView.viewToWorld];\r\n        } else {\r\n          // In WebXR mode we are called multiple times, once for each eye,\r\n          // so use their average to compute the sort center.\r\n          const cameras = renderer.xr.getCamera().cameras;\r\n          this.defaultCameras = cameras.map((camera) => camera.matrixWorld);\r\n          this.defaultView.viewToWorld =\r\n            averageOriginToWorlds(this.defaultCameras) ?? new THREE.Matrix4();\r\n        }\r\n      }\r\n\r\n      if (this.autoUpdate) {\r\n        this.update({ scene, viewToWorld: this.defaultView.viewToWorld });\r\n      }\r\n    }\r\n\r\n    // Update uniforms for rendering\r\n\r\n    if (isNewFrame) {\r\n      // Keep these uniforms the same for both eyes if in WebXR\r\n      if (this.material.premultipliedAlpha !== this.premultipliedAlpha) {\r\n        this.material.premultipliedAlpha = this.premultipliedAlpha;\r\n        this.material.needsUpdate = true;\r\n      }\r\n      this.uniforms.time.value = time;\r\n      this.uniforms.deltaTime.value = deltaTime;\r\n      // Alternating debug flag that can aid in visual debugging\r\n      this.uniforms.debugFlag.value = (performance.now() / 1000.0) % 2.0 < 1.0;\r\n\r\n      if (viewpoint.display && viewpoint.stochastic) {\r\n        (this.geometry as SplatGeometry).instanceCount =\r\n          this.uniforms.numSplats.value;\r\n      }\r\n    }\r\n\r\n    if (viewpoint.target) {\r\n      // Rendering to a texture target, so its dimensions\r\n      this.uniforms.renderSize.value.set(\r\n        viewpoint.target.width,\r\n        viewpoint.target.height,\r\n      );\r\n    } else {\r\n      // Rendering to the canvas or WebXR\r\n      const renderSize = renderer.getDrawingBufferSize(\r\n        this.uniforms.renderSize.value,\r\n      );\r\n      if (renderSize.x === 1 && renderSize.y === 1) {\r\n        // WebXR mode on Apple Vision Pro returns 1x1 when presenting.\r\n        // Use a different means to figure out the render size.\r\n        const baseLayer = renderer.xr.getSession()?.renderState.baseLayer;\r\n        if (baseLayer) {\r\n          renderSize.x = baseLayer.framebufferWidth;\r\n          renderSize.y = baseLayer.framebufferHeight;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Update uniforms from instance properties\r\n    const typedCamera = camera as\r\n      | THREE.PerspectiveCamera\r\n      | THREE.OrthographicCamera;\r\n    this.uniforms.near.value = typedCamera.near;\r\n    this.uniforms.far.value = typedCamera.far;\r\n    this.uniforms.encodeLinear.value = viewpoint.encodeLinear;\r\n    this.uniforms.maxStdDev.value = this.maxStdDev;\r\n    this.uniforms.minPixelRadius.value = this.minPixelRadius;\r\n    this.uniforms.maxPixelRadius.value = this.maxPixelRadius;\r\n    this.uniforms.minAlpha.value = this.minAlpha;\r\n    this.uniforms.stochastic.value = viewpoint.stochastic;\r\n    this.uniforms.enable2DGS.value = this.enable2DGS;\r\n    this.uniforms.preBlurAmount.value = this.preBlurAmount;\r\n    this.uniforms.blurAmount.value = this.blurAmount;\r\n    this.uniforms.focalDistance.value = this.focalDistance;\r\n    this.uniforms.apertureAngle.value = this.apertureAngle;\r\n    this.uniforms.falloff.value = this.falloff;\r\n    this.uniforms.clipXY.value = this.clipXY;\r\n    this.uniforms.focalAdjustment.value = this.focalAdjustment;\r\n\r\n    if (this.lastStochastic !== !viewpoint.stochastic) {\r\n      this.lastStochastic = !viewpoint.stochastic;\r\n      this.material.transparent = !viewpoint.stochastic;\r\n      this.material.depthWrite = viewpoint.stochastic;\r\n      this.material.needsUpdate = true;\r\n    }\r\n\r\n    if (this.splatTexture) {\r\n      const { enable, texture, multiply, add, near, far, mid } =\r\n        this.splatTexture;\r\n      if (enable && texture) {\r\n        this.uniforms.splatTexEnable.value = true;\r\n        this.uniforms.splatTexture.value = texture;\r\n        if (multiply) {\r\n          this.uniforms.splatTexMul.value.fromArray(multiply.elements);\r\n        } else {\r\n          this.uniforms.splatTexMul.value.set(\r\n            0.5 / this.maxStdDev,\r\n            0,\r\n            0,\r\n            0.5 / this.maxStdDev,\r\n          );\r\n        }\r\n        this.uniforms.splatTexAdd.value.set(add?.x ?? 0.5, add?.y ?? 0.5);\r\n        this.uniforms.splatTexNear.value = near ?? this.uniforms.near.value;\r\n        this.uniforms.splatTexFar.value = far ?? this.uniforms.far.value;\r\n        this.uniforms.splatTexMid.value = mid ?? 0.0;\r\n      } else {\r\n        this.uniforms.splatTexEnable.value = false;\r\n        this.uniforms.splatTexture.value = SparkRenderer.EMPTY_SPLAT_TEXTURE;\r\n      }\r\n    } else {\r\n      this.uniforms.splatTexEnable.value = false;\r\n      this.uniforms.splatTexture.value = SparkRenderer.EMPTY_SPLAT_TEXTURE;\r\n    }\r\n\r\n    // Calculate the transform from the accumulator to the current camera\r\n    const accumToWorld =\r\n      viewpoint.display?.accumulator.toWorld ?? new THREE.Matrix4();\r\n    const worldToCamera = camera.matrixWorld.clone().invert();\r\n    const originToCamera = accumToWorld.clone().premultiply(worldToCamera);\r\n    originToCamera.decompose(\r\n      this.uniforms.renderToViewPos.value,\r\n      this.uniforms.renderToViewQuat.value,\r\n      new THREE.Vector3(),\r\n    );\r\n  }\r\n\r\n  // Update the uniforms for the given viewpoint.\r\n  // Note that the client expects to be able to call render() at any point\r\n  // to update the canvas, so we must switch the viewpoint back to\r\n  // defaultView when we're finished.\r\n  prepareViewpoint(viewpoint?: SparkViewpoint) {\r\n    this.viewpoint = viewpoint ?? this.viewpoint;\r\n\r\n    if (this.viewpoint.display) {\r\n      const { accumulator, geometry } = this.viewpoint.display;\r\n      this.uniforms.numSplats.value = accumulator.splats.numSplats;\r\n      this.uniforms.packedSplats.value = accumulator.splats.getTexture();\r\n      this.uniforms.rgbMinMaxLnScaleMinMax.value.set(\r\n        accumulator.splats.splatEncoding?.rgbMin ?? 0.0,\r\n        accumulator.splats.splatEncoding?.rgbMax ?? 1.0,\r\n        accumulator.splats.splatEncoding?.lnScaleMin ?? LN_SCALE_MIN,\r\n        accumulator.splats.splatEncoding?.lnScaleMax ?? LN_SCALE_MAX,\r\n      );\r\n      this.geometry = geometry;\r\n      this.material.transparent = !this.viewpoint.stochastic;\r\n      this.material.depthWrite = this.viewpoint.stochastic;\r\n      this.material.needsUpdate = true;\r\n    } else {\r\n      // No Gsplats to display for this viewpoint yet\r\n      this.uniforms.numSplats.value = 0;\r\n      this.uniforms.packedSplats.value = PackedSplats.getEmpty();\r\n      this.geometry = EMPTY_GEOMETRY;\r\n    }\r\n  }\r\n\r\n  // If spark.autoUpdate is false then you must manually call\r\n  // spark.update({ scene }) to have the scene Gsplats be re-generated.\r\n  update({\r\n    scene,\r\n    viewToWorld,\r\n  }: { scene: THREE.Scene; viewToWorld?: THREE.Matrix4 }) {\r\n    // Compute the transform for the SparkRenderer to use as origin\r\n    // for Gsplat generation and accumulation.\r\n    const originToWorld = this.matrixWorld;\r\n\r\n    // Either do the update now, or in the next \"tick\" depending on preUpdate\r\n    if (this.preUpdate) {\r\n      this.updateInternal({\r\n        scene,\r\n        originToWorld: originToWorld.clone(),\r\n        viewToWorld,\r\n      });\r\n    } else {\r\n      // Pass the update parameters to be performed on the next tick\r\n      this.pendingUpdate.scene = scene;\r\n      this.pendingUpdate.originToWorld.copy(originToWorld);\r\n\r\n      // Schedule a timeout if there isn't one already\r\n      if (this.pendingUpdate.timeoutId === -1) {\r\n        this.pendingUpdate.timeoutId = setTimeout(() => {\r\n          const { scene, originToWorld } = this.pendingUpdate;\r\n          this.pendingUpdate.scene = null;\r\n          this.pendingUpdate.timeoutId = -1;\r\n          const updated = this.updateInternal({\r\n            scene: scene as THREE.Scene,\r\n            originToWorld,\r\n            viewToWorld,\r\n          });\r\n\r\n          if (updated) {\r\n            // Flush to encourage eager execution\r\n            const gl = this.renderer.getContext() as WebGL2RenderingContext;\r\n            gl.flush();\r\n          }\r\n        }, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  updateInternal({\r\n    scene,\r\n    originToWorld,\r\n    viewToWorld,\r\n  }: {\r\n    scene: THREE.Scene;\r\n    originToWorld?: THREE.Matrix4;\r\n    viewToWorld?: THREE.Matrix4;\r\n  }): boolean {\r\n    if (!this.canAllocAccumulator()) {\r\n      // We don't have any available accumulators because of sorting\r\n      // back pressure, so don't update this time but try again next time.\r\n      // Signal update not attempted.\r\n      return false;\r\n    }\r\n\r\n    // Figure out the frame of the SparkRenderer and current view\r\n    if (!originToWorld) {\r\n      originToWorld = this.active.toWorld;\r\n    }\r\n    viewToWorld = viewToWorld ?? originToWorld.clone();\r\n\r\n    const time = this.time ?? this.clock.getElapsedTime();\r\n    const deltaTime = time - (this.lastUpdateTime ?? time);\r\n    this.lastUpdateTime = time;\r\n\r\n    // Create a lookup from last active SplatGenerator to Gsplat mapping record\r\n    const activeMapping = this.active.mapping.reduce((map, record) => {\r\n      map.set(record.node, record);\r\n      return map;\r\n    }, new Map<SplatGenerator, GeneratorMapping>());\r\n\r\n    // Traverse visible scene to find all SplatGenerators and global SplatEdits\r\n    const { generators, visibleGenerators, globalEdits } =\r\n      this.compileScene(scene);\r\n\r\n    // Let all SplatGenerators run their frameUpdate() method\r\n    for (const object of generators) {\r\n      object.frameUpdate?.({\r\n        object,\r\n        time,\r\n        deltaTime,\r\n        viewToWorld,\r\n        globalEdits,\r\n      });\r\n    }\r\n\r\n    const visibleGenHash = new Set(visibleGenerators.map((g) => g.uuid));\r\n\r\n    // Make sure we have new version numbers for any objects with either\r\n    // generator or numSplats that have changed since the last frame.\r\n    for (const object of generators) {\r\n      const current = activeMapping.get(object);\r\n      const isVisible = object.generator && visibleGenHash.has(object.uuid);\r\n      const numSplats = isVisible ? object.numSplats : 0;\r\n      if (\r\n        this.needsUpdate ||\r\n        object.generator !== current?.generator ||\r\n        numSplats !== current?.count\r\n      ) {\r\n        object.updateVersion();\r\n      }\r\n    }\r\n\r\n    // Check if the origin is within the maximum allowed distance before\r\n    // we trigger an update.\r\n    const originUpdate = !withinCoorientDist({\r\n      matrix1: originToWorld,\r\n      matrix2: this.active.toWorld,\r\n      maxDistance: this.originDistance,\r\n    });\r\n\r\n    // Check if we need any update at all\r\n    const needsUpdate =\r\n      this.needsUpdate ||\r\n      originUpdate ||\r\n      generators.length !== activeMapping.size ||\r\n      generators.some((g) => g.version !== activeMapping.get(g)?.version);\r\n    this.needsUpdate = false;\r\n\r\n    let accumulator: SplatAccumulator | null = null;\r\n    if (needsUpdate) {\r\n      // Need to update, so allocate an accumulator\r\n      accumulator = this.maybeAllocAccumulator();\r\n      if (!accumulator) {\r\n        // This should never happen since we checked canAllocAccumulator() above\r\n        throw new Error(\"Unreachable\");\r\n      }\r\n\r\n      // Compute whether our view frame has changed enough to warrant\r\n      // doing a Gsplat sort. Check both distance epsilon and\r\n      // minimum co-orientation (dot product of quaternions)\r\n      const originChanged = !withinCoorientDist({\r\n        matrix1: originToWorld,\r\n        matrix2: accumulator.toWorld,\r\n        maxDistance: 0.00001,\r\n        minCoorient: 0.99999,\r\n      });\r\n\r\n      // Compute an ordering of the generators with the rough goal\r\n      // of keeping unchanging generators near the front to minimize\r\n      // the number of Gsplats that need to be regenerated.\r\n      const sorted = visibleGenerators\r\n        .map((g, gIndex): [number, number, SplatGenerator] => {\r\n          const lastGen = activeMapping.get(g);\r\n          // If no previous generator, sort by absolute version, which will\r\n          // tend to push frequently updated generators toward the end\r\n          return !lastGen\r\n            ? [Number.POSITIVE_INFINITY, g.version, g]\r\n            : // Sort by version deltas then by previous ordering in the mapping,\r\n              // attempting to keep unchanging generators near the front\r\n              // to improve our chances of avoiding a re-generation.\r\n              [g.version - lastGen.version, lastGen.base, g];\r\n        })\r\n        .sort((a, b) => {\r\n          // Sort by first then second element of the tuple\r\n          if (a[0] !== b[0]) {\r\n            return a[0] - b[0];\r\n          }\r\n          return a[1] - b[1];\r\n        });\r\n      const genOrder = sorted.map(([_version, _seq, g]) => g);\r\n\r\n      // Compute sequential layout of generated splats\r\n      const splatCounts = genOrder.map((g) => g.numSplats);\r\n      const { maxSplats, mapping } =\r\n        accumulator.splats.generateMapping(splatCounts);\r\n      const newGenerators = genOrder.map((node, gIndex) => {\r\n        const { base, count } = mapping[gIndex];\r\n        return {\r\n          node,\r\n          generator: node.generator,\r\n          version: node.version,\r\n          base,\r\n          count,\r\n        };\r\n      });\r\n\r\n      // Compute worldToAccumulator origin transform (no scale)\r\n      originToWorld\r\n        .clone()\r\n        .invert()\r\n        .decompose(\r\n          this.translateToAccumulator.value,\r\n          this.rotateToAccumulator.value,\r\n          new THREE.Vector3(),\r\n        );\r\n\r\n      // Generate the Gsplats according to the mapping that need updating\r\n      accumulator.ensureGenerate(maxSplats);\r\n      accumulator.splats.splatEncoding = { ...this.splatEncoding };\r\n      const generated = accumulator.generateSplats({\r\n        renderer: this.renderer,\r\n        modifier: this.modifier,\r\n        generators: newGenerators,\r\n        forceUpdate: originChanged,\r\n        originToWorld,\r\n      });\r\n\r\n      // Update splat version number\r\n      accumulator.splatsVersion = this.active.splatsVersion + 1;\r\n      // Increment the mapping version if the mapping isn't identical to before\r\n      const hasCorrespondence = accumulator.hasCorrespondence(this.active);\r\n      accumulator.mappingVersion =\r\n        this.active.mappingVersion + (hasCorrespondence ? 0 : 1);\r\n\r\n      // Release the old accumulator and make the new one active\r\n      this.releaseAccumulator(this.active);\r\n      this.active = accumulator;\r\n      this.prepareViewpoint();\r\n    }\r\n\r\n    // Let the system breath before potentially triggering sorts\r\n    setTimeout(() => {\r\n      // Notify all auto-updating viewpoints that we updated the Gsplats\r\n      for (const view of this.autoViewpoints) {\r\n        view.autoPoll({ accumulator: accumulator ?? undefined });\r\n      }\r\n    }, 1);\r\n\r\n    // Signal update was performed\r\n    return true;\r\n  }\r\n\r\n  private compileScene(scene: THREE.Scene): {\r\n    generators: SplatGenerator[];\r\n    visibleGenerators: SplatGenerator[];\r\n    globalEdits: SplatEdit[];\r\n  } {\r\n    // Take a snapshot of the SplatGenerators and SplatEdits in the scene\r\n    // to be used to run an update.\r\n    const generators: SplatGenerator[] = [];\r\n    // Collect all SplatGenerators, even if not visible, because we want to\r\n    // be able to call their update functions every frame.\r\n    scene.traverse((node) => {\r\n      if (node instanceof SplatGenerator) {\r\n        generators.push(node);\r\n      }\r\n    });\r\n\r\n    const visibleGenerators: SplatGenerator[] = [];\r\n    scene.traverseVisible((node) => {\r\n      if (node instanceof SplatGenerator) {\r\n        visibleGenerators.push(node);\r\n      }\r\n    });\r\n\r\n    const globalEdits = new Set<SplatEdit>();\r\n    scene.traverseVisible((node) => {\r\n      if (node instanceof SplatEdit) {\r\n        let ancestor = node.parent;\r\n        while (ancestor != null && !(ancestor instanceof SplatMesh)) {\r\n          ancestor = ancestor.parent;\r\n        }\r\n        if (ancestor == null) {\r\n          // Not part of a SplatMesh so it's a global edit\r\n          globalEdits.add(node);\r\n        }\r\n      }\r\n    });\r\n    return {\r\n      generators,\r\n      visibleGenerators,\r\n      globalEdits: Array.from(globalEdits),\r\n    };\r\n  }\r\n\r\n  // Renders out the scene to an environment map that can be used for\r\n  // Image-based lighting or similar applications. First optionally updates Gsplats,\r\n  // sorts them with respect to the provided worldCenter, renders 6 cube faces,\r\n  // then pre-filters them using THREE.PMREMGenerator and returns a THREE.Texture\r\n  // that can assigned directly to a THREE.MeshStandardMaterial.envMap property.\r\n  async renderEnvMap({\r\n    renderer,\r\n    scene,\r\n    worldCenter,\r\n    size = 256,\r\n    near = 0.1,\r\n    far = 1000,\r\n    hideObjects = [],\r\n    update = false,\r\n  }: {\r\n    renderer?: THREE.WebGLRenderer;\r\n    scene: THREE.Scene;\r\n    worldCenter: THREE.Vector3;\r\n    size?: number;\r\n    near?: number;\r\n    far?: number;\r\n    hideObjects?: THREE.Object3D[];\r\n    update?: boolean;\r\n  }): Promise<THREE.Texture> {\r\n    if (!this.envViewpoint) {\r\n      this.envViewpoint = this.newViewpoint({ sort360: true });\r\n    }\r\n    if (\r\n      !SparkRenderer.cubeRender ||\r\n      SparkRenderer.cubeRender.target.width !== size ||\r\n      SparkRenderer.cubeRender.near !== near ||\r\n      SparkRenderer.cubeRender.far !== far\r\n    ) {\r\n      if (SparkRenderer.cubeRender) {\r\n        SparkRenderer.cubeRender.target.dispose();\r\n      }\r\n      const target = new THREE.WebGLCubeRenderTarget(size, {\r\n        format: THREE.RGBAFormat,\r\n        generateMipmaps: true,\r\n        minFilter: THREE.LinearMipMapLinearFilter,\r\n      });\r\n      const camera = new THREE.CubeCamera(near, far, target);\r\n      SparkRenderer.cubeRender = { target, camera, near, far };\r\n    }\r\n\r\n    if (!SparkRenderer.pmrem) {\r\n      SparkRenderer.pmrem = new THREE.PMREMGenerator(renderer ?? this.renderer);\r\n    }\r\n\r\n    // Prepare the viewpoint, sorting Gsplats for this view origin.\r\n    const viewToWorld = new THREE.Matrix4().setPosition(worldCenter);\r\n    await this.envViewpoint?.prepare({ scene, viewToWorld, update });\r\n\r\n    const { target, camera } = SparkRenderer.cubeRender;\r\n    camera.position.copy(worldCenter);\r\n\r\n    // Save the visibility state of objects we want to hide before render\r\n    const objectVisibility = new Map<THREE.Object3D, boolean>();\r\n    for (const object of hideObjects) {\r\n      objectVisibility.set(object, object.visible);\r\n      object.visible = false;\r\n    }\r\n\r\n    // Update the CubeCamera, which performs 6 cube face renders\r\n    this.prepareViewpoint(this.envViewpoint);\r\n    camera.update(renderer ?? this.renderer, scene);\r\n\r\n    // Restore viewpoint to default and object visibility\r\n    this.prepareViewpoint(this.defaultView);\r\n    for (const [object, visible] of objectVisibility.entries()) {\r\n      object.visible = visible;\r\n    }\r\n\r\n    // Pre-filter the cube map using THREE.PMREMGenerator\r\n    return SparkRenderer.pmrem?.fromCubemap(target.texture).texture;\r\n  }\r\n\r\n  // Utility function to recursively set the envMap property for any\r\n  // THREE.MeshStandardMaterial within the subtree of root.\r\n  recurseSetEnvMap(root: THREE.Object3D, envMap: THREE.Texture) {\r\n    root.traverse((node) => {\r\n      if (node instanceof THREE.Mesh) {\r\n        if (Array.isArray(node.material)) {\r\n          for (const material of node.material) {\r\n            if (material instanceof THREE.MeshStandardMaterial) {\r\n              material.envMap = envMap;\r\n            }\r\n          }\r\n        } else {\r\n          if (node.material instanceof THREE.MeshStandardMaterial) {\r\n            node.material.envMap = envMap;\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  // Utility function that helps extract the Gsplat RGBA values from a\r\n  // SplatGenerator, including the result of any real-time RGBA SDF edits applied\r\n  // to a SplatMesh. This effectively \"bakes\" any computed RGBA values, which can\r\n  // now be used as a pipeline input via SplatMesh.splatRgba to inject these\r\n  // baked values into the Gsplat data.\r\n  getRgba({\r\n    generator,\r\n    rgba,\r\n  }: { generator: SplatGenerator; rgba?: RgbaArray }): RgbaArray {\r\n    const mapping = this.active.mapping.find(({ node }) => node === generator);\r\n    if (!mapping) {\r\n      throw new Error(\"Generator not found\");\r\n    }\r\n\r\n    rgba = rgba ?? new RgbaArray();\r\n    rgba.fromPackedSplats({\r\n      packedSplats: this.active.splats,\r\n      base: mapping.base,\r\n      count: mapping.count,\r\n      renderer: this.renderer,\r\n    });\r\n    return rgba;\r\n  }\r\n\r\n  // Utility function that builds on getRgba({ generator }) and additionally\r\n  // reads back the RGBA values to the CPU in a Uint8Array with packed RGBA\r\n  // in that byte order.\r\n  async readRgba({\r\n    generator,\r\n    rgba,\r\n  }: { generator: SplatGenerator; rgba?: RgbaArray }): Promise<Uint8Array> {\r\n    rgba = this.getRgba({ generator, rgba });\r\n    return rgba.read();\r\n  }\r\n}\r\n\r\nconst EMPTY_GEOMETRY = new SplatGeometry(new Uint32Array(1), 0);\r\n\r\nconst reorderSplats = dynoBlock(\r\n  { packedSplats: TPackedSplats, index: \"int\" },\r\n  { gsplat: Gsplat },\r\n  ({ packedSplats, index }) => {\r\n    if (!packedSplats || !index) {\r\n      throw new Error(\"Invalid input\");\r\n    }\r\n    const gsplat = readPackedSplat(packedSplats, index);\r\n    return { gsplat };\r\n  },\r\n);\r\n\r\nfunction averageOriginToWorlds(\r\n  originToWorlds: THREE.Matrix4[],\r\n): THREE.Matrix4 | null {\r\n  if (originToWorlds.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  const position = new THREE.Vector3();\r\n  const quaternion = new THREE.Quaternion();\r\n  const scale = new THREE.Vector3();\r\n\r\n  const positions: THREE.Vector3[] = [];\r\n  const quaternions: THREE.Quaternion[] = [];\r\n  for (const matrix of originToWorlds) {\r\n    matrix.decompose(position, quaternion, scale);\r\n    positions.push(position);\r\n    quaternions.push(quaternion);\r\n  }\r\n\r\n  return new THREE.Matrix4().compose(\r\n    averagePositions(positions),\r\n    averageQuaternions(quaternions),\r\n    new THREE.Vector3(1, 1, 1),\r\n  );\r\n}\r\n","import type { SplatEncoding } from \"./PackedSplats\";\r\nimport { computeMaxSplats, setPackedSplat } from \"./utils\";\r\n\r\nexport function decodeAntiSplat(\r\n  fileBytes: Uint8Array,\r\n  initNumSplats: (numSplats: number) => void,\r\n  splatCallback: (\r\n    index: number,\r\n    x: number,\r\n    y: number,\r\n    z: number,\r\n    scaleX: number,\r\n    scaleY: number,\r\n    scaleZ: number,\r\n    quatX: number,\r\n    quatY: number,\r\n    quatZ: number,\r\n    quatW: number,\r\n    opacity: number,\r\n    r: number,\r\n    g: number,\r\n    b: number,\r\n  ) => void,\r\n) {\r\n  const numSplats = Math.floor(fileBytes.length / 32); // 32 bytes per splat\r\n  if (numSplats * 32 !== fileBytes.length) {\r\n    throw new Error(\"Invalid .splat file size\");\r\n  }\r\n  initNumSplats(numSplats);\r\n\r\n  const f32 = new Float32Array(fileBytes.buffer);\r\n  for (let i = 0; i < numSplats; ++i) {\r\n    const i32 = i * 32;\r\n    const i8 = i * 8;\r\n    const x = f32[i8 + 0];\r\n    const y = f32[i8 + 1];\r\n    const z = f32[i8 + 2];\r\n    const scaleX = f32[i8 + 3];\r\n    const scaleY = f32[i8 + 4];\r\n    const scaleZ = f32[i8 + 5];\r\n    const r = fileBytes[i32 + 24] / 255;\r\n    const g = fileBytes[i32 + 25] / 255;\r\n    const b = fileBytes[i32 + 26] / 255;\r\n    const opacity = fileBytes[i32 + 27] / 255;\r\n    const quatW = (fileBytes[i32 + 28] - 128) / 128;\r\n    const quatX = (fileBytes[i32 + 29] - 128) / 128;\r\n    const quatY = (fileBytes[i32 + 30] - 128) / 128;\r\n    const quatZ = (fileBytes[i32 + 31] - 128) / 128;\r\n    splatCallback(\r\n      i,\r\n      x,\r\n      y,\r\n      z,\r\n      scaleX,\r\n      scaleY,\r\n      scaleZ,\r\n      quatX,\r\n      quatY,\r\n      quatZ,\r\n      quatW,\r\n      opacity,\r\n      r,\r\n      g,\r\n      b,\r\n    );\r\n  }\r\n}\r\n\r\nexport function unpackAntiSplat(\r\n  fileBytes: Uint8Array,\r\n  splatEncoding: SplatEncoding,\r\n): {\r\n  packedArray: Uint32Array;\r\n  numSplats: number;\r\n} {\r\n  let numSplats = 0;\r\n  let maxSplats = 0;\r\n  let packedArray = new Uint32Array(0);\r\n  decodeAntiSplat(\r\n    fileBytes,\r\n    (cbNumSplats) => {\r\n      numSplats = cbNumSplats;\r\n      maxSplats = computeMaxSplats(numSplats);\r\n      packedArray = new Uint32Array(maxSplats * 4);\r\n    },\r\n    (\r\n      index,\r\n      x,\r\n      y,\r\n      z,\r\n      scaleX,\r\n      scaleY,\r\n      scaleZ,\r\n      quatX,\r\n      quatY,\r\n      quatZ,\r\n      quatW,\r\n      opacity,\r\n      r,\r\n      g,\r\n      b,\r\n    ) => {\r\n      setPackedSplat(\r\n        packedArray,\r\n        index,\r\n        x,\r\n        y,\r\n        z,\r\n        scaleX,\r\n        scaleY,\r\n        scaleZ,\r\n        quatX,\r\n        quatY,\r\n        quatZ,\r\n        quatW,\r\n        opacity,\r\n        r,\r\n        g,\r\n        b,\r\n        splatEncoding,\r\n      );\r\n    },\r\n  );\r\n  return { packedArray, numSplats };\r\n}\r\n","import type { SplatEncoding } from \"./PackedSplats\";\r\nimport {\r\n  computeMaxSplats,\r\n  encodeSh1Rgb,\r\n  encodeSh2Rgb,\r\n  encodeSh3Rgb,\r\n  fromHalf,\r\n  setPackedSplat,\r\n} from \"./utils\";\r\n\r\ntype KsplatCompression = {\r\n  bytesPerCenter: number;\r\n  bytesPerScale: number;\r\n  bytesPerRotation: number;\r\n  bytesPerColor: number;\r\n  bytesPerSphericalHarmonicsComponent: number;\r\n  scaleOffsetBytes: number;\r\n  rotationOffsetBytes: number;\r\n  colorOffsetBytes: number;\r\n  sphericalHarmonicsOffsetBytes: number;\r\n  scaleRange: number;\r\n};\r\n\r\nconst KSPLAT_COMPRESSION: Record<number, KsplatCompression> = {\r\n  0: {\r\n    bytesPerCenter: 12,\r\n    bytesPerScale: 12,\r\n    bytesPerRotation: 16,\r\n    bytesPerColor: 4,\r\n    bytesPerSphericalHarmonicsComponent: 4,\r\n    scaleOffsetBytes: 12,\r\n    rotationOffsetBytes: 24,\r\n    colorOffsetBytes: 40,\r\n    sphericalHarmonicsOffsetBytes: 44,\r\n    scaleRange: 1,\r\n  },\r\n  1: {\r\n    bytesPerCenter: 6,\r\n    bytesPerScale: 6,\r\n    bytesPerRotation: 8,\r\n    bytesPerColor: 4,\r\n    bytesPerSphericalHarmonicsComponent: 2,\r\n    scaleOffsetBytes: 6,\r\n    rotationOffsetBytes: 12,\r\n    colorOffsetBytes: 20,\r\n    sphericalHarmonicsOffsetBytes: 24,\r\n    scaleRange: 32767,\r\n  },\r\n  2: {\r\n    bytesPerCenter: 6,\r\n    bytesPerScale: 6,\r\n    bytesPerRotation: 8,\r\n    bytesPerColor: 4,\r\n    bytesPerSphericalHarmonicsComponent: 1,\r\n    scaleOffsetBytes: 6,\r\n    rotationOffsetBytes: 12,\r\n    colorOffsetBytes: 20,\r\n    sphericalHarmonicsOffsetBytes: 24,\r\n    scaleRange: 32767,\r\n  },\r\n};\r\n\r\nconst KSPLAT_SH_DEGREE_TO_COMPONENTS: Record<number, number> = {\r\n  0: 0,\r\n  1: 9,\r\n  2: 24,\r\n  3: 45,\r\n};\r\n\r\nexport function decodeKsplat(\r\n  fileBytes: Uint8Array,\r\n  initNumSplats: (numSplats: number) => void,\r\n  splatCallback: (\r\n    index: number,\r\n    x: number,\r\n    y: number,\r\n    z: number,\r\n    scaleX: number,\r\n    scaleY: number,\r\n    scaleZ: number,\r\n    quatX: number,\r\n    quatY: number,\r\n    quatZ: number,\r\n    quatW: number,\r\n    opacity: number,\r\n    r: number,\r\n    g: number,\r\n    b: number,\r\n  ) => void,\r\n  shCallback?: (\r\n    index: number,\r\n    sh1: Float32Array,\r\n    sh2?: Float32Array,\r\n    sh3?: Float32Array,\r\n  ) => void,\r\n) {\r\n  const HEADER_BYTES = 4096;\r\n  const SECTION_BYTES = 1024;\r\n\r\n  let headerOffset = 0;\r\n  const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\r\n  headerOffset += HEADER_BYTES;\r\n\r\n  const versionMajor = header.getUint8(0);\r\n  const versionMinor = header.getUint8(1);\r\n  if (versionMajor !== 0 || versionMinor < 1) {\r\n    throw new Error(\r\n      `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`,\r\n    );\r\n  }\r\n  const maxSectionCount = header.getUint32(4, true);\r\n  // const sectionCount = header.getUint32(8, true);\r\n  // const maxSplatCount = header.getUint32(12, true);\r\n  const splatCount = header.getUint32(16, true);\r\n  const compressionLevel = header.getUint16(20, true);\r\n  if (compressionLevel < 0 || compressionLevel > 2) {\r\n    throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\r\n  }\r\n  // const sceneCenterX = header.getFloat32(24, true);\r\n  // const sceneCenterY = header.getFloat32(28, true);\r\n  // const sceneCenterZ = header.getFloat32(32, true);\r\n  const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\r\n  const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\r\n\r\n  const numSplats = splatCount;\r\n  initNumSplats(numSplats);\r\n  const maxSplats = computeMaxSplats(numSplats);\r\n  const packedArray = new Uint32Array(maxSplats * 4);\r\n  const extra: Record<string, unknown> = {};\r\n\r\n  let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\r\n\r\n  for (let section = 0; section < maxSectionCount; ++section) {\r\n    const section = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\r\n    headerOffset += SECTION_BYTES;\r\n\r\n    const sectionSplatCount = section.getUint32(0, true);\r\n    const sectionMaxSplatCount = section.getUint32(4, true);\r\n    const bucketSize = section.getUint32(8, true);\r\n    const bucketCount = section.getUint32(12, true);\r\n    const bucketBlockSize = section.getFloat32(16, true);\r\n    const bucketStorageSizeBytes = section.getUint16(20, true);\r\n    const compressionScaleRange =\r\n      (section.getUint32(24, true) ||\r\n        KSPLAT_COMPRESSION[compressionLevel]?.scaleRange) ??\r\n      1;\r\n    const fullBucketCount = section.getUint32(32, true);\r\n    const fullBucketSplats = fullBucketCount * bucketSize;\r\n    const partiallyFilledBucketCount = section.getUint32(36, true);\r\n    const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\r\n    const bucketsStorageSizeBytes =\r\n      bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\r\n    const sphericalHarmonicsDegree = section.getUint16(40, true);\r\n    const shComponents =\r\n      KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\r\n\r\n    const {\r\n      bytesPerCenter,\r\n      bytesPerScale,\r\n      bytesPerRotation,\r\n      bytesPerColor,\r\n      bytesPerSphericalHarmonicsComponent,\r\n      scaleOffsetBytes,\r\n      rotationOffsetBytes,\r\n      colorOffsetBytes,\r\n      sphericalHarmonicsOffsetBytes,\r\n    } = KSPLAT_COMPRESSION[compressionLevel];\r\n    const bytesPerSplat =\r\n      bytesPerCenter +\r\n      bytesPerScale +\r\n      bytesPerRotation +\r\n      bytesPerColor +\r\n      shComponents * bytesPerSphericalHarmonicsComponent;\r\n    const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\r\n    const storageSizeBytes =\r\n      splatDataStorageSizeBytes + bucketsStorageSizeBytes;\r\n\r\n    const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\r\n    const sh2Index = [\r\n      9, 14, 19, 10, 15, 20, 11, 16, 21, 12, 17, 22, 13, 18, 23,\r\n    ];\r\n    const sh3Index = [\r\n      24, 31, 38, 25, 32, 39, 26, 33, 40, 27, 34, 41, 28, 35, 42, 29, 36, 43,\r\n      30, 37, 44,\r\n    ];\r\n    const sh1 =\r\n      sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : undefined;\r\n    const sh2 =\r\n      sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : undefined;\r\n    const sh3 =\r\n      sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : undefined;\r\n\r\n    const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\r\n    const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\r\n    const dataBase = sectionBase + bucketsStorageSizeBytes;\r\n    const data = new DataView(\r\n      fileBytes.buffer,\r\n      dataBase,\r\n      splatDataStorageSizeBytes,\r\n    );\r\n    const bucketArray = new Float32Array(\r\n      fileBytes.buffer,\r\n      bucketsBase,\r\n      bucketCount * 3,\r\n    );\r\n    const partiallyFilledBucketLengths = new Uint32Array(\r\n      fileBytes.buffer,\r\n      sectionBase,\r\n      partiallyFilledBucketCount,\r\n    );\r\n\r\n    function getSh(splatOffset: number, component: number) {\r\n      if (compressionLevel === 0) {\r\n        return data.getFloat32(\r\n          splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\r\n          true,\r\n        );\r\n      }\r\n      if (compressionLevel === 1) {\r\n        return fromHalf(\r\n          data.getUint16(\r\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\r\n            true,\r\n          ),\r\n        );\r\n      }\r\n      const t =\r\n        data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) /\r\n        255;\r\n      return (\r\n        minSphericalHarmonicsCoeff +\r\n        t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff)\r\n      );\r\n    }\r\n\r\n    let partialBucketIndex = fullBucketCount;\r\n    let partialBucketBase = fullBucketSplats;\r\n\r\n    for (let i = 0; i < sectionSplatCount; ++i) {\r\n      const splatOffset = i * bytesPerSplat;\r\n\r\n      let bucketIndex: number;\r\n      if (i < fullBucketSplats) {\r\n        bucketIndex = Math.floor(i / bucketSize);\r\n      } else {\r\n        const bucketLength =\r\n          partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\r\n        if (i >= partialBucketBase + bucketLength) {\r\n          partialBucketIndex += 1;\r\n          partialBucketBase += bucketLength;\r\n        }\r\n        bucketIndex = partialBucketIndex;\r\n      }\r\n\r\n      const x =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + 0, true)\r\n          : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) *\r\n              compressionScaleFactor +\r\n            bucketArray[3 * bucketIndex + 0];\r\n      const y =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + 4, true)\r\n          : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) *\r\n              compressionScaleFactor +\r\n            bucketArray[3 * bucketIndex + 1];\r\n      const z =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + 8, true)\r\n          : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) *\r\n              compressionScaleFactor +\r\n            bucketArray[3 * bucketIndex + 2];\r\n\r\n      const scaleX =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true)\r\n          : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\r\n      const scaleY =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true)\r\n          : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\r\n      const scaleZ =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true)\r\n          : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\r\n\r\n      const quatW =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true)\r\n          : fromHalf(\r\n              data.getUint16(splatOffset + rotationOffsetBytes + 0, true),\r\n            );\r\n      const quatX =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true)\r\n          : fromHalf(\r\n              data.getUint16(splatOffset + rotationOffsetBytes + 2, true),\r\n            );\r\n      const quatY =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true)\r\n          : fromHalf(\r\n              data.getUint16(splatOffset + rotationOffsetBytes + 4, true),\r\n            );\r\n      const quatZ =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true)\r\n          : fromHalf(\r\n              data.getUint16(splatOffset + rotationOffsetBytes + 6, true),\r\n            );\r\n\r\n      const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\r\n      const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\r\n      const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\r\n      const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\r\n\r\n      splatCallback(\r\n        i,\r\n        x,\r\n        y,\r\n        z,\r\n        scaleX,\r\n        scaleY,\r\n        scaleZ,\r\n        quatX,\r\n        quatY,\r\n        quatZ,\r\n        quatW,\r\n        opacity,\r\n        r,\r\n        g,\r\n        b,\r\n      );\r\n\r\n      if (sphericalHarmonicsDegree >= 1 && sh1) {\r\n        for (const [i, key] of sh1Index.entries()) {\r\n          sh1[i] = getSh(splatOffset, key);\r\n        }\r\n        if (sh2) {\r\n          for (const [i, key] of sh2Index.entries()) {\r\n            sh2[i] = getSh(splatOffset, key);\r\n          }\r\n        }\r\n        if (sh3) {\r\n          for (const [i, key] of sh3Index.entries()) {\r\n            sh3[i] = getSh(splatOffset, key);\r\n          }\r\n        }\r\n        shCallback?.(i, sh1, sh2, sh3);\r\n      }\r\n    }\r\n    sectionBase += storageSizeBytes;\r\n  }\r\n}\r\n\r\nexport function unpackKsplat(\r\n  fileBytes: Uint8Array,\r\n  splatEncoding: SplatEncoding,\r\n): {\r\n  packedArray: Uint32Array;\r\n  numSplats: number;\r\n  extra: Record<string, unknown>;\r\n} {\r\n  const HEADER_BYTES = 4096;\r\n  const SECTION_BYTES = 1024;\r\n\r\n  let headerOffset = 0;\r\n  const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\r\n  headerOffset += HEADER_BYTES;\r\n\r\n  const versionMajor = header.getUint8(0);\r\n  const versionMinor = header.getUint8(1);\r\n  if (versionMajor !== 0 || versionMinor < 1) {\r\n    throw new Error(\r\n      `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`,\r\n    );\r\n  }\r\n  const maxSectionCount = header.getUint32(4, true);\r\n  // const sectionCount = header.getUint32(8, true);\r\n  // const maxSplatCount = header.getUint32(12, true);\r\n  const splatCount = header.getUint32(16, true);\r\n  const compressionLevel = header.getUint16(20, true);\r\n  if (compressionLevel < 0 || compressionLevel > 2) {\r\n    throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\r\n  }\r\n  // const sceneCenterX = header.getFloat32(24, true);\r\n  // const sceneCenterY = header.getFloat32(28, true);\r\n  // const sceneCenterZ = header.getFloat32(32, true);\r\n  const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\r\n  const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\r\n\r\n  const numSplats = splatCount;\r\n  const maxSplats = computeMaxSplats(numSplats);\r\n  const packedArray = new Uint32Array(maxSplats * 4);\r\n  const extra: Record<string, unknown> = {};\r\n\r\n  let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\r\n\r\n  for (let section = 0; section < maxSectionCount; ++section) {\r\n    const section = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\r\n    headerOffset += SECTION_BYTES;\r\n\r\n    const sectionSplatCount = section.getUint32(0, true);\r\n    const sectionMaxSplatCount = section.getUint32(4, true);\r\n    const bucketSize = section.getUint32(8, true);\r\n    const bucketCount = section.getUint32(12, true);\r\n    const bucketBlockSize = section.getFloat32(16, true);\r\n    const bucketStorageSizeBytes = section.getUint16(20, true);\r\n    const compressionScaleRange =\r\n      (section.getUint32(24, true) ||\r\n        KSPLAT_COMPRESSION[compressionLevel]?.scaleRange) ??\r\n      1;\r\n    const fullBucketCount = section.getUint32(32, true);\r\n    const fullBucketSplats = fullBucketCount * bucketSize;\r\n    const partiallyFilledBucketCount = section.getUint32(36, true);\r\n    const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\r\n    const bucketsStorageSizeBytes =\r\n      bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\r\n    const sphericalHarmonicsDegree = section.getUint16(40, true);\r\n    const shComponents =\r\n      KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\r\n\r\n    const {\r\n      bytesPerCenter,\r\n      bytesPerScale,\r\n      bytesPerRotation,\r\n      bytesPerColor,\r\n      bytesPerSphericalHarmonicsComponent,\r\n      scaleOffsetBytes,\r\n      rotationOffsetBytes,\r\n      colorOffsetBytes,\r\n      sphericalHarmonicsOffsetBytes,\r\n    } = KSPLAT_COMPRESSION[compressionLevel];\r\n    const bytesPerSplat =\r\n      bytesPerCenter +\r\n      bytesPerScale +\r\n      bytesPerRotation +\r\n      bytesPerColor +\r\n      shComponents * bytesPerSphericalHarmonicsComponent;\r\n    const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\r\n    const storageSizeBytes =\r\n      splatDataStorageSizeBytes + bucketsStorageSizeBytes;\r\n\r\n    const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\r\n    const sh2Index = [\r\n      9, 14, 19, 10, 15, 20, 11, 16, 21, 12, 17, 22, 13, 18, 23,\r\n    ];\r\n    const sh3Index = [\r\n      24, 31, 38, 25, 32, 39, 26, 33, 40, 27, 34, 41, 28, 35, 42, 29, 36, 43,\r\n      30, 37, 44,\r\n    ];\r\n    const sh1 =\r\n      sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : undefined;\r\n    const sh2 =\r\n      sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : undefined;\r\n    const sh3 =\r\n      sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : undefined;\r\n\r\n    const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\r\n    const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\r\n    const dataBase = sectionBase + bucketsStorageSizeBytes;\r\n    const data = new DataView(\r\n      fileBytes.buffer,\r\n      dataBase,\r\n      splatDataStorageSizeBytes,\r\n    );\r\n    const bucketArray = new Float32Array(\r\n      fileBytes.buffer,\r\n      bucketsBase,\r\n      bucketCount * 3,\r\n    );\r\n    const partiallyFilledBucketLengths = new Uint32Array(\r\n      fileBytes.buffer,\r\n      sectionBase,\r\n      partiallyFilledBucketCount,\r\n    );\r\n\r\n    function getSh(splatOffset: number, component: number) {\r\n      if (compressionLevel === 0) {\r\n        return data.getFloat32(\r\n          splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\r\n          true,\r\n        );\r\n      }\r\n      if (compressionLevel === 1) {\r\n        return fromHalf(\r\n          data.getUint16(\r\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\r\n            true,\r\n          ),\r\n        );\r\n      }\r\n      const t =\r\n        data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) /\r\n        255;\r\n      return (\r\n        minSphericalHarmonicsCoeff +\r\n        t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff)\r\n      );\r\n    }\r\n\r\n    let partialBucketIndex = fullBucketCount;\r\n    let partialBucketBase = fullBucketSplats;\r\n\r\n    for (let i = 0; i < sectionSplatCount; ++i) {\r\n      const splatOffset = i * bytesPerSplat;\r\n\r\n      let bucketIndex: number;\r\n      if (i < fullBucketSplats) {\r\n        bucketIndex = Math.floor(i / bucketSize);\r\n      } else {\r\n        const bucketLength =\r\n          partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\r\n        if (i >= partialBucketBase + bucketLength) {\r\n          partialBucketIndex += 1;\r\n          partialBucketBase += bucketLength;\r\n        }\r\n        bucketIndex = partialBucketIndex;\r\n      }\r\n\r\n      const x =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + 0, true)\r\n          : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) *\r\n              compressionScaleFactor +\r\n            bucketArray[3 * bucketIndex + 0];\r\n      const y =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + 4, true)\r\n          : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) *\r\n              compressionScaleFactor +\r\n            bucketArray[3 * bucketIndex + 1];\r\n      const z =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + 8, true)\r\n          : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) *\r\n              compressionScaleFactor +\r\n            bucketArray[3 * bucketIndex + 2];\r\n\r\n      const scaleX =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true)\r\n          : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\r\n      const scaleY =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true)\r\n          : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\r\n      const scaleZ =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true)\r\n          : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\r\n\r\n      const quatW =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true)\r\n          : fromHalf(\r\n              data.getUint16(splatOffset + rotationOffsetBytes + 0, true),\r\n            );\r\n      const quatX =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true)\r\n          : fromHalf(\r\n              data.getUint16(splatOffset + rotationOffsetBytes + 2, true),\r\n            );\r\n      const quatY =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true)\r\n          : fromHalf(\r\n              data.getUint16(splatOffset + rotationOffsetBytes + 4, true),\r\n            );\r\n      const quatZ =\r\n        compressionLevel === 0\r\n          ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true)\r\n          : fromHalf(\r\n              data.getUint16(splatOffset + rotationOffsetBytes + 6, true),\r\n            );\r\n\r\n      const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\r\n      const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\r\n      const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\r\n      const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\r\n\r\n      setPackedSplat(\r\n        packedArray,\r\n        i,\r\n        x,\r\n        y,\r\n        z,\r\n        scaleX,\r\n        scaleY,\r\n        scaleZ,\r\n        quatX,\r\n        quatY,\r\n        quatZ,\r\n        quatW,\r\n        opacity,\r\n        r,\r\n        g,\r\n        b,\r\n        splatEncoding,\r\n      );\r\n\r\n      if (sphericalHarmonicsDegree >= 1) {\r\n        if (sh1) {\r\n          if (!extra.sh1) {\r\n            extra.sh1 = new Uint32Array(numSplats * 2);\r\n          }\r\n          for (const [i, key] of sh1Index.entries()) {\r\n            sh1[i] = getSh(splatOffset, key);\r\n          }\r\n          encodeSh1Rgb(extra.sh1 as Uint32Array, i, sh1, splatEncoding);\r\n        }\r\n        if (sh2) {\r\n          if (!extra.sh2) {\r\n            extra.sh2 = new Uint32Array(numSplats * 4);\r\n          }\r\n          for (const [i, key] of sh2Index.entries()) {\r\n            sh2[i] = getSh(splatOffset, key);\r\n          }\r\n          encodeSh2Rgb(extra.sh2 as Uint32Array, i, sh2, splatEncoding);\r\n        }\r\n        if (sh3) {\r\n          if (!extra.sh3) {\r\n            extra.sh3 = new Uint32Array(numSplats * 4);\r\n          }\r\n          for (const [i, key] of sh3Index.entries()) {\r\n            sh3[i] = getSh(splatOffset, key);\r\n          }\r\n          encodeSh3Rgb(extra.sh3 as Uint32Array, i, sh3, splatEncoding);\r\n        }\r\n      }\r\n    }\r\n    sectionBase += storageSizeBytes;\r\n  }\r\n  return { packedArray, numSplats, extra };\r\n}\r\n","import * as THREE from \"three\";\r\nimport {\r\n  SplatData,\r\n  SplatFileType,\r\n  type TranscodeSpzInput,\r\n  getSplatFileType,\r\n  getSplatFileTypeFromPath,\r\n} from \"./SplatLoader\";\r\nimport { GunzipReader, fromHalf, normalize, unpackSplat } from \"./utils\";\r\n\r\nimport { decodeAntiSplat } from \"./antisplat\";\r\nimport { decodeKsplat } from \"./ksplat\";\r\nimport { PlyReader } from \"./ply\";\r\n\r\n// SPZ file format reader\r\n\r\nexport class SpzReader {\r\n  fileBytes: Uint8Array;\r\n  reader: GunzipReader;\r\n\r\n  version = -1;\r\n  numSplats = 0;\r\n  shDegree = 0;\r\n  fractionalBits = 0;\r\n  flags = 0;\r\n  flagAntiAlias = false;\r\n  reserved = 0;\r\n  headerParsed = false;\r\n  parsed = false;\r\n\r\n  constructor({ fileBytes }: { fileBytes: Uint8Array | ArrayBuffer }) {\r\n    this.fileBytes =\r\n      fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\r\n    this.reader = new GunzipReader({ fileBytes: this.fileBytes });\r\n  }\r\n\r\n  async parseHeader() {\r\n    if (this.headerParsed) {\r\n      throw new Error(\"SPZ file header already parsed\");\r\n    }\r\n\r\n    const header = new DataView((await this.reader.read(16)).buffer);\r\n    if (header.getUint32(0, true) !== 0x5053474e) {\r\n      throw new Error(\"Invalid SPZ file\");\r\n    }\r\n    this.version = header.getUint32(4, true);\r\n    if (this.version < 1 || this.version > 3) {\r\n      throw new Error(`Unsupported SPZ version: ${this.version}`);\r\n    }\r\n\r\n    this.numSplats = header.getUint32(8, true);\r\n    this.shDegree = header.getUint8(12);\r\n    this.fractionalBits = header.getUint8(13);\r\n    this.flags = header.getUint8(14);\r\n    this.flagAntiAlias = (this.flags & 0x01) !== 0;\r\n    this.reserved = header.getUint8(15);\r\n    this.headerParsed = true;\r\n    this.parsed = false;\r\n  }\r\n\r\n  async parseSplats(\r\n    centerCallback?: (index: number, x: number, y: number, z: number) => void,\r\n    alphaCallback?: (index: number, alpha: number) => void,\r\n    rgbCallback?: (index: number, r: number, g: number, b: number) => void,\r\n    scalesCallback?: (\r\n      index: number,\r\n      scaleX: number,\r\n      scaleY: number,\r\n      scaleZ: number,\r\n    ) => void,\r\n    quatCallback?: (\r\n      index: number,\r\n      quatX: number,\r\n      quatY: number,\r\n      quatZ: number,\r\n      quatW: number,\r\n    ) => void,\r\n    shCallback?: (\r\n      index: number,\r\n      sh1: Float32Array,\r\n      sh2?: Float32Array,\r\n      sh3?: Float32Array,\r\n    ) => void,\r\n  ) {\r\n    if (!this.headerParsed) {\r\n      throw new Error(\"SPZ file header must be parsed first\");\r\n    }\r\n    if (this.parsed) {\r\n      throw new Error(\"SPZ file already parsed\");\r\n    }\r\n    this.parsed = true;\r\n\r\n    if (this.version === 1) {\r\n      // float16 centers\r\n      const centerBytes = await this.reader.read(this.numSplats * 3 * 2);\r\n      const centerUint16 = new Uint16Array(centerBytes.buffer);\r\n      for (let i = 0; i < this.numSplats; i++) {\r\n        const i3 = i * 3;\r\n        const x = fromHalf(centerUint16[i3]);\r\n        const y = fromHalf(centerUint16[i3 + 1]);\r\n        const z = fromHalf(centerUint16[i3 + 2]);\r\n        centerCallback?.(i, x, y, z);\r\n      }\r\n    } else if (this.version === 2 || this.version === 3) {\r\n      // 24-bit fixed-point centers\r\n      const fixed = 1 << this.fractionalBits;\r\n      const centerBytes = await this.reader.read(this.numSplats * 3 * 3);\r\n      for (let i = 0; i < this.numSplats; i++) {\r\n        const i9 = i * 9;\r\n        const x =\r\n          (((centerBytes[i9 + 2] << 24) |\r\n            (centerBytes[i9 + 1] << 16) |\r\n            (centerBytes[i9] << 8)) >>\r\n            8) /\r\n          fixed;\r\n        const y =\r\n          (((centerBytes[i9 + 5] << 24) |\r\n            (centerBytes[i9 + 4] << 16) |\r\n            (centerBytes[i9 + 3] << 8)) >>\r\n            8) /\r\n          fixed;\r\n        const z =\r\n          (((centerBytes[i9 + 8] << 24) |\r\n            (centerBytes[i9 + 7] << 16) |\r\n            (centerBytes[i9 + 6] << 8)) >>\r\n            8) /\r\n          fixed;\r\n        centerCallback?.(i, x, y, z);\r\n      }\r\n    } else {\r\n      throw new Error(\"Unreachable\");\r\n    }\r\n\r\n    {\r\n      const bytes = await this.reader.read(this.numSplats);\r\n      for (let i = 0; i < this.numSplats; i++) {\r\n        alphaCallback?.(i, bytes[i] / 255);\r\n      }\r\n    }\r\n    {\r\n      const rgbBytes = await this.reader.read(this.numSplats * 3);\r\n      const scale = SH_C0 / 0.15;\r\n      for (let i = 0; i < this.numSplats; i++) {\r\n        const i3 = i * 3;\r\n        const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;\r\n        const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;\r\n        const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;\r\n        rgbCallback?.(i, r, g, b);\r\n      }\r\n    }\r\n    {\r\n      const scalesBytes = await this.reader.read(this.numSplats * 3);\r\n      for (let i = 0; i < this.numSplats; i++) {\r\n        const i3 = i * 3;\r\n        const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);\r\n        const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);\r\n        const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);\r\n        scalesCallback?.(i, scaleX, scaleY, scaleZ);\r\n      }\r\n    }\r\n    if (this.version === 3) {\r\n      // Version 3 uses a trick called \"smallest three\" to compress the rotation quaternions\r\n      // achieving better precision. \"Optimizing orientation\" section at https://gafferongames.com/post/snapshot_compression/ A quaternion length must be 1: x^2+y^2+z^2+w^2 = 1\r\n      // We can drop one component and reconstruct it with the identity above.\r\n      // Largest component is dropped for best numerical precision.\r\n      // Quaternion stored in 32 bits\r\n      // 10 bits singed integer for each of the 3 components + 2 bits indicating the index of dropped component.\r\n      // vs 8 bits for each component uncompressed (spz version < 3)\r\n      // Max Value after extracting largest component v is another component v\r\n      // (v,v,0,0)\r\n      // v^2 + v^2 = 1\r\n      // v = 1 / sqrt(2);\r\n      const maxValue = 1 / Math.sqrt(2); // 0.7071\r\n      const quatBytes = await this.reader.read(this.numSplats * 4);\r\n      for (let i = 0; i < this.numSplats; i++) {\r\n        const i3 = i * 4;\r\n        const quaternion = [0, 0, 0, 0];\r\n        const values = [\r\n          quatBytes[i3],\r\n          quatBytes[i3 + 1],\r\n          quatBytes[i3 + 2],\r\n          quatBytes[i3 + 3],\r\n        ];\r\n        // all values are packed in 32 bits (10 per each of 3 components + 2 bits of index of larged value)\r\n        const combinedValues =\r\n          values[0] + (values[1] << 8) + (values[2] << 16) + (values[3] << 24);\r\n        // each component value is 9 bits + sign (1 bit)\r\n        const valueMask = (1 << 9) - 1;\r\n        // extract index of the largest element. 2 top bits.\r\n        const largestIndex = combinedValues >>> 30;\r\n        let remainingValues = combinedValues;\r\n        let sumSquares = 0;\r\n\r\n        for (let i = 3; i >= 0; --i) {\r\n          if (i !== largestIndex) {\r\n            // extract current value and sign.\r\n            const value = remainingValues & valueMask;\r\n            const sign = (remainingValues >>> 9) & 0x1;\r\n            // each value is represented as 10 bits. Shift to next one.\r\n            remainingValues = remainingValues >>> 10;\r\n            // convert to range [0,1] and then to [0, 0.7071]\r\n            quaternion[i] = maxValue * (value / valueMask);\r\n            // apply sign.\r\n            quaternion[i] = sign === 0 ? quaternion[i] : -quaternion[i];\r\n            // accumulate the sum of squares\r\n            sumSquares += quaternion[i] * quaternion[i];\r\n          }\r\n        }\r\n\r\n        // quartenion length must be 1 (x^2+y^2+z^2+w^2 = 1)\r\n        // so can reconstruct largest component from the other 3.\r\n        // w = sqrt(1 - x^2 - y^2 - z^2);\r\n        const square = 1 - sumSquares;\r\n        quaternion[largestIndex] = Math.sqrt(Math.max(square, 0));\r\n\r\n        quatCallback?.(\r\n          i,\r\n          quaternion[0],\r\n          quaternion[1],\r\n          quaternion[2],\r\n          quaternion[3],\r\n        );\r\n      }\r\n    } else {\r\n      const quatBytes = await this.reader.read(this.numSplats * 3);\r\n      for (let i = 0; i < this.numSplats; i++) {\r\n        const i3 = i * 3;\r\n        const quatX = quatBytes[i3] / 127.5 - 1;\r\n        const quatY = quatBytes[i3 + 1] / 127.5 - 1;\r\n        const quatZ = quatBytes[i3 + 2] / 127.5 - 1;\r\n        const quatW = Math.sqrt(\r\n          Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ),\r\n        );\r\n        quatCallback?.(i, quatX, quatY, quatZ, quatW);\r\n      }\r\n    }\r\n\r\n    if (shCallback && this.shDegree >= 1) {\r\n      const sh1 = new Float32Array(3 * 3);\r\n      const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : undefined;\r\n      const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : undefined;\r\n      const shBytes = await this.reader.read(\r\n        this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3,\r\n      );\r\n\r\n      let offset = 0;\r\n      for (let i = 0; i < this.numSplats; i++) {\r\n        for (let j = 0; j < 9; ++j) {\r\n          sh1[j] = (shBytes[offset + j] - 128) / 128;\r\n        }\r\n        offset += 9;\r\n        if (sh2) {\r\n          for (let j = 0; j < 15; ++j) {\r\n            sh2[j] = (shBytes[offset + j] - 128) / 128;\r\n          }\r\n          offset += 15;\r\n        }\r\n        if (sh3) {\r\n          for (let j = 0; j < 21; ++j) {\r\n            sh3[j] = (shBytes[offset + j] - 128) / 128;\r\n          }\r\n          offset += 21;\r\n        }\r\n        shCallback?.(i, sh1, sh2, sh3);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst SH_DEGREE_TO_VECS: Record<number, number> = { 1: 3, 2: 8, 3: 15 };\r\nconst SH_C0 = 0.28209479177387814;\r\n\r\nexport const SPZ_MAGIC = 0x5053474e; // NGSP = Niantic gaussian splat\r\nexport const SPZ_VERSION = 3;\r\nexport const FLAG_ANTIALIASED = 0x1;\r\n\r\nexport class SpzWriter {\r\n  buffer: ArrayBuffer;\r\n  view: DataView;\r\n  numSplats: number;\r\n  shDegree: number;\r\n  fractionalBits: number;\r\n  fraction: number;\r\n  flagAntiAlias: boolean;\r\n  clippedCount = 0;\r\n\r\n  constructor({\r\n    numSplats,\r\n    shDegree,\r\n    fractionalBits = 12,\r\n    flagAntiAlias = true,\r\n  }: {\r\n    numSplats: number;\r\n    shDegree: number;\r\n    fractionalBits?: number;\r\n    flagAntiAlias?: boolean;\r\n  }) {\r\n    const splatSize =\r\n      9 + // Position\r\n      1 + // Opacity\r\n      3 + // Scale\r\n      3 + // DC-rgb\r\n      4 + // Rotation\r\n      (shDegree >= 1 ? 9 : 0) +\r\n      (shDegree >= 2 ? 15 : 0) +\r\n      (shDegree >= 3 ? 21 : 0);\r\n    const bufferSize = 16 + numSplats * splatSize;\r\n    this.buffer = new ArrayBuffer(bufferSize);\r\n    this.view = new DataView(this.buffer);\r\n\r\n    this.view.setUint32(0, SPZ_MAGIC, true); // NGSP\r\n    this.view.setUint32(4, SPZ_VERSION, true);\r\n    this.view.setUint32(8, numSplats, true);\r\n    this.view.setUint8(12, shDegree);\r\n    this.view.setUint8(13, fractionalBits);\r\n    this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);\r\n    this.view.setUint8(15, 0); // Reserved\r\n\r\n    this.numSplats = numSplats;\r\n    this.shDegree = shDegree;\r\n    this.fractionalBits = fractionalBits;\r\n    this.fraction = 1 << fractionalBits;\r\n    this.flagAntiAlias = flagAntiAlias;\r\n  }\r\n\r\n  setCenter(index: number, x: number, y: number, z: number) {\r\n    // Divide by this.fraction and round to nearest integer,\r\n    // then write as 3-bytes per x then y then z.\r\n    const xRounded = Math.round(x * this.fraction);\r\n    const xInt = Math.max(-0x7fffff, Math.min(0x7fffff, xRounded));\r\n    const yRounded = Math.round(y * this.fraction);\r\n    const yInt = Math.max(-0x7fffff, Math.min(0x7fffff, yRounded));\r\n    const zRounded = Math.round(z * this.fraction);\r\n    const zInt = Math.max(-0x7fffff, Math.min(0x7fffff, zRounded));\r\n    const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;\r\n    if (clipped) {\r\n      this.clippedCount += 1;\r\n      // if (this.clippedCount < 10) {\r\n      //   // Write x y z also in hex\r\n      //   console.log(`Clipped ${index}: ${x}, ${y}, ${z} (0x${x.toString(16)}, 0x${y.toString(16)}, 0x${z.toString(16)}) -> ${xRounded}, ${yRounded}, ${zRounded} (0x${xRounded.toString(16)}, 0x${yRounded.toString(16)}, 0x${zRounded.toString(16)}) -> ${xInt}, ${yInt}, ${zInt} (0x${xInt.toString(16)}, 0x${yInt.toString(16)}, 0x${zInt.toString(16)})`);\r\n      // }\r\n    }\r\n    const i9 = index * 9;\r\n    const base = 16 + i9;\r\n    this.view.setUint8(base, xInt & 0xff);\r\n    this.view.setUint8(base + 1, (xInt >> 8) & 0xff);\r\n    this.view.setUint8(base + 2, (xInt >> 16) & 0xff);\r\n    this.view.setUint8(base + 3, yInt & 0xff);\r\n    this.view.setUint8(base + 4, (yInt >> 8) & 0xff);\r\n    this.view.setUint8(base + 5, (yInt >> 16) & 0xff);\r\n    this.view.setUint8(base + 6, zInt & 0xff);\r\n    this.view.setUint8(base + 7, (zInt >> 8) & 0xff);\r\n    this.view.setUint8(base + 8, (zInt >> 16) & 0xff);\r\n  }\r\n\r\n  setAlpha(index: number, alpha: number) {\r\n    const base = 16 + this.numSplats * 9 + index;\r\n    this.view.setUint8(\r\n      base,\r\n      Math.max(0, Math.min(255, Math.round(alpha * 255))),\r\n    );\r\n  }\r\n\r\n  static scaleRgb(r: number) {\r\n    const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\r\n    return Math.max(0, Math.min(255, Math.round(v)));\r\n  }\r\n\r\n  setRgb(index: number, r: number, g: number, b: number) {\r\n    const base = 16 + this.numSplats * 10 + index * 3;\r\n    this.view.setUint8(base, SpzWriter.scaleRgb(r));\r\n    this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));\r\n    this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));\r\n  }\r\n\r\n  setScale(index: number, scaleX: number, scaleY: number, scaleZ: number) {\r\n    const base = 16 + this.numSplats * 13 + index * 3;\r\n    this.view.setUint8(\r\n      base,\r\n      Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16))),\r\n    );\r\n    this.view.setUint8(\r\n      base + 1,\r\n      Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16))),\r\n    );\r\n    this.view.setUint8(\r\n      base + 2,\r\n      Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16))),\r\n    );\r\n  }\r\n\r\n  setQuat(\r\n    index: number,\r\n    ...q: [number, number, number, number] // x, y, z, w\r\n  ) {\r\n    const base = 16 + this.numSplats * 16 + index * 4;\r\n\r\n    const quat = normalize(q);\r\n\r\n    // Find largest component\r\n    let iLargest = 0;\r\n    for (let i = 1; i < 4; ++i) {\r\n      if (Math.abs(quat[i]) > Math.abs(quat[iLargest])) {\r\n        iLargest = i;\r\n      }\r\n    }\r\n\r\n    // Since -quat represents the same rotation as quat, transform the quaternion so the largest element\r\n    // is positive. This avoids having to send its sign bit.\r\n    const negate = quat[iLargest] < 0 ? 1 : 0;\r\n\r\n    // Do compression using sign bit and 9-bit precision per element.\r\n    let comp = iLargest;\r\n    for (let i = 0; i < 4; ++i) {\r\n      if (i !== iLargest) {\r\n        const negbit = (quat[i] < 0 ? 1 : 0) ^ negate;\r\n        const mag = Math.floor(\r\n          ((1 << 9) - 1) * (Math.abs(quat[i]) / Math.SQRT1_2) + 0.5,\r\n        );\r\n        comp = (comp << 10) | (negbit << 9) | mag;\r\n      }\r\n    }\r\n\r\n    this.view.setUint8(base, comp & 0xff);\r\n    this.view.setUint8(base + 1, (comp >> 8) & 0xff);\r\n    this.view.setUint8(base + 2, (comp >> 16) & 0xff);\r\n    this.view.setUint8(base + 3, (comp >>> 24) & 0xff);\r\n  }\r\n\r\n  static quantizeSh(sh: number, bits: number) {\r\n    const value = Math.round(sh * 128) + 128;\r\n    const bucketSize = 1 << (8 - bits);\r\n    const quantized =\r\n      Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;\r\n    return Math.max(0, Math.min(255, quantized));\r\n  }\r\n\r\n  setSh(\r\n    index: number,\r\n    sh1: Float32Array,\r\n    sh2?: Float32Array,\r\n    sh3?: Float32Array,\r\n  ) {\r\n    const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\r\n    const base1 = 16 + this.numSplats * 20 + index * shVecs * 3;\r\n    for (let j = 0; j < 9; ++j) {\r\n      this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));\r\n    }\r\n    if (sh2) {\r\n      const base2 = base1 + 9;\r\n      for (let j = 0; j < 15; ++j) {\r\n        this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));\r\n      }\r\n      if (sh3) {\r\n        const base3 = base2 + 15;\r\n        for (let j = 0; j < 21; ++j) {\r\n          this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  async finalize(): Promise<Uint8Array> {\r\n    const input = new Uint8Array(this.buffer);\r\n    const stream = new ReadableStream({\r\n      async start(controller) {\r\n        controller.enqueue(input);\r\n        controller.close();\r\n      },\r\n    });\r\n    const compressed = stream.pipeThrough(new CompressionStream(\"gzip\"));\r\n    const response = new Response(compressed);\r\n    const buffer = await response.arrayBuffer();\r\n    console.log(\r\n      \"Compressed\",\r\n      input.length,\r\n      \"bytes to\",\r\n      buffer.byteLength,\r\n      \"bytes\",\r\n    );\r\n    return new Uint8Array(buffer);\r\n  }\r\n}\r\n\r\nexport async function transcodeSpz(input: TranscodeSpzInput) {\r\n  const splats = new SplatData();\r\n  const {\r\n    inputs,\r\n    clipXyz,\r\n    maxSh,\r\n    fractionalBits = 12,\r\n    opacityThreshold,\r\n  } = input;\r\n  for (const input of inputs) {\r\n    const scale = input.transform?.scale ?? 1;\r\n    const quaternion = new THREE.Quaternion().fromArray(\r\n      input.transform?.quaternion ?? [0, 0, 0, 1],\r\n    );\r\n    const translate = new THREE.Vector3().fromArray(\r\n      input.transform?.translate ?? [0, 0, 0],\r\n    );\r\n    const clip = clipXyz\r\n      ? new THREE.Box3(\r\n          new THREE.Vector3().fromArray(clipXyz.min),\r\n          new THREE.Vector3().fromArray(clipXyz.max),\r\n        )\r\n      : undefined;\r\n\r\n    function transformPos(pos: THREE.Vector3) {\r\n      pos.multiplyScalar(scale);\r\n      pos.applyQuaternion(quaternion);\r\n      pos.add(translate);\r\n      return pos;\r\n    }\r\n\r\n    function transformScales(scales: THREE.Vector3) {\r\n      scales.multiplyScalar(scale);\r\n      return scales;\r\n    }\r\n\r\n    function transformQuaternion(quat: THREE.Quaternion) {\r\n      quat.premultiply(quaternion);\r\n      return quat;\r\n    }\r\n\r\n    function withinClip(p: THREE.Vector3) {\r\n      return !clip || clip.containsPoint(p);\r\n    }\r\n\r\n    function withinOpacity(opacity: number) {\r\n      return opacityThreshold !== undefined\r\n        ? opacity >= opacityThreshold\r\n        : true;\r\n    }\r\n\r\n    let fileType = input.fileType;\r\n    if (!fileType) {\r\n      fileType = getSplatFileType(input.fileBytes);\r\n      if (!fileType && input.pathOrUrl) {\r\n        fileType = getSplatFileTypeFromPath(input.pathOrUrl);\r\n      }\r\n    }\r\n    switch (fileType) {\r\n      case SplatFileType.PLY: {\r\n        const ply = new PlyReader({ fileBytes: input.fileBytes });\r\n        await ply.parseHeader();\r\n        let lastIndex: number | null = null;\r\n        ply.parseSplats(\r\n          (\r\n            index,\r\n            x,\r\n            y,\r\n            z,\r\n            scaleX,\r\n            scaleY,\r\n            scaleZ,\r\n            quatX,\r\n            quatY,\r\n            quatZ,\r\n            quatW,\r\n            opacity,\r\n            r,\r\n            g,\r\n            b,\r\n          ) => {\r\n            const center = transformPos(new THREE.Vector3(x, y, z));\r\n            if (withinClip(center) && withinOpacity(opacity)) {\r\n              lastIndex = splats.pushSplat();\r\n              splats.setCenter(lastIndex, center.x, center.y, center.z);\r\n              const scales = transformScales(\r\n                new THREE.Vector3(scaleX, scaleY, scaleZ),\r\n              );\r\n              splats.setScale(lastIndex, scales.x, scales.y, scales.z);\r\n              const quaternion = transformQuaternion(\r\n                new THREE.Quaternion(quatX, quatY, quatZ, quatW),\r\n              );\r\n              splats.setQuaternion(\r\n                lastIndex,\r\n                quaternion.x,\r\n                quaternion.y,\r\n                quaternion.z,\r\n                quaternion.w,\r\n              );\r\n              splats.setOpacity(lastIndex, opacity);\r\n              splats.setColor(lastIndex, r, g, b);\r\n            } else {\r\n              lastIndex = null;\r\n            }\r\n          },\r\n          (index, sh1, sh2, sh3) => {\r\n            if (sh1 && lastIndex !== null) {\r\n              splats.setSh1(lastIndex, sh1);\r\n            }\r\n            if (sh2 && lastIndex !== null) {\r\n              splats.setSh2(lastIndex, sh2);\r\n            }\r\n            if (sh3 && lastIndex !== null) {\r\n              splats.setSh3(lastIndex, sh3);\r\n            }\r\n          },\r\n        );\r\n        break;\r\n      }\r\n      case SplatFileType.SPZ: {\r\n        const spz = new SpzReader({ fileBytes: input.fileBytes });\r\n        await spz.parseHeader();\r\n        const mapping = new Int32Array(spz.numSplats);\r\n        mapping.fill(-1);\r\n        const centers = new Float32Array(spz.numSplats * 3);\r\n        const center = new THREE.Vector3();\r\n        spz.parseSplats(\r\n          (index, x, y, z) => {\r\n            const center = transformPos(new THREE.Vector3(x, y, z));\r\n            centers[index * 3] = center.x;\r\n            centers[index * 3 + 1] = center.y;\r\n            centers[index * 3 + 2] = center.z;\r\n          },\r\n          (index, alpha) => {\r\n            center.fromArray(centers, index * 3);\r\n            if (withinClip(center) && withinOpacity(alpha)) {\r\n              mapping[index] = splats.pushSplat();\r\n              splats.setCenter(mapping[index], center.x, center.y, center.z);\r\n              splats.setOpacity(mapping[index], alpha);\r\n            }\r\n          },\r\n          (index, r, g, b) => {\r\n            if (mapping[index] >= 0) {\r\n              splats.setColor(mapping[index], r, g, b);\r\n            }\r\n          },\r\n          (index, scaleX, scaleY, scaleZ) => {\r\n            if (mapping[index] >= 0) {\r\n              const scales = transformScales(\r\n                new THREE.Vector3(scaleX, scaleY, scaleZ),\r\n              );\r\n              splats.setScale(mapping[index], scales.x, scales.y, scales.z);\r\n            }\r\n          },\r\n          (index, quatX, quatY, quatZ, quatW) => {\r\n            if (mapping[index] >= 0) {\r\n              const quaternion = transformQuaternion(\r\n                new THREE.Quaternion(quatX, quatY, quatZ, quatW),\r\n              );\r\n              splats.setQuaternion(\r\n                mapping[index],\r\n                quaternion.x,\r\n                quaternion.y,\r\n                quaternion.z,\r\n                quaternion.w,\r\n              );\r\n            }\r\n          },\r\n          (index, sh1, sh2, sh3) => {\r\n            if (mapping[index] >= 0) {\r\n              splats.setSh1(mapping[index], sh1);\r\n              if (sh2) {\r\n                splats.setSh2(mapping[index], sh2);\r\n              }\r\n              if (sh3) {\r\n                splats.setSh3(mapping[index], sh3);\r\n              }\r\n            }\r\n          },\r\n        );\r\n        break;\r\n      }\r\n      case SplatFileType.SPLAT:\r\n        decodeAntiSplat(\r\n          input.fileBytes,\r\n          (numSplats) => {},\r\n          (\r\n            index,\r\n            x,\r\n            y,\r\n            z,\r\n            scaleX,\r\n            scaleY,\r\n            scaleZ,\r\n            quatX,\r\n            quatY,\r\n            quatZ,\r\n            quatW,\r\n            opacity,\r\n            r,\r\n            g,\r\n            b,\r\n          ) => {\r\n            const center = transformPos(new THREE.Vector3(x, y, z));\r\n            if (withinClip(center) && withinOpacity(opacity)) {\r\n              const index = splats.pushSplat();\r\n              splats.setCenter(index, center.x, center.y, center.z);\r\n              const scales = transformScales(\r\n                new THREE.Vector3(scaleX, scaleY, scaleZ),\r\n              );\r\n              splats.setScale(index, scales.x, scales.y, scales.z);\r\n              const quaternion = transformQuaternion(\r\n                new THREE.Quaternion(quatX, quatY, quatZ, quatW),\r\n              );\r\n              splats.setQuaternion(\r\n                index,\r\n                quaternion.x,\r\n                quaternion.y,\r\n                quaternion.z,\r\n                quaternion.w,\r\n              );\r\n              splats.setOpacity(index, opacity);\r\n              splats.setColor(index, r, g, b);\r\n            }\r\n          },\r\n        );\r\n        break;\r\n      case SplatFileType.KSPLAT: {\r\n        let lastIndex: number | null = null;\r\n        decodeKsplat(\r\n          input.fileBytes,\r\n          (numSplats) => {},\r\n          (\r\n            index,\r\n            x,\r\n            y,\r\n            z,\r\n            scaleX,\r\n            scaleY,\r\n            scaleZ,\r\n            quatX,\r\n            quatY,\r\n            quatZ,\r\n            quatW,\r\n            opacity,\r\n            r,\r\n            g,\r\n            b,\r\n          ) => {\r\n            const center = transformPos(new THREE.Vector3(x, y, z));\r\n            if (withinClip(center) && withinOpacity(opacity)) {\r\n              lastIndex = splats.pushSplat();\r\n              splats.setCenter(lastIndex, center.x, center.y, center.z);\r\n              const scales = transformScales(\r\n                new THREE.Vector3(scaleX, scaleY, scaleZ),\r\n              );\r\n              splats.setScale(lastIndex, scales.x, scales.y, scales.z);\r\n              const quaternion = transformQuaternion(\r\n                new THREE.Quaternion(quatX, quatY, quatZ, quatW),\r\n              );\r\n              splats.setQuaternion(\r\n                lastIndex,\r\n                quaternion.x,\r\n                quaternion.y,\r\n                quaternion.z,\r\n                quaternion.w,\r\n              );\r\n              splats.setOpacity(lastIndex, opacity);\r\n              splats.setColor(lastIndex, r, g, b);\r\n            } else {\r\n              lastIndex = null;\r\n            }\r\n          },\r\n          (index, sh1, sh2, sh3) => {\r\n            if (lastIndex !== null) {\r\n              splats.setSh1(lastIndex, sh1);\r\n              if (sh2) {\r\n                splats.setSh2(lastIndex, sh2);\r\n              }\r\n              if (sh3) {\r\n                splats.setSh3(lastIndex, sh3);\r\n              }\r\n            }\r\n          },\r\n        );\r\n        break;\r\n      }\r\n      default:\r\n        throw new Error(`transcodeSpz not implemented for ${fileType}`);\r\n    }\r\n  }\r\n\r\n  const shDegree = Math.min(\r\n    maxSh ?? 3,\r\n    splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0,\r\n  );\r\n  const spz = new SpzWriter({\r\n    numSplats: splats.numSplats,\r\n    shDegree,\r\n    fractionalBits,\r\n    flagAntiAlias: true,\r\n  });\r\n\r\n  for (let i = 0; i < splats.numSplats; ++i) {\r\n    const i3 = i * 3;\r\n    const i4 = i * 4;\r\n    spz.setCenter(\r\n      i,\r\n      splats.centers[i3],\r\n      splats.centers[i3 + 1],\r\n      splats.centers[i3 + 2],\r\n    );\r\n    spz.setScale(\r\n      i,\r\n      splats.scales[i3],\r\n      splats.scales[i3 + 1],\r\n      splats.scales[i3 + 2],\r\n    );\r\n    spz.setQuat(\r\n      i,\r\n      splats.quaternions[i4],\r\n      splats.quaternions[i4 + 1],\r\n      splats.quaternions[i4 + 2],\r\n      splats.quaternions[i4 + 3],\r\n    );\r\n    spz.setAlpha(i, splats.opacities[i]);\r\n    spz.setRgb(\r\n      i,\r\n      splats.colors[i3],\r\n      splats.colors[i3 + 1],\r\n      splats.colors[i3 + 2],\r\n    );\r\n    if (splats.sh1 && shDegree >= 1) {\r\n      spz.setSh(\r\n        i,\r\n        splats.sh1.slice(i * 9, (i + 1) * 9),\r\n        shDegree >= 2 && splats.sh2\r\n          ? splats.sh2.slice(i * 15, (i + 1) * 15)\r\n          : undefined,\r\n        shDegree >= 3 && splats.sh3\r\n          ? splats.sh3.slice(i * 21, (i + 1) * 21)\r\n          : undefined,\r\n      );\r\n    }\r\n  }\r\n\r\n  const spzBytes = await spz.finalize();\r\n  return { fileBytes: spzBytes, clippedCount: spz.clippedCount };\r\n}\r\n","import * as THREE from \"three\";\r\n\r\n// SplatSkinning is an experimental class that implements dual-quaternion\r\n// skeletal animation for Gsplats. A skeletal animation system consists\r\n// of a set of bones, each with a \"rest\" pose that consists of a position\r\n// and orientation, and a weighting of up to 4 bones for each Gsplat.\r\n// By moving and rotating the bones you can animate all the Gsplats like\r\n// your would for a normal 3D animated mesh.\r\n// Note that the dual-quaternion formulation assumes that mass/volume\r\n// is conserved through these transformations, which helps avoid common\r\n// issues with linear blend skinning such as joint collapse or bulging.\r\n// However, it is not as good a fit for animations that involve explicit\r\n// deformations, such as cartoon animations.\r\n\r\nimport type { SplatMesh } from \"./SplatMesh\";\r\nimport {\r\n  Dyno,\r\n  DynoUniform,\r\n  type DynoVal,\r\n  Gsplat,\r\n  unindent,\r\n  unindentLines,\r\n} from \"./dyno\";\r\nimport { getTextureSize } from \"./utils\";\r\n\r\nexport type SplatSkinningOptions = {\r\n  // Specifies the SplatMesh that will be animated.\r\n  mesh: SplatMesh;\r\n  // Overrides the number of Gsplats in the mesh that will be animated.\r\n  // (default: mesh.numSplats)\r\n  numSplats?: number;\r\n  // Set the number of bones used to animate the SplatMesh, with a maximum\r\n  // of 256 (in order to compactly encode the bone index). (default: 256)\r\n  numBones?: number;\r\n};\r\n\r\nexport class SplatSkinning {\r\n  mesh: SplatMesh;\r\n  numSplats: number;\r\n\r\n  // Store the skinning weights for each Gsplat, composed of a 4-vector\r\n  // of bone indices and weight\r\n  skinData: Uint16Array;\r\n  skinTexture: THREE.DataArrayTexture;\r\n\r\n  numBones: number;\r\n  boneData: Float32Array;\r\n  boneTexture: THREE.DataTexture;\r\n\r\n  uniform: DynoUniform<typeof GsplatSkinning, \"skinning\">;\r\n\r\n  constructor(options: SplatSkinningOptions) {\r\n    this.mesh = options.mesh;\r\n    this.numSplats = options.numSplats ?? this.mesh.numSplats;\r\n\r\n    const { width, height, depth, maxSplats } = getTextureSize(this.numSplats);\r\n    this.skinData = new Uint16Array(maxSplats * 4);\r\n    this.skinTexture = new THREE.DataArrayTexture(\r\n      this.skinData,\r\n      width,\r\n      height,\r\n      depth,\r\n    );\r\n    this.skinTexture.format = THREE.RGBAIntegerFormat;\r\n    this.skinTexture.type = THREE.UnsignedShortType;\r\n    this.skinTexture.internalFormat = \"RGBA16UI\";\r\n    this.skinTexture.needsUpdate = true;\r\n\r\n    this.numBones = options.numBones ?? 256;\r\n    this.boneData = new Float32Array(this.numBones * 16);\r\n    this.boneTexture = new THREE.DataTexture(\r\n      this.boneData,\r\n      4,\r\n      this.numBones,\r\n      THREE.RGBAFormat,\r\n      THREE.FloatType,\r\n    );\r\n    this.boneTexture.internalFormat = \"RGBA32F\";\r\n    this.boneTexture.needsUpdate = true;\r\n\r\n    this.uniform = new DynoUniform({\r\n      key: \"skinning\",\r\n      type: GsplatSkinning,\r\n      globals: () => [defineGsplatSkinning],\r\n      value: {\r\n        numSplats: this.numSplats,\r\n        numBones: this.numBones,\r\n        skinTexture: this.skinTexture,\r\n        boneTexture: this.boneTexture,\r\n      },\r\n    });\r\n  }\r\n\r\n  // Apply the skeletal animation to a Gsplat in a dyno program.\r\n  modify(gsplat: DynoVal<typeof Gsplat>): DynoVal<typeof Gsplat> {\r\n    return applyGsplatSkinning(gsplat, this.uniform);\r\n  }\r\n\r\n  // Set the \"rest\" pose for a bone with position and quaternion orientation.\r\n  setRestQuatPos(\r\n    boneIndex: number,\r\n    quat: THREE.Quaternion,\r\n    pos: THREE.Vector3,\r\n  ) {\r\n    const i16 = boneIndex * 16;\r\n    this.boneData[i16 + 0] = quat.x;\r\n    this.boneData[i16 + 1] = quat.y;\r\n    this.boneData[i16 + 2] = quat.z;\r\n    this.boneData[i16 + 3] = quat.w;\r\n    this.boneData[i16 + 4] = pos.x;\r\n    this.boneData[i16 + 5] = pos.y;\r\n    this.boneData[i16 + 6] = pos.z;\r\n    this.boneData[i16 + 7] = 0;\r\n    this.boneData[i16 + 8] = 0;\r\n    this.boneData[i16 + 9] = 0;\r\n    this.boneData[i16 + 10] = 0;\r\n    this.boneData[i16 + 11] = 1;\r\n    this.boneData[i16 + 12] = 0;\r\n    this.boneData[i16 + 13] = 0;\r\n    this.boneData[i16 + 14] = 0;\r\n    this.boneData[i16 + 15] = 0;\r\n  }\r\n\r\n  // Set the \"current\" position and orientation of a bone.\r\n  setBoneQuatPos(\r\n    boneIndex: number,\r\n    quat: THREE.Quaternion,\r\n    pos: THREE.Vector3,\r\n  ) {\r\n    const i16 = boneIndex * 16;\r\n    const origQuat = new THREE.Quaternion(\r\n      this.boneData[i16 + 0],\r\n      this.boneData[i16 + 1],\r\n      this.boneData[i16 + 2],\r\n      this.boneData[i16 + 3],\r\n    );\r\n    const origPos = new THREE.Vector3(\r\n      this.boneData[i16 + 4],\r\n      this.boneData[i16 + 5],\r\n      this.boneData[i16 + 6],\r\n    );\r\n\r\n    const relQuat = origQuat.clone().invert();\r\n    const relPos = pos.clone().sub(origPos);\r\n    relPos.applyQuaternion(relQuat);\r\n    relQuat.multiply(quat);\r\n    const dual = new THREE.Quaternion(\r\n      relPos.x,\r\n      relPos.y,\r\n      relPos.z,\r\n      0.0,\r\n    ).multiply(origQuat);\r\n\r\n    this.boneData[i16 + 8] = relQuat.x;\r\n    this.boneData[i16 + 9] = relQuat.y;\r\n    this.boneData[i16 + 10] = relQuat.z;\r\n    this.boneData[i16 + 11] = relQuat.w;\r\n    this.boneData[i16 + 12] = 0.5 * dual.x;\r\n    this.boneData[i16 + 13] = 0.5 * dual.y;\r\n    this.boneData[i16 + 14] = 0.5 * dual.z;\r\n    this.boneData[i16 + 15] = 0.5 * dual.w;\r\n  }\r\n\r\n  // Set up to 4 bone indices and weights for a Gsplat. For fewer than 4 bones,\r\n  // you can set the remaining weights to 0 (and index=0).\r\n  setSplatBones(\r\n    splatIndex: number,\r\n    boneIndices: THREE.Vector4,\r\n    weights: THREE.Vector4,\r\n  ) {\r\n    const i4 = splatIndex * 4;\r\n    this.skinData[i4 + 0] =\r\n      Math.min(255, Math.max(0, Math.round(weights.x * 255.0))) +\r\n      (boneIndices.x << 8);\r\n    this.skinData[i4 + 1] =\r\n      Math.min(255, Math.max(0, Math.round(weights.y * 255.0))) +\r\n      (boneIndices.y << 8);\r\n    this.skinData[i4 + 2] =\r\n      Math.min(255, Math.max(0, Math.round(weights.z * 255.0))) +\r\n      (boneIndices.z << 8);\r\n    this.skinData[i4 + 3] =\r\n      Math.min(255, Math.max(0, Math.round(weights.w * 255.0))) +\r\n      (boneIndices.w << 8);\r\n  }\r\n\r\n  // Call this to indicate that the bones have changed and the Gsplats need to be\r\n  // re-generated with updated skinning.\r\n  updateBones() {\r\n    this.boneTexture.needsUpdate = true;\r\n    this.mesh.needsUpdate = true;\r\n  }\r\n}\r\n\r\n// dyno program definitions for SplatSkinning\r\n\r\nexport const GsplatSkinning = { type: \"GsplatSkinning\" } as {\r\n  type: \"GsplatSkinning\";\r\n};\r\n\r\nexport const defineGsplatSkinning = unindent(`\r\n  struct GsplatSkinning {\r\n    int numSplats;\r\n    int numBones;\r\n    usampler2DArray skinTexture;\r\n    sampler2D boneTexture;\r\n  };\r\n`);\r\n\r\nexport const defineApplyGsplatSkinning = unindent(`\r\n  void applyGsplatSkinning(\r\n    int numSplats, int numBones,\r\n    usampler2DArray skinTexture, sampler2D boneTexture,\r\n    int splatIndex, inout vec3 center, inout vec4 quaternion\r\n  ) {\r\n    if ((splatIndex < 0) || (splatIndex >= numSplats)) {\r\n      return;\r\n    }\r\n\r\n    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);\r\n\r\n    float weights[4];\r\n    weights[0] = float(skinData.x & 0xffu) / 255.0;\r\n    weights[1] = float(skinData.y & 0xffu) / 255.0;\r\n    weights[2] = float(skinData.z & 0xffu) / 255.0;\r\n    weights[3] = float(skinData.w & 0xffu) / 255.0;\r\n\r\n    uint boneIndices[4];\r\n    boneIndices[0] = (skinData.x >> 8u) & 0xffu;\r\n    boneIndices[1] = (skinData.y >> 8u) & 0xffu;\r\n    boneIndices[2] = (skinData.z >> 8u) & 0xffu;\r\n    boneIndices[3] = (skinData.w >> 8u) & 0xffu;\r\n\r\n    vec4 quat = vec4(0.0);\r\n    vec4 dual = vec4(0.0);\r\n    for (int i = 0; i < 4; i++) {\r\n      if (weights[i] > 0.0) {\r\n        int boneIndex = int(boneIndices[i]);\r\n        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);\r\n        vec4 boneDual = vec4(0.0);\r\n        if (boneIndex < numBones) {\r\n          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);\r\n          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);\r\n        }\r\n\r\n        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {\r\n          // Flip sign if next blend is pointing in the opposite direction\r\n          boneQuat = -boneQuat;\r\n          boneDual = -boneDual;\r\n        }\r\n        quat += weights[i] * boneQuat;\r\n        dual += weights[i] * boneDual;\r\n      }\r\n    }\r\n\r\n    // Normalize dual quaternion\r\n    float norm = length(quat);\r\n    quat /= norm;\r\n    dual /= norm;\r\n    vec3 translate = vec3(\r\n      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),\r\n      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),\r\n      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)\r\n    );\r\n\r\n    center = quatVec(quat, center) + translate;\r\n    quaternion = quatQuat(quat, quaternion);\r\n  }\r\n`);\r\n\r\nfunction applyGsplatSkinning(\r\n  gsplat: DynoVal<typeof Gsplat>,\r\n  skinning: DynoVal<typeof GsplatSkinning>,\r\n): DynoVal<typeof Gsplat> {\r\n  const dyno = new Dyno<\r\n    { gsplat: typeof Gsplat; skinning: typeof GsplatSkinning },\r\n    { gsplat: typeof Gsplat }\r\n  >({\r\n    inTypes: { gsplat: Gsplat, skinning: GsplatSkinning },\r\n    outTypes: { gsplat: Gsplat },\r\n    globals: () => [defineGsplatSkinning, defineApplyGsplatSkinning],\r\n    inputs: { gsplat, skinning },\r\n    statements: ({ inputs, outputs }) => {\r\n      const { skinning } = inputs;\r\n      const { gsplat } = outputs;\r\n      return unindentLines(`\r\n        ${gsplat} = ${inputs.gsplat};\r\n        if (isGsplatActive(${gsplat}.flags)) {\r\n          applyGsplatSkinning(\r\n            ${skinning}.numSplats, ${skinning}.numBones,\r\n            ${skinning}.skinTexture, ${skinning}.boneTexture,\r\n            ${gsplat}.index, ${gsplat}.center, ${gsplat}.quaternion\r\n          );\r\n        }\r\n      `);\r\n    },\r\n  });\r\n  return dyno.outputs.gsplat;\r\n}\r\n","import * as THREE from \"three\";\r\nimport { PackedSplats } from \"./PackedSplats\";\r\nimport { SplatMesh } from \"./SplatMesh\";\r\n\r\nexport function constructGrid({\r\n  // PackedSplats object to add splats to\r\n  splats,\r\n  // min and max box extents of the grid\r\n  extents,\r\n  // step size along each grid axis\r\n  stepSize = 1,\r\n  // spherical radius of each Gsplat\r\n  pointRadius = 0.01,\r\n  // relative size of the \"shadow copy\" of each Gsplat placed behind it\r\n  pointShadowScale = 2.0,\r\n  // Gsplat opacity\r\n  opacity = 1.0,\r\n  // Gsplat color (THREE.Color) or function to set color for position:\r\n  // ((THREE.Color, THREE.Vector3) => void) (default: RGB-modulated grid)\r\n  color,\r\n}: {\r\n  splats: PackedSplats;\r\n  extents: THREE.Box3;\r\n  stepSize?: number;\r\n  pointRadius?: number;\r\n  pointShadowScale?: number;\r\n  opacity?: number;\r\n  color?: THREE.Color | ((color: THREE.Color, point: THREE.Vector3) => void);\r\n}) {\r\n  const EPSILON = 1.0e-6;\r\n  const center = new THREE.Vector3();\r\n  const scales = new THREE.Vector3();\r\n  const quaternion = new THREE.Quaternion(0, 0, 0, 1);\r\n  if (color == null) {\r\n    color = (color, point) =>\r\n      color.set(\r\n        0.55 + 0.45 * Math.cos(point.x * 1),\r\n        0.55 + 0.45 * Math.cos(point.y * 1),\r\n        0.55 + 0.45 * Math.cos(point.z * 1),\r\n      );\r\n  }\r\n  const pointColor = new THREE.Color();\r\n  for (let z = extents.min.z; z < extents.max.z + EPSILON; z += stepSize) {\r\n    for (let y = extents.min.y; y < extents.max.y + EPSILON; y += stepSize) {\r\n      for (let x = extents.min.x; x < extents.max.x + EPSILON; x += stepSize) {\r\n        center.set(x, y, z);\r\n        for (let layer = 0; layer < 2; ++layer) {\r\n          scales.setScalar(pointRadius * (layer ? 1 : pointShadowScale));\r\n          if (!layer) {\r\n            pointColor.setScalar(0.0);\r\n          } else if (typeof color === \"function\") {\r\n            color(pointColor, center);\r\n          } else {\r\n            pointColor.copy(color);\r\n          }\r\n          splats.pushSplat(center, scales, quaternion, opacity, pointColor);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function constructAxes({\r\n  // PackedSplats object to add splats to\r\n  splats,\r\n  // scale (Gsplat scale along axis)\r\n  scale = 0.25,\r\n  // radius of the axes (Gsplat scale orthogonal to axis)\r\n  axisRadius = 0.0075,\r\n  // relative size of the \"shadow copy\" of each Gsplat placed behind it\r\n  axisShadowScale = 2.0,\r\n  // origins of the axes (default single axis at origin)\r\n  origins = [new THREE.Vector3()],\r\n}: {\r\n  splats: PackedSplats;\r\n  scale?: number;\r\n  axisRadius?: number;\r\n  axisShadowScale?: number;\r\n  origins?: THREE.Vector3[];\r\n}) {\r\n  const center = new THREE.Vector3();\r\n  const scales = new THREE.Vector3();\r\n  const quaternion = new THREE.Quaternion(0, 0, 0, 1);\r\n  const color = new THREE.Color();\r\n  const opacity = 1.0;\r\n  for (const origin of origins) {\r\n    for (let axis = 0; axis < 3; ++axis) {\r\n      center.set(\r\n        origin.x + (axis === 0 ? scale : 0),\r\n        origin.y + (axis === 1 ? scale : 0),\r\n        origin.z + (axis === 2 ? scale : 0),\r\n      );\r\n      for (let layer = 0; layer < 2; ++layer) {\r\n        scales.set(\r\n          (axis === 0 ? scale : axisRadius) * (layer ? 1 : axisShadowScale),\r\n          (axis === 1 ? scale : axisRadius) * (layer ? 1 : axisShadowScale),\r\n          (axis === 2 ? scale : axisRadius) * (layer ? 1 : axisShadowScale),\r\n        );\r\n        color.setRGB(\r\n          layer === 0 ? 0.0 : axis === 0 ? 1.0 : 0.0,\r\n          layer === 0 ? 0.0 : axis === 1 ? 1.0 : 0.0,\r\n          layer === 0 ? 0.0 : axis === 2 ? 1.0 : 0.0,\r\n        );\r\n        splats.pushSplat(center, scales, quaternion, opacity, color);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function constructSpherePoints({\r\n  // PackedSplats object to add splats to\r\n  splats,\r\n  // center of the sphere (default: origin)\r\n  origin = new THREE.Vector3(),\r\n  // radius of the sphere\r\n  radius = 1.0,\r\n  // maximum depth of recursion for subdividing the sphere\r\n  // Warning: Gsplat count grows exponentially with depth\r\n  maxDepth = 3,\r\n  // filter function to apply to each point, for example to select\r\n  // points in a certain direction or other function ((THREE.Vector3) => boolean)\r\n  // (default: null)\r\n  filter = null,\r\n  // radius of each oriented Gsplat\r\n  pointRadius = 0.02,\r\n  // flatness of each oriented Gsplat\r\n  pointThickness = 0.001,\r\n  // color of each Gsplat (THREE.Color) or function to set color for point:\r\n  // ((THREE.Color, THREE.Vector3) => void) (default: white)\r\n  color = new THREE.Color(1, 1, 1),\r\n}: {\r\n  splats: PackedSplats;\r\n  origin?: THREE.Vector3;\r\n  radius?: number;\r\n  maxDepth?: number;\r\n  filter?: ((point: THREE.Vector3) => boolean) | null;\r\n  pointRadius?: number;\r\n  pointThickness?: number;\r\n  color?: THREE.Color | ((color: THREE.Color, point: THREE.Vector3) => void);\r\n}) {\r\n  const pointsHash: { [key: string]: THREE.Vector3 } = {};\r\n\r\n  function addPoint(p: THREE.Vector3) {\r\n    if (filter && !filter(p)) {\r\n      return;\r\n    }\r\n    const key = `${p.x},${p.y},${p.z}`;\r\n    if (!pointsHash[key]) {\r\n      pointsHash[key] = p;\r\n    }\r\n  }\r\n\r\n  function recurse(\r\n    depth: number,\r\n    p0: THREE.Vector3,\r\n    p1: THREE.Vector3,\r\n    p2: THREE.Vector3,\r\n  ) {\r\n    addPoint(p0);\r\n    addPoint(p1);\r\n    addPoint(p2);\r\n    if (depth >= maxDepth) {\r\n      return;\r\n    }\r\n    const p01 = new THREE.Vector3().addVectors(p0, p1).normalize();\r\n    const p12 = new THREE.Vector3().addVectors(p1, p2).normalize();\r\n    const p20 = new THREE.Vector3().addVectors(p2, p0).normalize();\r\n    recurse(depth + 1, p0, p01, p20);\r\n    recurse(depth + 1, p01, p1, p12);\r\n    recurse(depth + 1, p20, p12, p2);\r\n    recurse(depth + 1, p01, p12, p20);\r\n  }\r\n\r\n  for (const x of [-1, 1]) {\r\n    for (const y of [-1, 1]) {\r\n      for (const z of [-1, 1]) {\r\n        const p0 = new THREE.Vector3(x, 0, 0);\r\n        const p1 = new THREE.Vector3(0, y, 0);\r\n        const p2 = new THREE.Vector3(0, 0, z);\r\n        recurse(0, p0, p1, p2);\r\n      }\r\n    }\r\n  }\r\n\r\n  const points = Object.values(pointsHash);\r\n  const scales = new THREE.Vector3(pointRadius, pointRadius, pointThickness);\r\n  const quaternion = new THREE.Quaternion();\r\n  const pointColor = typeof color === \"function\" ? new THREE.Color() : color;\r\n  for (const point of points) {\r\n    quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), point);\r\n    if (typeof color === \"function\") {\r\n      color(pointColor, point);\r\n    }\r\n    point.multiplyScalar(radius);\r\n    point.add(origin);\r\n    splats.pushSplat(point, scales, quaternion, 1.0, pointColor);\r\n  }\r\n}\r\n\r\nexport function textSplats({\r\n  // text string to display\r\n  text,\r\n  // browser font to render text with (default: \"Arial\")\r\n  font,\r\n  // font size in pixels/Gsplats (default: 32)\r\n  fontSize,\r\n  // SplatMesh.recolor tint assuming white Gsplats (default: white)\r\n  color,\r\n  // Individual Gsplat color (default: white)\r\n  rgb,\r\n  // Gsplat radius (default: 0.8 covers 1-unit spacing well)\r\n  dotRadius,\r\n  // text alignment: \"left\", \"center\", \"right\", \"start\", \"end\" (default: \"start\")\r\n  textAlign,\r\n  // line spacing multiplier, lines delimited by \"\\n\" (default: 1.0)\r\n  lineHeight,\r\n  // Coordinate scale in object-space (default: 1.0)\r\n  objectScale,\r\n}: {\r\n  text: string;\r\n  font?: string;\r\n  fontSize?: number;\r\n  color?: THREE.Color;\r\n  rgb?: THREE.Color;\r\n  dotRadius?: number;\r\n  textAlign?: \"left\" | \"center\" | \"right\" | \"start\" | \"end\";\r\n  lineHeight?: number;\r\n  objectScale?: number;\r\n}) {\r\n  font = font ?? \"Arial\";\r\n  fontSize = fontSize ?? 32;\r\n  color = color ?? new THREE.Color(1, 1, 1);\r\n  dotRadius = dotRadius ?? 0.8;\r\n  textAlign = textAlign ?? \"start\";\r\n  lineHeight = lineHeight ?? 1;\r\n  objectScale = objectScale ?? 1;\r\n  const lines = text.split(\"\\n\");\r\n\r\n  const canvas = document.createElement(\"canvas\");\r\n  const ctx = canvas.getContext(\"2d\");\r\n  if (!ctx) {\r\n    throw new Error(\"Failed to create canvas context\");\r\n  }\r\n\r\n  ctx.font = `${fontSize}px ${font}`;\r\n  ctx.textAlign = textAlign;\r\n  const metrics = ctx.measureText(\"\");\r\n  const fontHeight =\r\n    metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;\r\n\r\n  let minLeft = Number.POSITIVE_INFINITY;\r\n  let maxRight = Number.NEGATIVE_INFINITY;\r\n  let minTop = Number.POSITIVE_INFINITY;\r\n  let maxBottom = Number.NEGATIVE_INFINITY;\r\n  for (let line = 0; line < lines.length; ++line) {\r\n    const metrics = ctx.measureText(lines[line]);\r\n    const y = fontHeight * lineHeight * line;\r\n    minLeft = Math.min(minLeft, -metrics.actualBoundingBoxLeft);\r\n    maxRight = Math.max(maxRight, metrics.actualBoundingBoxRight);\r\n    minTop = Math.min(minTop, y - metrics.actualBoundingBoxAscent);\r\n    maxBottom = Math.max(maxBottom, y + metrics.actualBoundingBoxDescent);\r\n  }\r\n  const originLeft = Math.floor(minLeft);\r\n  const originTop = Math.floor(minTop);\r\n  const width = Math.ceil(maxRight) - originLeft;\r\n  const height = Math.ceil(maxBottom) - originTop;\r\n  canvas.width = width;\r\n  canvas.height = height;\r\n\r\n  ctx.font = `${fontSize}px ${font}`;\r\n  ctx.textAlign = textAlign;\r\n  ctx.textBaseline = \"alphabetic\";\r\n  ctx.fillStyle = \"#FFFFFF\";\r\n  for (let i = 0; i < lines.length; ++i) {\r\n    const y = fontHeight * lineHeight * i - originTop;\r\n    ctx.fillText(lines[i], -originLeft, y);\r\n  }\r\n\r\n  const imageData = ctx.getImageData(0, 0, width, height);\r\n  const rgba = new Uint8Array(imageData.data.buffer);\r\n  const splats = new PackedSplats();\r\n  const center = new THREE.Vector3();\r\n  const scales = new THREE.Vector3().setScalar(dotRadius * objectScale);\r\n  const quaternion = new THREE.Quaternion(0, 0, 0, 1);\r\n  rgb = rgb ?? new THREE.Color(1, 1, 1);\r\n\r\n  let offset = 0;\r\n  for (let y = 0; y < height; ++y) {\r\n    for (let x = 0; x < width; ++x) {\r\n      const a = rgba[offset + 3];\r\n      if (a > 0) {\r\n        const opacity = a / 255;\r\n        center.set(x - 0.5 * (width - 1), 0.5 * (height - 1) - y, 0);\r\n        center.multiplyScalar(objectScale);\r\n        splats.pushSplat(center, scales, quaternion, opacity, rgb);\r\n      }\r\n      offset += 4;\r\n    }\r\n  }\r\n\r\n  const mesh = new SplatMesh({ packedSplats: splats });\r\n  mesh.recolor = color;\r\n  return mesh;\r\n}\r\n\r\nexport function imageSplats({\r\n  // URL of the image to convert to splats (example: `url: \"./image.png\"`)\r\n  url,\r\n  // Radius of each Gsplat, default covers 1-unit spacing well (default: 0.8)\r\n  dotRadius,\r\n  // Subsampling factor for the image. Higher values reduce resolution,\r\n  // for example 2 will halve the width and height by averaging (default: 1)\r\n  subXY,\r\n  // Optional callback function to modify each Gsplat before it's added.\r\n  // Return null to skip adding the Gsplat, or a number to set the opacity\r\n  // and add the Gsplat with parameter values in the objects center, rgba etc. were\r\n  // passed into the forEachSplat callback. Ending the callback in `return opacity;`\r\n  // will retain the original opacity.\r\n  // ((width: number, height: number, index: number, center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number, color: THREE.Color) => number | null)\r\n  forEachSplat,\r\n}: {\r\n  url: string;\r\n  dotRadius?: number;\r\n  subXY?: number;\r\n  forEachSplat?: (\r\n    width: number,\r\n    height: number,\r\n    index: number,\r\n    center: THREE.Vector3,\r\n    scales: THREE.Vector3,\r\n    quaternion: THREE.Quaternion,\r\n    opacity: number,\r\n    color: THREE.Color,\r\n  ) => number | null;\r\n}): SplatMesh {\r\n  dotRadius = dotRadius ?? 0.8;\r\n  subXY = Math.max(1, Math.floor(subXY ?? 1));\r\n\r\n  return new SplatMesh({\r\n    constructSplats: async (splats) => {\r\n      return new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        img.crossOrigin = \"anonymous\";\r\n        img.onerror = reject;\r\n        img.onload = () => {\r\n          const { width, height } = img;\r\n          const canvas = document.createElement(\"canvas\");\r\n          canvas.width = width;\r\n          canvas.height = height;\r\n          const ctx = canvas.getContext(\"2d\");\r\n          if (!ctx) {\r\n            reject(new Error(\"Failed to create canvas context\"));\r\n            return;\r\n          }\r\n          ctx.imageSmoothingEnabled = true;\r\n          ctx.imageSmoothingQuality = \"high\";\r\n          const destWidth = Math.round(width / subXY);\r\n          const destHeight = Math.round(height / subXY);\r\n          ctx.drawImage(img, 0, 0, destWidth, destHeight);\r\n          try {\r\n            const imageData = ctx.getImageData(0, 0, destWidth, destHeight);\r\n            const rgba = new Uint8Array(imageData.data.buffer);\r\n\r\n            const center = new THREE.Vector3();\r\n            const scales = new THREE.Vector3().setScalar(dotRadius);\r\n            const quaternion = new THREE.Quaternion(0, 0, 0, 1);\r\n            const rgb = new THREE.Color();\r\n\r\n            let index = 0;\r\n            for (let y = 0; y < destHeight; ++y) {\r\n              for (let x = 0; x < destWidth; ++x) {\r\n                const offset = index * 4;\r\n                const a = rgba[offset + 3];\r\n                if (a > 0) {\r\n                  let opacity = a / 255;\r\n                  rgb.set(\r\n                    rgba[offset + 0] / 255,\r\n                    rgba[offset + 1] / 255,\r\n                    rgba[offset + 2] / 255,\r\n                  );\r\n                  center.set(\r\n                    x - 0.5 * (destWidth - 1),\r\n                    0.5 * (destHeight - 1) - y,\r\n                    0,\r\n                  );\r\n                  scales.setScalar(dotRadius);\r\n                  quaternion.set(0, 0, 0, 1);\r\n                  let push = true;\r\n                  if (forEachSplat) {\r\n                    const maybeOpacity = forEachSplat(\r\n                      destWidth,\r\n                      destHeight,\r\n                      index,\r\n                      center,\r\n                      scales,\r\n                      quaternion,\r\n                      opacity,\r\n                      rgb,\r\n                    );\r\n                    opacity = maybeOpacity ?? opacity;\r\n                    push = maybeOpacity !== null;\r\n                  }\r\n                  if (push) {\r\n                    splats.pushSplat(center, scales, quaternion, opacity, rgb);\r\n                  }\r\n                }\r\n                index += 1;\r\n              }\r\n            }\r\n            resolve();\r\n          } catch (error) {\r\n            reject(error);\r\n          }\r\n        };\r\n        img.src = url;\r\n      });\r\n    },\r\n  });\r\n}\r\n","import * as THREE from \"three\";\r\nimport { SplatGenerator, SplatTransformer } from \"../SplatGenerator\";\r\nimport {\r\n  type DynoVal,\r\n  Gsplat,\r\n  add,\r\n  combine,\r\n  combineGsplat,\r\n  defineGsplat,\r\n  div,\r\n  dynoBlock,\r\n  dynoConst,\r\n  dynoFloat,\r\n  dynoLiteral,\r\n  floatBitsToInt,\r\n  hashVec3,\r\n  imod,\r\n  mul,\r\n  split,\r\n  sub,\r\n  vec3,\r\n} from \"../dyno\";\r\n\r\nexport function staticBox({\r\n  box,\r\n  cells,\r\n  dotScale,\r\n  color,\r\n  opacity,\r\n}: {\r\n  box: THREE.Box3;\r\n  cells: THREE.Vector3;\r\n  dotScale: number;\r\n  color?: THREE.Color;\r\n  opacity?: number;\r\n}) {\r\n  cells.x = Math.max(1, Math.round(cells.x));\r\n  cells.y = Math.max(1, Math.round(cells.y));\r\n  cells.z = Math.max(1, Math.round(cells.z));\r\n  opacity = opacity ?? 1;\r\n  const numSplats = cells.x * cells.y * cells.z;\r\n  const dynoX = dynoConst(\"int\", cells.x);\r\n  const dynoY = dynoConst(\"int\", cells.y);\r\n  const dynoZ = dynoConst(\"int\", cells.z);\r\n\r\n  const dynoTime = dynoFloat(0);\r\n  const generator = new SplatGenerator({\r\n    numSplats,\r\n    generator: dynoBlock(\r\n      { index: \"int\" },\r\n      { gsplat: Gsplat },\r\n      ({ index }) => {\r\n        if (!index) {\r\n          throw new Error(\"index is undefined\");\r\n        }\r\n        const cellX = imod(index, dynoX);\r\n        const index2 = div(index, dynoX);\r\n        const cellY = imod(index2, dynoY);\r\n        const cellZ = div(index2, dynoY);\r\n        const cell = combine({\r\n          vectorType: \"ivec3\",\r\n          x: cellX,\r\n          y: cellY,\r\n          z: cellZ,\r\n        });\r\n\r\n        const intTime = floatBitsToInt(dynoTime);\r\n        const inputs = combine({ vectorType: \"ivec2\", x: index, y: intTime });\r\n        const random = hashVec3(inputs);\r\n        const min = dynoConst(\"vec3\", box.min);\r\n        const max = dynoConst(\"vec3\", box.max);\r\n        const size = sub(max, min);\r\n        const coord = div(add(vec3(cell), random), dynoConst(\"vec3\", cells));\r\n        let r: DynoVal<\"float\">;\r\n        let g: DynoVal<\"float\">;\r\n        let b: DynoVal<\"float\">;\r\n        if (color) {\r\n          r = dynoConst(\"float\", color.r);\r\n          g = dynoConst(\"float\", color.g);\r\n          b = dynoConst(\"float\", color.b);\r\n        } else {\r\n          ({ r, g, b } = split(coord).outputs);\r\n        }\r\n        const rgba = combine({\r\n          vectorType: \"vec4\",\r\n          r,\r\n          g,\r\n          b,\r\n          a: dynoConst(\"float\", opacity),\r\n        });\r\n        const center = add(min, mul(size, coord));\r\n        const scales = vec3(dynoConst(\"float\", dotScale));\r\n        const quaternion = dynoConst(\"vec4\", new THREE.Quaternion(0, 0, 0, 1));\r\n        let gsplat = combineGsplat({\r\n          flags: dynoLiteral(\"uint\", \"GSPLAT_FLAG_ACTIVE\"),\r\n          index: index,\r\n          center,\r\n          scales,\r\n          quaternion,\r\n          rgba,\r\n        });\r\n        gsplat = transformer.applyGsplat(gsplat);\r\n        return { gsplat };\r\n      },\r\n      {\r\n        globals: () => [defineGsplat],\r\n      },\r\n    ),\r\n    update: ({ time }) => {\r\n      dynoTime.value = time;\r\n      const _updated = transformer.update(generator);\r\n      generator.updateVersion();\r\n    },\r\n  });\r\n  const transformer: SplatTransformer = new SplatTransformer();\r\n  return generator;\r\n}\r\n","import * as THREE from \"three\";\r\n\r\nimport { SplatGenerator, SplatTransformer } from \"../SplatGenerator\";\r\nimport {\r\n  Gsplat,\r\n  add,\r\n  combine,\r\n  combineGsplat,\r\n  defineGsplat,\r\n  dynoBlock,\r\n  dynoConst,\r\n  dynoFloat,\r\n  dynoLiteral,\r\n  fract,\r\n  hashVec4,\r\n  max,\r\n  mix,\r\n  mod,\r\n  mul,\r\n  sin,\r\n  split,\r\n  sub,\r\n  vec3,\r\n} from \"../dyno\";\r\nimport { dynoVec3 } from \"../dyno\";\r\n\r\n// snowBox produces Gsplat trajectories that move in a deterministic fashion over time,\r\n// with high similarity between adjacent frames. See examples/atmospheric/main.js\r\n// for an example that creates a snowBox.\r\n\r\n// A snowBox instance has a collection of properties that can be tuned to achieve\r\n// different particle effects. The below DEFAULT_SNOW and DEFAULT_RAIN are example\r\n// parameter sets that look a lot like snow and rain, and can be used as a starting\r\n// point for further tweaking: `const mySnow = { ...DEFAULT_SNOW, density: 500 };`\r\n\r\nexport const DEFAULT_SNOW = {\r\n  box: new THREE.Box3(\r\n    new THREE.Vector3(-1, -1, -1),\r\n    new THREE.Vector3(1, 1, 1),\r\n  ),\r\n  density: 100,\r\n  fallDirection: new THREE.Vector3(-1, -3, 1).normalize(),\r\n  fallVelocity: 0.02,\r\n  wanderScale: 0.04,\r\n  wanderVariance: 2,\r\n  color1: new THREE.Color(1, 1, 1),\r\n  color2: new THREE.Color(0.5, 0.5, 1),\r\n  minScale: 0.001,\r\n  maxScale: 0.005,\r\n  anisoScale: new THREE.Vector3(1, 1, 1),\r\n};\r\n\r\nexport const DEFAULT_RAIN = {\r\n  box: new THREE.Box3(\r\n    new THREE.Vector3(-2, -1, -2),\r\n    new THREE.Vector3(2, 5, 2),\r\n  ),\r\n  density: 10,\r\n  fallDirection: new THREE.Vector3(0, -1, 0),\r\n  fallVelocity: 2,\r\n  wanderScale: 0.1,\r\n  wanderVariance: 1,\r\n  color1: new THREE.Color(1, 1, 1),\r\n  color2: new THREE.Color(0.25, 0.25, 0.5),\r\n  minScale: 0.005,\r\n  maxScale: 0.01,\r\n  anisoScale: new THREE.Vector3(0.1, 1, 0.1),\r\n};\r\n\r\n// Calling snowBox creates a new snowBox instance and returns an object with\r\n// the snowBox itself as well `as` a collection of controls that can be used to\r\n// adjust the snowBox's properties over time:\r\n//\r\n// - snow: the SplatGenerator snowBox instance\r\n// - min: the vec3 uniform of the snowBox minimum position\r\n// - max: the vec3 uniform of the snowBox maximum position\r\n// - minY: the float uniform of the snowBox minimum y-coordinate\r\n// - color1: the vec3 uniform of the snowBox first color\r\n// - color2: the vec3 uniform of the snowBox second color\r\n// - opacity: the float uniform of the snowBox opacity\r\n// - fallVelocity: the float uniform of the snowBox fall velocity\r\n// - wanderVariance: the float uniform of the snowBox wander variance\r\n// - wanderScale: the float uniform of the snowBox wander scale\r\n// - fallDirection: the vec3 uniform of the snowBox fall direction\r\n// - minScale: the float uniform of the snowBox minimum scale\r\n// - maxScale: the float uniform of the snowBox maximum scale\r\n// - anisoScale: the vec3 uniform of the snowBox anisotropic scale\r\n\r\nexport function snowBox({\r\n  // min and max box extents of the snowBox\r\n  box,\r\n  // minimum y-coordinate to clamp particle position, which can be used to\r\n  // fake hitting a ground plane and lingering there for a bit\r\n  minY,\r\n  // number of Gsplats to generate (default: calculated from box and density)\r\n  numSplats,\r\n  // density of Gsplats per unit volume (default: 100)\r\n  density,\r\n  // The xyz anisotropic scale of the Gsplat, which can be used for example\r\n  // to elongate rain particles (default: (1, 1, 1))\r\n  anisoScale,\r\n  // Minimum Gsplat particle scale (default: 0.001)\r\n  minScale,\r\n  // Maximum Gsplat particle scale (default: 0.005)\r\n  maxScale,\r\n  // The average direction of fall (default: (0, -1, 0))\r\n  fallDirection,\r\n  // The average speed of the fall (multiplied with fallDirection) (default: 0.02)\r\n  fallVelocity,\r\n  // The world scale of wandering overlay motion (default: 0.01)\r\n  wanderScale,\r\n  // Controls how uniformly the particles wander in sync, more variance mean\r\n  // more randomness in the motion (default: 2)\r\n  wanderVariance,\r\n  // Color 1 of the two colors interpolated between (default: (1, 1, 1))\r\n  color1,\r\n  // Color 2 of the two colors interpolated between (default: (0.5, 0.5, 1))\r\n  color2,\r\n  // The base opacity of the Gsplats (default: 1)\r\n  opacity,\r\n  // Optional callback function to call each frame.\r\n  onFrame,\r\n}: {\r\n  box?: THREE.Box3;\r\n  minY?: number;\r\n  numSplats?: number;\r\n  density?: number;\r\n  anisoScale?: THREE.Vector3;\r\n  minScale?: number;\r\n  maxScale?: number;\r\n  fallDirection?: THREE.Vector3;\r\n  fallVelocity?: number;\r\n  wanderScale?: number;\r\n  wanderVariance?: number;\r\n  color1?: THREE.Color;\r\n  color2?: THREE.Color;\r\n  opacity?: number;\r\n  onFrame?: ({\r\n    object,\r\n    time,\r\n    deltaTime,\r\n  }: { object: SplatGenerator; time: number; deltaTime: number }) => void;\r\n}) {\r\n  box =\r\n    box ??\r\n    new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1));\r\n  const volume =\r\n    (box.max.x - box.min.x) * (box.max.y - box.min.y) * (box.max.z - box.min.z);\r\n  density = density ?? 100;\r\n  numSplats =\r\n    numSplats ?? Math.max(1, Math.min(1000000, Math.round(volume * density)));\r\n\r\n  const dynoMinScale = dynoFloat(minScale ?? 0.001);\r\n  const dynoMaxScale = dynoFloat(maxScale ?? 0.005);\r\n  const dynoAnisoScale = dynoVec3(\r\n    (anisoScale?.clone() ?? new THREE.Vector3(1, 1, 1)).normalize(),\r\n  );\r\n  const dynoFallDirection = dynoVec3(\r\n    (fallDirection ?? new THREE.Vector3(0, -1, 0)).normalize(),\r\n  );\r\n  const dynoFallVelocity = dynoFloat(fallVelocity ?? 0.02);\r\n  const dynoWanderScale = dynoFloat(wanderScale ?? 0.01);\r\n  const dynoWanderVariance = dynoFloat(wanderVariance ?? 2);\r\n  const dynoColor1 = dynoVec3(color1 ?? new THREE.Color(1, 1, 1));\r\n  const dynoColor2 = dynoVec3(color2 ?? new THREE.Color(0.5, 0.5, 1));\r\n  const dynoOpacity = dynoFloat(opacity ?? 1);\r\n\r\n  const dynoTime = dynoFloat(0);\r\n  const globalOffset = dynoVec3(new THREE.Vector3(0, 0, 0));\r\n  const dynoMin = dynoVec3(box.min);\r\n  const dynoMax = dynoVec3(box.max);\r\n  const dynoMinY = dynoFloat(minY ?? Number.NEGATIVE_INFINITY);\r\n  const minMax = sub(dynoMax, dynoMin);\r\n  const snow = new SplatGenerator({\r\n    numSplats,\r\n    generator: dynoBlock(\r\n      { index: \"int\" },\r\n      { gsplat: Gsplat },\r\n      ({ index }) => {\r\n        if (!index) {\r\n          throw new Error(\"index not defined\");\r\n        }\r\n        const random = hashVec4(index);\r\n        const randomW = split(random).outputs.w;\r\n        let position = vec3(random);\r\n\r\n        let size = fract(mul(randomW, dynoConst(\"float\", 100)));\r\n        size = sin(mul(dynoLiteral(\"float\", \"PI\"), size));\r\n        size = add(dynoMinScale, mul(size, sub(dynoMaxScale, dynoMinScale)));\r\n        const scales = mul(size, dynoAnisoScale);\r\n\r\n        const intensity = fract(mul(randomW, dynoConst(\"float\", 10)));\r\n        const hue = fract(randomW);\r\n        const color = mix(dynoColor1, dynoColor2, hue);\r\n        const rgb = mul(color, intensity);\r\n\r\n        const random2 = hashVec4(\r\n          combine({\r\n            vectorType: \"ivec2\",\r\n            x: index,\r\n            y: dynoConst(\"int\", 0x1ab5),\r\n          }),\r\n        );\r\n        let perturb = vec3(random2);\r\n        let timeOffset = mul(split(random2).outputs.w, dynoWanderVariance);\r\n        timeOffset = add(dynoTime, timeOffset);\r\n\r\n        position = add(position, globalOffset);\r\n        const modulo = mod(\r\n          position,\r\n          dynoConst(\"vec3\", new THREE.Vector3(1, 1, 1)),\r\n        );\r\n        position = add(dynoMin, mul(minMax, modulo));\r\n\r\n        const quaternion = dynoConst(\"vec4\", new THREE.Quaternion(0, 0, 0, 1));\r\n\r\n        perturb = sin(add(vec3(timeOffset), perturb));\r\n        perturb = mul(perturb, dynoWanderScale);\r\n        let center = add(position, perturb);\r\n\r\n        let centerY = split(center).outputs.y;\r\n        centerY = max(dynoMinY, centerY);\r\n        center = combine({ vector: center, y: centerY });\r\n\r\n        let gsplat = combineGsplat({\r\n          flags: dynoLiteral(\"uint\", \"GSPLAT_FLAG_ACTIVE\"),\r\n          index: index,\r\n          center,\r\n          scales,\r\n          quaternion,\r\n          rgb,\r\n          opacity: dynoOpacity,\r\n        });\r\n        gsplat = transformer.applyGsplat(gsplat);\r\n        return { gsplat };\r\n      },\r\n      {\r\n        globals: () => [defineGsplat],\r\n      },\r\n    ),\r\n    update: ({ object, time, deltaTime }) => {\r\n      dynoTime.value = time;\r\n      const _updated = transformer.update(snow);\r\n\r\n      const fallDelta = dynoFallDirection.value\r\n        .clone()\r\n        .multiplyScalar(dynoFallVelocity.value * deltaTime);\r\n      globalOffset.value.add(fallDelta);\r\n\r\n      // Enable/disable splats based on opacity\r\n      object.visible = dynoOpacity.value > 0;\r\n\r\n      onFrame?.({ object, time, deltaTime });\r\n      snow.updateVersion();\r\n    },\r\n  });\r\n  const transformer: SplatTransformer = new SplatTransformer();\r\n  return {\r\n    snow,\r\n    min: dynoMin,\r\n    max: dynoMax,\r\n    minY: dynoMinY,\r\n    color1: dynoColor1,\r\n    color2: dynoColor2,\r\n    opacity: dynoOpacity,\r\n    fallVelocity: dynoFallVelocity,\r\n    wanderVariance: dynoWanderVariance,\r\n    wanderScale: dynoWanderScale,\r\n    fallDirection: dynoFallDirection,\r\n    minScale: dynoMinScale,\r\n    maxScale: dynoMaxScale,\r\n    anisoScale: dynoAnisoScale,\r\n  };\r\n}\r\n\r\nexport type SNOW_RESULT_TYPE = ReturnType<typeof snowBox>;\r\n","import type { SplatTransformer } from \"../SplatGenerator\";\r\nimport type { SplatMesh } from \"../SplatMesh\";\r\nimport {\r\n  Gsplat,\r\n  add,\r\n  combineGsplat,\r\n  dot,\r\n  dynoBlock,\r\n  dynoConst,\r\n  greaterThanEqual,\r\n  gsplatNormal,\r\n  mul,\r\n  neg,\r\n  select,\r\n  splitGsplat,\r\n} from \"../dyno\";\r\n\r\nexport function makeNormalColorModifier(splatToView: SplatTransformer) {\r\n  return dynoBlock({ gsplat: Gsplat }, { gsplat: Gsplat }, ({ gsplat }) => {\r\n    if (!gsplat) {\r\n      throw new Error(\"No gsplat input\");\r\n    }\r\n    let normal = gsplatNormal(gsplat);\r\n\r\n    const viewGsplat = splatToView.applyGsplat(gsplat);\r\n    const viewCenter = splitGsplat(viewGsplat).outputs.center;\r\n    const viewNormal = gsplatNormal(viewGsplat);\r\n    const splatDot = dot(viewCenter, viewNormal);\r\n\r\n    const sameDir = greaterThanEqual(splatDot, dynoConst(\"float\", 0));\r\n    normal = select(sameDir, neg(normal), normal);\r\n    const rgb = add(\r\n      mul(normal, dynoConst(\"float\", 0.5)),\r\n      dynoConst(\"float\", 0.5),\r\n    );\r\n\r\n    gsplat = combineGsplat({ gsplat, rgb });\r\n    return { gsplat };\r\n  });\r\n}\r\n\r\nexport function setWorldNormalColor(splats: SplatMesh) {\r\n  splats.enableWorldToView = true;\r\n  splats.worldModifier = makeNormalColorModifier(splats.context.worldToView);\r\n  splats.updateGenerator();\r\n}\r\n","import type { SplatTransformer } from \"../SplatGenerator\";\r\nimport type { SplatMesh } from \"../SplatMesh\";\r\nimport {\r\n  type DynoVal,\r\n  Gsplat,\r\n  combineGsplat,\r\n  dynoBlock,\r\n  dynoConst,\r\n  neg,\r\n  normalizedDepth,\r\n  select,\r\n  split,\r\n  splitGsplat,\r\n  sub,\r\n} from \"../dyno\";\r\n\r\nexport function makeDepthColorModifier(\r\n  splatToView: SplatTransformer,\r\n  minDepth: DynoVal<\"float\">,\r\n  maxDepth: DynoVal<\"float\">,\r\n  reverse: DynoVal<\"bool\">,\r\n) {\r\n  return dynoBlock({ gsplat: Gsplat }, { gsplat: Gsplat }, ({ gsplat }) => {\r\n    if (!gsplat) {\r\n      throw new Error(\"No gsplat input\");\r\n    }\r\n    let { center } = splitGsplat(gsplat).outputs;\r\n    center = splatToView.apply(center);\r\n    const { z } = split(center).outputs;\r\n    let depth = normalizedDepth(neg(z), minDepth, maxDepth);\r\n    depth = select(reverse, sub(dynoConst(\"float\", 1), depth), depth);\r\n\r\n    gsplat = combineGsplat({ gsplat, r: depth, g: depth, b: depth });\r\n    return { gsplat };\r\n  });\r\n}\r\n\r\nexport function setDepthColor(\r\n  splats: SplatMesh,\r\n  minDepth: number,\r\n  maxDepth: number,\r\n  reverse?: boolean,\r\n) {\r\n  splats.enableWorldToView = true;\r\n  const dynoMinDepth = dynoConst(\"float\", minDepth);\r\n  const dynoMaxDepth = dynoConst(\"float\", maxDepth);\r\n  const dynoReverse = dynoConst(\"bool\", reverse ?? false);\r\n  splats.worldModifier = makeDepthColorModifier(\r\n    splats.context.worldToView,\r\n    dynoMinDepth,\r\n    dynoMaxDepth,\r\n    dynoReverse,\r\n  );\r\n  splats.updateGenerator();\r\n  return {\r\n    minDepth: dynoMinDepth,\r\n    maxDepth: dynoMaxDepth,\r\n    reverse: dynoReverse,\r\n  };\r\n}\r\n","import type * as THREE from \"three\";\r\n\r\nexport class VRButton {\r\n  static createButton(\r\n    renderer: THREE.WebGLRenderer,\r\n    sessionInit: XRSessionInit = {},\r\n  ): HTMLElement | null {\r\n    const navigatorXr = navigator.xr;\r\n    if (!navigatorXr) {\r\n      // Only allow creation if WebXR is supported\r\n      return null;\r\n    }\r\n    const xr = navigatorXr;\r\n\r\n    const button = document.createElement(\"button\");\r\n    renderer.xr.enabled = true;\r\n    renderer.xr.setReferenceSpaceType(\"local\");\r\n\r\n    function showEnterVR(/*device*/) {\r\n      let currentSession: XRSession | null = null;\r\n\r\n      async function onSessionStarted(session: XRSession) {\r\n        console.log(\"onSessionStarted\");\r\n\r\n        session.addEventListener(\"end\", onSessionEnded);\r\n\r\n        await renderer.xr.setSession(session);\r\n        button.textContent = \"EXIT VR\";\r\n\r\n        currentSession = session;\r\n      }\r\n\r\n      function onSessionEnded(/*event*/) {\r\n        console.log(\"onSessionEnded\");\r\n        currentSession?.removeEventListener(\"end\", onSessionEnded);\r\n\r\n        button.textContent = \"ENTER VR\";\r\n\r\n        currentSession = null;\r\n      }\r\n\r\n      button.style.display = \"\";\r\n      button.style.cursor = \"pointer\";\r\n      button.style.left = \"calc(50% - 100px)\";\r\n      button.style.width = \"200px\";\r\n      button.style.height = \"100px\";\r\n      button.textContent = \"ENTER VR\";\r\n\r\n      // WebXR's requestReferenceSpace only works if the corresponding feature\r\n      // was requested at session creation time. For simplicity, just ask for\r\n      // the interesting ones as optional features, but be aware that the\r\n      // requestReferenceSpace call will fail if it turns out to be unavailable.\r\n      // ('local' is always available for immersive sessions and doesn't need to\r\n      // be requested separately.)\r\n\r\n      const sessionOptions: XRSessionInit = {\r\n        ...sessionInit,\r\n        optionalFeatures: [\r\n          // \"local-floor\",\r\n          // \"bounded-floor\",\r\n          // \"layers\",\r\n          ...(sessionInit.optionalFeatures || []),\r\n        ],\r\n      };\r\n\r\n      button.onmouseenter = () => {\r\n        button.style.opacity = \"1.0\";\r\n      };\r\n      button.onmouseleave = () => {\r\n        button.style.opacity = \"0.5\";\r\n      };\r\n      button.onclick = () => {\r\n        if (currentSession === null) {\r\n          console.log(\"requesting session\");\r\n          xr.requestSession(\"immersive-vr\", sessionOptions).then(\r\n            onSessionStarted,\r\n          );\r\n          // xr.requestSession( \"immersive-ar\", sessionOptions ).then( onSessionStarted );\r\n        } else {\r\n          console.log(\"ending session\");\r\n          currentSession.end();\r\n        }\r\n      };\r\n    }\r\n\r\n    function disableButton() {\r\n      button.style.display = \"none\";\r\n      button.style.cursor = \"auto\";\r\n      button.style.left = \"calc(50% - 75px)\";\r\n      button.style.width = \"150px\";\r\n\r\n      button.onmouseenter = null;\r\n      button.onmouseleave = null;\r\n      button.onclick = null;\r\n    }\r\n\r\n    function showWebXRNotFound() {\r\n      disableButton();\r\n      button.textContent = \"VR NOT SUPPORTED\";\r\n    }\r\n\r\n    function showVRNotAllowed(exception: any) {\r\n      disableButton();\r\n      console.warn(\r\n        \"Exception when trying to call xr.isSessionSupported\",\r\n        exception,\r\n      );\r\n      button.textContent = \"VR NOT ALLOWED\";\r\n    }\r\n\r\n    function stylizeElement(element: HTMLElement) {\r\n      element.style.position = \"absolute\";\r\n      element.style.bottom = \"20px\";\r\n      element.style.padding = \"12px 6px\";\r\n      element.style.border = \"1px solid #fff\";\r\n      element.style.borderRadius = \"4px\";\r\n      element.style.background = \"rgba(0,0,0,0.1)\";\r\n      element.style.color = \"#fff\";\r\n      element.style.font = \"normal 13px sans-serif\";\r\n      element.style.textAlign = \"center\";\r\n      element.style.opacity = \"0.5\";\r\n      element.style.outline = \"none\";\r\n      element.style.zIndex = \"999\";\r\n    }\r\n\r\n    button.id = \"VRButton\";\r\n    button.style.display = \"none\";\r\n    stylizeElement(button);\r\n\r\n    xr.isSessionSupported(\"immersive-vr\")\r\n      .then((supported) => {\r\n        // xr.isSessionSupported( \"immersive-ar\" ).then( function ( supported ) {\r\n        supported ? showEnterVR() : showWebXRNotFound();\r\n\r\n        if (supported && VRButton.xrSessionIsGranted) {\r\n          button.click();\r\n        }\r\n      })\r\n      .catch(showVRNotAllowed);\r\n\r\n    return button;\r\n  }\r\n\r\n  static registerSessionGrantedListener() {\r\n    const navigatorXr = navigator.xr;\r\n    if (!navigatorXr) {\r\n      // Only allow creation if WebXR is supported\r\n      return null;\r\n    }\r\n    const xr = navigatorXr;\r\n\r\n    // WebXRViewer (based on Firefox) has a bug where addEventListener\r\n    // throws a silent exception and aborts execution entirely.\r\n    if (/WebXRViewer\\//i.test(navigator.userAgent)) return;\r\n\r\n    xr.addEventListener(\"sessiongranted\", () => {\r\n      VRButton.xrSessionIsGranted = true;\r\n    });\r\n  }\r\n\r\n  static xrSessionIsGranted = false;\r\n}\r\n\r\nVRButton.registerSessionGrantedListener();\r\n","import {\r\n  Color,\r\n  Matrix4,\r\n  type Object3D,\r\n  Quaternion,\r\n  Vector3,\r\n  type WebXRManager,\r\n} from \"three\";\r\nimport { SplatMesh } from \"./SplatMesh\";\r\n\r\n// Experimental WebXR hand tracking and movement\r\n\r\nconst DEFAULT_MOVE_INERTIA = 0.5;\r\nconst DEFAULT_ROTATE_INERTIA = 0.5;\r\nconst TOUCH_BIAS = 0.0;\r\n\r\nexport enum JointEnum {\r\n  w = \"wrist\",\r\n  t0 = \"thumb-metacarpal\",\r\n  t1 = \"thumb-phalanx-proximal\",\r\n  t2 = \"thumb-phalanx-distal\",\r\n  t3 = \"thumb-tip\",\r\n  i0 = \"index-finger-metacarpal\",\r\n  i1 = \"index-finger-phalanx-proximal\",\r\n  i2 = \"index-finger-phalanx-intermediate\",\r\n  i3 = \"index-finger-phalanx-distal\",\r\n  i4 = \"index-finger-tip\",\r\n  m0 = \"middle-finger-metacarpal\",\r\n  m1 = \"middle-finger-phalanx-proximal\",\r\n  m2 = \"middle-finger-phalanx-intermediate\",\r\n  m3 = \"middle-finger-phalanx-distal\",\r\n  m4 = \"middle-finger-tip\",\r\n  r0 = \"ring-finger-metacarpal\",\r\n  r1 = \"ring-finger-phalanx-proximal\",\r\n  r2 = \"ring-finger-phalanx-intermediate\",\r\n  r3 = \"ring-finger-phalanx-distal\",\r\n  r4 = \"ring-finger-tip\",\r\n  p0 = \"pinky-finger-metacarpal\",\r\n  p1 = \"pinky-finger-phalanx-proximal\",\r\n  p2 = \"pinky-finger-phalanx-intermediate\",\r\n  p3 = \"pinky-finger-phalanx-distal\",\r\n  p4 = \"pinky-finger-tip\",\r\n}\r\nexport type JointId = keyof typeof JointEnum;\r\nexport const JOINT_IDS = Object.keys(JointEnum) as JointId[];\r\nexport const NUM_JOINTS = JOINT_IDS.length;\r\n\r\nexport const JOINT_INDEX: { [key in JointId]: number } = {\r\n  w: 0,\r\n  t0: 1,\r\n  t1: 2,\r\n  t2: 3,\r\n  t3: 4,\r\n  i0: 5,\r\n  i1: 6,\r\n  i2: 7,\r\n  i3: 8,\r\n  i4: 9,\r\n  m0: 10,\r\n  m1: 11,\r\n  m2: 12,\r\n  m3: 13,\r\n  m4: 14,\r\n  r0: 15,\r\n  r1: 16,\r\n  r2: 17,\r\n  r3: 18,\r\n  r4: 19,\r\n  p0: 20,\r\n  p1: 21,\r\n  p2: 22,\r\n  p3: 23,\r\n  p4: 24,\r\n};\r\n\r\nexport const JOINT_RADIUS: { [key in JointId]: number } = {\r\n  w: 0.02,\r\n  t0: 0.02,\r\n  t1: 0.014,\r\n  t2: 0.0115,\r\n  t3: 0.0085,\r\n  i0: 0.022,\r\n  i1: 0.012,\r\n  i2: 0.0085,\r\n  i3: 0.0075,\r\n  i4: 0.0065,\r\n  m0: 0.021,\r\n  m1: 0.012,\r\n  m2: 0.008,\r\n  m3: 0.0075,\r\n  m4: 0.0065,\r\n  r0: 0.019,\r\n  r1: 0.011,\r\n  r2: 0.0075,\r\n  r3: 0.007,\r\n  r4: 0.006,\r\n  p0: 0.012,\r\n  p1: 0.01,\r\n  p2: 0.007,\r\n  p3: 0.0065,\r\n  p4: 0.0055,\r\n};\r\n\r\nexport const JOINT_SEGMENTS: JointId[][] = [\r\n  [\"w\", \"t0\", \"t1\", \"t2\", \"t3\"],\r\n  [\"w\", \"i0\", \"i1\", \"i2\", \"i3\", \"i4\"],\r\n  [\"w\", \"m0\", \"m1\", \"m2\", \"m3\", \"m4\"],\r\n  [\"w\", \"r0\", \"r1\", \"r2\", \"r3\", \"r4\"],\r\n  [\"w\", \"p0\", \"p1\", \"p2\", \"p3\", \"p4\"],\r\n];\r\n\r\nexport const JOINT_SEGMENT_STEPS: number[][] = [\r\n  [8, 10, 8, 6],\r\n  [8, 19, 14, 8, 6],\r\n  [8, 19, 14, 8, 6],\r\n  [8, 19, 14, 8, 6],\r\n  [8, 19, 14, 8, 6],\r\n];\r\n\r\nexport const JOINT_TIPS: JointId[] = [\"t3\", \"i4\", \"m4\", \"r4\", \"p4\"];\r\nexport const FINGER_TIPS: JointId[] = [\"i4\", \"m4\", \"r4\", \"p4\"];\r\n\r\nexport enum Hand {\r\n  left = \"left\",\r\n  right = \"right\",\r\n}\r\nexport const HANDS = Object.keys(Hand) as Hand[];\r\n\r\nexport type Joint = {\r\n  position: Vector3;\r\n  quaternion: Quaternion;\r\n  radius: number;\r\n};\r\n\r\nexport type HandJoints = { [key in JointId]?: Joint };\r\nexport type HandsJoints = { [key in Hand]?: HandJoints };\r\n\r\nexport class XrHands {\r\n  hands: HandsJoints = {};\r\n  last: HandsJoints = {};\r\n\r\n  values: Record<string, number> = {};\r\n  tests: Record<string, boolean> = {};\r\n  lastTests: Record<string, boolean> = {};\r\n\r\n  updated = false;\r\n\r\n  update({ xr, xrFrame }: { xr: WebXRManager; xrFrame: XRFrame }) {\r\n    const xrSession = xr.getSession();\r\n    if (!xrSession) {\r\n      return;\r\n    }\r\n    const referenceSpace = xr.getReferenceSpace();\r\n    if (!referenceSpace) {\r\n      return;\r\n    }\r\n    if (!xrFrame.getJointPose) {\r\n      return;\r\n    }\r\n\r\n    this.last = this.hands;\r\n    this.lastTests = this.tests;\r\n\r\n    this.hands = {};\r\n    this.values = {};\r\n    this.tests = {};\r\n\r\n    for (const inputSource of xrSession.inputSources) {\r\n      if (!inputSource.hand) {\r\n        continue;\r\n      }\r\n\r\n      const hand = inputSource.handedness as Hand;\r\n      this.hands[hand] = {};\r\n\r\n      // Iterate over JointId\r\n      for (const jointId of JOINT_IDS) {\r\n        const jointSpace = inputSource.hand.get(JointEnum[jointId]);\r\n        if (jointSpace) {\r\n          const jointPose = xrFrame.getJointPose(jointSpace, referenceSpace);\r\n          if (jointPose) {\r\n            const { position, orientation } = jointPose.transform;\r\n            this.hands[hand][jointId] = {\r\n              position: new Vector3(position.x, position.y, position.z),\r\n              quaternion: new Quaternion(\r\n                orientation.x,\r\n                orientation.y,\r\n                orientation.z,\r\n                orientation.w,\r\n              ),\r\n              radius: jointPose.radius || 0.001,\r\n            };\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const hand of HANDS) {\r\n      for (const { key, value } of [\r\n        { key: `${hand}AllTips`, value: this.allTipsTouching(hand) },\r\n        {\r\n          key: `${hand}IndexThumb`,\r\n          value: this.touching(hand, \"i4\", hand, \"t3\"),\r\n        },\r\n        {\r\n          key: `${hand}MiddleThumb`,\r\n          value: this.touching(hand, \"m4\", hand, \"t3\"),\r\n        },\r\n        {\r\n          key: `${hand}RingThumb`,\r\n          value: this.touching(hand, \"r4\", hand, \"t3\"),\r\n        },\r\n        {\r\n          key: `${hand}PinkyThumb`,\r\n          value: this.touching(hand, \"p4\", hand, \"t3\"),\r\n        },\r\n        { key: `${hand}TriTips`, value: this.triTipsTouching(hand) },\r\n      ]) {\r\n        this.values[key] = value;\r\n        this.tests[key] =\r\n          value === 1.0\r\n            ? true\r\n            : value === 0.0\r\n              ? false\r\n              : (this.lastTests[key] ?? false);\r\n      }\r\n    }\r\n  }\r\n\r\n  makeGhostMesh(): SplatMesh {\r\n    const center = new Vector3();\r\n    const scales = new Vector3(0.01, 0.01, 0.01);\r\n    const quaternion = new Quaternion(0, 0, 0, 1);\r\n    const color = new Color(1, 1, 1);\r\n    const CYCLE = Math.PI * 3;\r\n    const WHITE = new Color(1, 1, 1);\r\n    let opacity = 1.0;\r\n\r\n    const mesh = new SplatMesh({\r\n      onFrame: () => {\r\n        let splatIndex = 0;\r\n        for (const handedness of HANDS) {\r\n          const xrHand = this.hands[handedness];\r\n          for (const [index, segment] of JOINT_SEGMENTS.entries()) {\r\n            for (let i = 1; i < segment.length; ++i) {\r\n              const segmentSplats = JOINT_SEGMENT_STEPS[index][i - 1] * 2;\r\n              const lastSegment = i + 1 === segment.length;\r\n              const jointA = xrHand?.[segment[i - 1]];\r\n              const jointB = xrHand?.[segment[i]];\r\n\r\n              for (let j = 0; j < segmentSplats; ++j) {\r\n                const t = (j + 0.5) / segmentSplats;\r\n                opacity = 0.0;\r\n                if (jointA && jointB) {\r\n                  center.copy(jointA.position).lerp(jointB.position, t);\r\n                  quaternion\r\n                    .copy(jointA.quaternion)\r\n                    .slerp(jointB.quaternion, t);\r\n                  const radiusA = JOINT_RADIUS[segment[i - 1]];\r\n                  const radiusB = JOINT_RADIUS[segment[i]];\r\n                  let radius = (1 - t) * radiusA + t * radiusB;\r\n                  if (lastSegment && t > 0.8) {\r\n                    // Round out finger tips\r\n                    radius *= Math.sqrt(1 - ((t - 0.8) / 0.2) ** 2);\r\n                  }\r\n                  scales.set(0.65 * radius, 0.5 * radius, 0.003);\r\n                  color.set(\r\n                    0.55 + 0.45 * Math.sin(center.x * CYCLE),\r\n                    0.55 + 0.45 * Math.sin(center.y * CYCLE),\r\n                    0.55 + 0.45 * Math.sin(center.z * CYCLE),\r\n                  );\r\n                  if (handedness === \"right\") {\r\n                    color.set(1 - color.r, 1 - color.g, 1 - color.b);\r\n                  }\r\n                  opacity = 0.75;\r\n                }\r\n                mesh.packedSplats.setSplat(\r\n                  splatIndex,\r\n                  center,\r\n                  scales,\r\n                  quaternion,\r\n                  opacity,\r\n                  color,\r\n                );\r\n                splatIndex += 1;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        mesh.packedSplats.numSplats = splatIndex;\r\n        mesh.packedSplats.needsUpdate = true;\r\n        mesh.numSplats = splatIndex;\r\n        mesh.updateVersion();\r\n      },\r\n    });\r\n    return mesh;\r\n  }\r\n\r\n  distance(\r\n    handA: Hand,\r\n    jointA: JointId,\r\n    handB: Hand,\r\n    jointB: JointId,\r\n    last = false,\r\n  ): number {\r\n    const hA = last ? this.last[handA] : this.hands[handA];\r\n    const hB = last ? this.last[handB] : this.hands[handB];\r\n    const jA = hA?.[jointA];\r\n    const jB = hB?.[jointB];\r\n    if (!jA || !jB) {\r\n      return Number.POSITIVE_INFINITY;\r\n    }\r\n    return jA.position.distanceTo(jB.position);\r\n  }\r\n\r\n  separation(\r\n    handA: Hand,\r\n    jointA: JointId,\r\n    handB: Hand,\r\n    jointB: JointId,\r\n    last = false,\r\n  ): number {\r\n    const d = this.distance(handA, jointA, handB, jointB, last);\r\n    if (d === Number.POSITIVE_INFINITY) {\r\n      return Number.POSITIVE_INFINITY;\r\n    }\r\n    return d - JOINT_RADIUS[jointA] - JOINT_RADIUS[jointB];\r\n  }\r\n\r\n  touching(\r\n    handA: Hand,\r\n    jointA: JointId,\r\n    handB: Hand,\r\n    jointB: JointId,\r\n    last = false,\r\n  ): number {\r\n    const d = this.separation(handA, jointA, handB, jointB, last);\r\n    if (d === Number.POSITIVE_INFINITY) {\r\n      return Number.POSITIVE_INFINITY;\r\n    }\r\n    return 1 - Math.max(0, Math.min(1, d / 0.01 - TOUCH_BIAS));\r\n  }\r\n\r\n  allTipsTouching(hand: Hand, last = false): number {\r\n    return Math.min(\r\n      this.touching(hand, \"t3\", hand, \"i4\", last),\r\n      this.touching(hand, \"i4\", hand, \"m4\", last),\r\n      this.touching(hand, \"m4\", hand, \"r4\", last),\r\n      this.touching(hand, \"r4\", hand, \"p4\", last),\r\n      // this.touching(hand, \"p4\", hand, \"t3\", last),\r\n    );\r\n  }\r\n\r\n  triTipsTouching(hand: Hand, last = false): number {\r\n    return Math.min(\r\n      this.touching(hand, \"t3\", hand, \"i4\", last),\r\n      this.touching(hand, \"i4\", hand, \"m4\", last),\r\n      this.touching(hand, \"m4\", hand, \"t3\", last),\r\n    );\r\n  }\r\n}\r\n\r\nexport class HandMovement {\r\n  xrHands: XrHands;\r\n  control: Object3D;\r\n  moveInertia: number;\r\n  rotateInertia: number;\r\n\r\n  lastGrip: { [key in Hand]?: Vector3 } = {};\r\n  lastPivot: Vector3 = new Vector3();\r\n  rotateVelocity = 0;\r\n  velocity: Vector3 = new Vector3();\r\n\r\n  constructor({\r\n    xrHands,\r\n    control,\r\n    moveInertia,\r\n    rotateInertia,\r\n  }: {\r\n    xrHands: XrHands;\r\n    control: Object3D;\r\n    moveInertia?: number;\r\n    rotateInertia?: number;\r\n  }) {\r\n    this.xrHands = xrHands;\r\n    this.control = control;\r\n    this.moveInertia = moveInertia ?? DEFAULT_MOVE_INERTIA;\r\n    this.rotateInertia = rotateInertia ?? DEFAULT_ROTATE_INERTIA;\r\n  }\r\n\r\n  update(deltaTime: number) {\r\n    const grip: { [key in Hand]?: Vector3 } = {};\r\n    for (const handedness of HANDS) {\r\n      const hand = this.xrHands.hands[handedness];\r\n      if (hand && this.xrHands.tests[`${handedness}MiddleThumb`]) {\r\n        grip[handedness] = new Vector3()\r\n          .add(hand.t3?.position ?? new Vector3())\r\n          .add(hand.i4?.position ?? new Vector3())\r\n          .add(hand.m4?.position ?? new Vector3())\r\n          .add(hand.r4?.position ?? new Vector3())\r\n          .add(hand.p4?.position ?? new Vector3())\r\n          .multiplyScalar(1 / 5);\r\n      }\r\n    }\r\n\r\n    if (grip.left && grip.right && this.lastGrip.left && this.lastGrip.right) {\r\n      const mid = grip.left.clone().add(grip.right).multiplyScalar(0.5);\r\n      const lastMid = this.lastGrip.left\r\n        .clone()\r\n        .add(this.lastGrip.right)\r\n        .multiplyScalar(0.5);\r\n      this.lastPivot = mid;\r\n\r\n      const delta = mid.clone().applyMatrix4(this.control.matrix);\r\n      delta.sub(lastMid.clone().applyMatrix4(this.control.matrix));\r\n      delta.multiplyScalar(1 / deltaTime);\r\n      this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime));\r\n\r\n      const angle = Math.atan2(grip.left.z - mid.z, grip.left.x - mid.x);\r\n      const lastAngle = Math.atan2(\r\n        this.lastGrip.left.z - lastMid.z,\r\n        this.lastGrip.left.x - lastMid.x,\r\n      );\r\n      // Find closest rotation over circle between angle and lastAngle\r\n      let closestAngle = angle - lastAngle;\r\n      if (closestAngle > Math.PI) {\r\n        closestAngle -= Math.PI * 2;\r\n      } else if (closestAngle < -Math.PI) {\r\n        closestAngle += Math.PI * 2;\r\n      }\r\n      const rotateVelocity = closestAngle / deltaTime;\r\n\r\n      const blend = Math.exp(-20 * deltaTime);\r\n      this.rotateVelocity =\r\n        this.rotateVelocity * blend + rotateVelocity * (1 - blend);\r\n    } else {\r\n      this.rotateVelocity *= Math.exp(-deltaTime / this.rotateInertia);\r\n\r\n      if (grip.left && this.lastGrip.left) {\r\n        const delta = grip.left.clone().applyMatrix4(this.control.matrix);\r\n        delta.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix));\r\n        delta.multiplyScalar(1 / deltaTime);\r\n        this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime));\r\n      } else if (grip.right && this.lastGrip.right) {\r\n        const delta = grip.right.clone().applyMatrix4(this.control.matrix);\r\n        delta.sub(\r\n          this.lastGrip.right.clone().applyMatrix4(this.control.matrix),\r\n        );\r\n        delta.multiplyScalar(1 / deltaTime);\r\n        this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime));\r\n      } else {\r\n        this.velocity.multiplyScalar(Math.exp(-deltaTime / this.moveInertia));\r\n      }\r\n    }\r\n\r\n    const negPivot = this.lastPivot.clone().negate();\r\n    const rotate = new Matrix4()\r\n      .makeTranslation(negPivot)\r\n      .premultiply(new Matrix4().makeRotationY(this.rotateVelocity * deltaTime))\r\n      .premultiply(new Matrix4().makeTranslation(this.lastPivot));\r\n    this.control.matrix.multiply(rotate);\r\n    this.control.matrix.decompose(\r\n      this.control.position,\r\n      this.control.quaternion,\r\n      this.control.scale,\r\n    );\r\n    this.control.updateMatrixWorld(true);\r\n\r\n    this.control.position.sub(this.velocity.clone().multiplyScalar(deltaTime));\r\n    this.lastGrip = grip;\r\n  }\r\n}\r\n","import * as THREE from \"three\";\r\n\r\n// Spark controls for keyboard + mouse, game pad, or mobile multi-touch\r\n\r\nconst DEFAULT_MOVEMENT_SPEED = 1.0;\r\nconst DEFAULT_ROLL_SPEED = 2.0;\r\nconst DEFAULT_ROTATE_SPEED = 0.002;\r\nconst DEFAULT_SLIDE_SPEED = 0.006;\r\nconst DEFAULT_SCROLL_SPEED = 0.0015;\r\nconst DEFAULT_ROLL_SPRING = 0.0;\r\nconst DEFAULT_ROTATE_INERTIA = 0.15;\r\nconst DEFAULT_MOVE_INERTIA = 0.15;\r\nconst DEFAULT_STICK_THRESHOLD = 0.1;\r\nconst DEFAULT_FPS_ROTATE_SPEED = 2.0;\r\nconst DEFAULT_POINTER_ROLL_SCALE = 1.0;\r\n\r\n// Time limit for double-finger press (pinch etc)\r\nconst DUAL_PRESS_MS = 200;\r\n// Time limit for double-click/double-tap\r\nconst DOUBLE_PRESS_LIMIT_MS = 400;\r\n// Distance limit for double-click.\r\nconst DOUBLE_PRESS_DISTANCE = 50;\r\n\r\n// Standard WASD movement keys with R+F for up/down\r\nconst WASD_KEYCODE_MOVE = {\r\n  KeyW: new THREE.Vector3(0, 0, -1),\r\n  KeyS: new THREE.Vector3(0, 0, 1),\r\n  KeyA: new THREE.Vector3(-1, 0, 0),\r\n  KeyD: new THREE.Vector3(1, 0, 0),\r\n  KeyR: new THREE.Vector3(0, 1, 0),\r\n  KeyF: new THREE.Vector3(0, -1, 0),\r\n};\r\n\r\n// Arrow key movement with PageUp/PageDown\r\nconst ARROW_KEYCODE_MOVE = {\r\n  ArrowUp: new THREE.Vector3(0, 0, -1),\r\n  ArrowDown: new THREE.Vector3(0, 0, 1),\r\n  ArrowLeft: new THREE.Vector3(-1, 0, 0),\r\n  ArrowRight: new THREE.Vector3(1, 0, 0),\r\n  PageUp: new THREE.Vector3(0, 1, 0),\r\n  PageDown: new THREE.Vector3(0, -1, 0),\r\n};\r\n\r\n// Rolling with Q/E\r\nconst QE_KEYCODE_ROTATE = {\r\n  KeyQ: new THREE.Vector3(0, 0, 1),\r\n  KeyE: new THREE.Vector3(0, 0, -1),\r\n};\r\n\r\n// Home/End/Insert/Delete for rotation\r\nconst ARROW_KEYCODE_ROTATE = {\r\n  Home: new THREE.Vector3(0, -1, 0),\r\n  End: new THREE.Vector3(0, 1, 0),\r\n  Insert: new THREE.Vector3(-1, 0, 0),\r\n  Delete: new THREE.Vector3(1, 0, 0),\r\n};\r\n\r\n// SparkControls provides simple, intuitive controls for navigating 3D space that\r\n// use the keyboard + mouse, game pad, or mobile multi-touch. Internally it\r\n// instantiates and updates a `FpsMovement` and `PointerControls` instance.\r\n\r\nexport class SparkControls {\r\n  fpsMovement: FpsMovement;\r\n  pointerControls: PointerControls;\r\n  lastTime = 0;\r\n\r\n  constructor({ canvas }: { canvas: HTMLCanvasElement }) {\r\n    this.fpsMovement = new FpsMovement({});\r\n    this.pointerControls = new PointerControls({ canvas });\r\n  }\r\n\r\n  update(control: THREE.Object3D) {\r\n    const time = performance.now();\r\n    const deltaTime = (time - (this.lastTime || time)) / 1000;\r\n    this.lastTime = time;\r\n\r\n    this.fpsMovement.update(deltaTime, control);\r\n    this.pointerControls.update(deltaTime, control);\r\n  }\r\n}\r\n\r\n// FpsMovement implements controls that will be familiar to anyone who plays\r\n// First Person Shooters using keyboard + mouse or a gamepad. Creating a FpsMovement\r\n// instance provides many parameters for configuring the controls.\r\n//\r\n// When gamepads are connected, FpsMovement will always use gamepad index 0\r\n// for twin-stick movement and rotation.\r\n//\r\n// If xr is passed in, the WebXR controllers can be used as a split gamepad\r\n// to control movement and rotation. (tested on Quest 3)\r\n\r\nexport class FpsMovement {\r\n  moveSpeed: number;\r\n  rollSpeed: number;\r\n  stickThreshold: number;\r\n  rotateSpeed: number;\r\n  keycodeMoveMapping: { [key: string]: THREE.Vector3 };\r\n  keycodeRotateMapping: { [key: string]: THREE.Vector3 };\r\n  gamepadMapping: {\r\n    [button: number]: \"shift\" | \"ctrl\" | \"rollLeft\" | \"rollRight\";\r\n  };\r\n  capsMultiplier: number;\r\n  shiftMultiplier: number;\r\n  ctrlMultiplier: number;\r\n  xr?: THREE.WebXRManager;\r\n  // Enable/disable controls updates\r\n  enable = true;\r\n\r\n  // Currently active event.key values\r\n  keydown: { [key: string]: boolean };\r\n  // Currently active event.code values\r\n  keycode: { [key: string]: boolean };\r\n\r\n  constructor({\r\n    moveSpeed,\r\n    rollSpeed,\r\n    stickThreshold,\r\n    rotateSpeed,\r\n    keycodeMoveMapping,\r\n    keycodeRotateMapping,\r\n    gamepadMapping,\r\n    capsMultiplier,\r\n    shiftMultiplier,\r\n    ctrlMultiplier,\r\n    xr,\r\n  }: {\r\n    // Base movement speed (default DEFAULT_MOVEMENT_SPEED)\r\n    moveSpeed?: number;\r\n    // Base roll speed (default DEFAULT_ROLL_SPEED)\r\n    rollSpeed?: number;\r\n    // Stick threshold (default DEFAULT_STICK_THRESHOLD)\r\n    stickThreshold?: number;\r\n    // Speed of rotation when using gamepad or keys (default DEFAULT_FPS_ROTATE_SPEED)\r\n    rotateSpeed?: number;\r\n    // Maps keyboard keys to movement directions\r\n    // (default {...WASD_KEYCODE_MOVE, ...ARROW_KEYCODE_MOVE})\r\n    keycodeMoveMapping?: { [key: string]: THREE.Vector3 };\r\n    // Maps keyboard keys to rotation directions\r\n    // (default {...QE_KEYCODE_ROTATE, ...ARROW_KEYCODE_ROTATE})\r\n    keycodeRotateMapping?: { [key: string]: THREE.Vector3 };\r\n    // Maps gamepad buttons to control actions\r\n    // (default {4: \"rollLeft\", 5: \"rollRight\", 6: \"ctrl\", 7: \"shift\"})\r\n    gamepadMapping?: {\r\n      [button: number]: \"shift\" | \"ctrl\" | \"rollLeft\" | \"rollRight\";\r\n    };\r\n    // Speed multiplier when Caps Lock is active (default: 10)\r\n    capsMultiplier?: number;\r\n    // Speed multiplier when Shift is active (default: 5)\r\n    shiftMultiplier?: number;\r\n    // Speed multiplier when Ctrl is active (default: 1/5)\r\n    ctrlMultiplier?: number;\r\n    // Optional WebXR manager for XR controller stick support\r\n    xr?: THREE.WebXRManager;\r\n  } = {}) {\r\n    this.moveSpeed = moveSpeed ?? DEFAULT_MOVEMENT_SPEED;\r\n    this.rollSpeed = rollSpeed ?? DEFAULT_ROLL_SPEED;\r\n    this.stickThreshold = stickThreshold ?? DEFAULT_STICK_THRESHOLD;\r\n    this.rotateSpeed = rotateSpeed ?? DEFAULT_FPS_ROTATE_SPEED;\r\n    this.keycodeMoveMapping = keycodeMoveMapping ?? {\r\n      ...WASD_KEYCODE_MOVE,\r\n      ...ARROW_KEYCODE_MOVE,\r\n    };\r\n    this.keycodeRotateMapping = keycodeRotateMapping ?? {\r\n      ...QE_KEYCODE_ROTATE,\r\n      ...ARROW_KEYCODE_ROTATE,\r\n    };\r\n    this.gamepadMapping = gamepadMapping ?? {\r\n      4: \"rollLeft\",\r\n      5: \"rollRight\",\r\n      6: \"ctrl\",\r\n      7: \"shift\",\r\n    };\r\n    this.capsMultiplier = capsMultiplier ?? 10.0;\r\n    this.shiftMultiplier = shiftMultiplier ?? 5.0;\r\n    this.ctrlMultiplier = ctrlMultiplier ?? 1.0 / 5.0;\r\n\r\n    this.xr = xr;\r\n\r\n    this.keydown = {};\r\n    this.keycode = {};\r\n\r\n    document.addEventListener(\"keydown\", (event) => {\r\n      this.keydown[event.key] = true;\r\n      this.keycode[event.code] = true;\r\n    });\r\n    document.addEventListener(\"keyup\", (event) => {\r\n      this.keydown[event.key] = false;\r\n      this.keycode[event.code] = false;\r\n    });\r\n    window.addEventListener(\"blur\", () => {\r\n      this.keydown = {};\r\n      this.keycode = {};\r\n    });\r\n  }\r\n\r\n  // Call this method in your render loop with `control` set to the object to control\r\n  // (`THREE.Camera` or a `THREE.Object3D` that contains it), with `deltaTime`\r\n  // in seconds since the last update.\r\n  update(deltaTime: number, control: THREE.Object3D) {\r\n    if (!this.enable) {\r\n      return;\r\n    }\r\n\r\n    // Update gamepad / XR controllers\r\n\r\n    const sticks = [new THREE.Vector2(), new THREE.Vector2()];\r\n    const gamepad = navigator.getGamepads()[0];\r\n    if (gamepad) {\r\n      sticks[0].set(gamepad.axes[0], gamepad.axes[1]);\r\n      sticks[1].set(gamepad.axes[2], gamepad.axes[3]);\r\n    }\r\n    const gamepadButtons =\r\n      gamepad?.buttons.map((button) => button.pressed) || [];\r\n\r\n    const xrSources = Array.from(this.xr?.getSession()?.inputSources ?? []);\r\n    for (const source of xrSources) {\r\n      const gamepad = source.gamepad;\r\n      if (gamepad) {\r\n        switch (source.handedness) {\r\n          case \"none\": {\r\n            sticks[0].x += gamepad.axes[0];\r\n            sticks[0].y += gamepad.axes[1];\r\n            sticks[1].x += gamepad.axes[2];\r\n            sticks[1].y += gamepad.axes[3];\r\n            break;\r\n          }\r\n          case \"left\": {\r\n            sticks[0].x += gamepad.axes[2];\r\n            sticks[0].y += gamepad.axes[3];\r\n            break;\r\n          }\r\n          case \"right\": {\r\n            sticks[1].x += gamepad.axes[2];\r\n            sticks[1].y += gamepad.axes[3];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const stick of sticks) {\r\n      stick.x = Math.abs(stick.x) >= this.stickThreshold ? stick.x : 0;\r\n      stick.y = Math.abs(stick.y) >= this.stickThreshold ? stick.y : 0;\r\n    }\r\n\r\n    // Rotation\r\n\r\n    const rotate = new THREE.Vector3(\r\n      sticks[1].x,\r\n      sticks[1].y,\r\n      0,\r\n    ).multiplyScalar(this.rotateSpeed);\r\n\r\n    for (const [keycode, rot] of Object.entries(this.keycodeRotateMapping)) {\r\n      if (this.keycode[keycode]) {\r\n        rotate.add(rot);\r\n      }\r\n    }\r\n    for (const button in this.gamepadMapping) {\r\n      if (gamepadButtons[Number.parseInt(button)]) {\r\n        switch (this.gamepadMapping[button]) {\r\n          case \"rollLeft\":\r\n            rotate.z += 1;\r\n            break;\r\n          case \"rollRight\":\r\n            rotate.z -= 1;\r\n            break;\r\n        }\r\n      }\r\n    }\r\n\r\n    rotate.multiply(\r\n      new THREE.Vector3(this.rotateSpeed, this.rotateSpeed, this.rollSpeed),\r\n    );\r\n\r\n    if (rotate.manhattanLength() > 0.0) {\r\n      rotate.multiplyScalar(deltaTime);\r\n      const eulers = new THREE.Euler().setFromQuaternion(\r\n        control.quaternion,\r\n        \"YXZ\",\r\n      );\r\n      eulers.y -= rotate.x;\r\n      eulers.x = Math.max(\r\n        -Math.PI / 2,\r\n        Math.min(Math.PI / 2, eulers.x - rotate.y),\r\n      );\r\n      eulers.z = Math.max(-Math.PI, Math.min(Math.PI, eulers.z + rotate.z));\r\n      control.quaternion.setFromEuler(eulers);\r\n    }\r\n\r\n    // Movement\r\n\r\n    const moveVector = new THREE.Vector3(sticks[0].x, 0, sticks[0].y);\r\n\r\n    for (const [keycode, move] of Object.entries(this.keycodeMoveMapping)) {\r\n      if (this.keycode[keycode]) {\r\n        moveVector.add(move);\r\n      }\r\n    }\r\n\r\n    let speedMultiplier = 1.0;\r\n    if (this.keydown.CapsLock) {\r\n      speedMultiplier *= this.capsMultiplier;\r\n    }\r\n    if (this.keycode.ShiftLeft || this.keycode.ShiftRight) {\r\n      speedMultiplier *= this.shiftMultiplier;\r\n    }\r\n    if (this.keycode.ControlLeft || this.keycode.ControlRight) {\r\n      speedMultiplier *= this.ctrlMultiplier;\r\n    }\r\n    for (const button in this.gamepadMapping) {\r\n      if (gamepadButtons[Number.parseInt(button)]) {\r\n        switch (this.gamepadMapping[button]) {\r\n          case \"shift\":\r\n            speedMultiplier *= this.shiftMultiplier;\r\n            break;\r\n          case \"ctrl\":\r\n            speedMultiplier *= this.ctrlMultiplier;\r\n            break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Apply movement in view direction\r\n    moveVector.applyQuaternion(control.quaternion);\r\n    control.position.add(\r\n      moveVector.multiplyScalar(this.moveSpeed * speedMultiplier * deltaTime),\r\n    );\r\n  }\r\n}\r\n\r\ntype PointerState = {\r\n  initial: THREE.Vector2;\r\n  last: THREE.Vector2;\r\n  position: THREE.Vector2;\r\n  pointerId: number;\r\n  button?: number;\r\n  timeStamp: DOMHighResTimeStamp;\r\n};\r\n\r\n// `PointerControls` implements pointer/mouse/touch controls on the canvas,\r\n// for both desktop and mobile web applications.\r\n\r\nexport class PointerControls {\r\n  canvas: HTMLCanvasElement;\r\n  rotateSpeed: number;\r\n  slideSpeed: number;\r\n  scrollSpeed: number;\r\n  swapRotateSlide: boolean;\r\n  reverseRotate: boolean;\r\n  reverseSlide: boolean;\r\n  reverseSwipe: boolean;\r\n  reverseScroll: boolean;\r\n  moveInertia: number;\r\n  rotateInertia: number;\r\n  pointerRollScale: number;\r\n  // Enable/disable controls updates\r\n  enable = true;\r\n\r\n  doublePress: ({\r\n    position,\r\n    intervalMs,\r\n  }: { position: THREE.Vector2; intervalMs: number }) => void;\r\n  // Time limit for double press (default DOUBLE_PRESS_LIMIT_MS)\r\n  doublePressLimitMs: number;\r\n  // Distance limit for double press (default DOUBLE_PRESS_DISTANCE)\r\n  doublePressDistance: number;\r\n  // Last pointer up event (default: null)\r\n  lastUp: { position: THREE.Vector2; time: number } | null;\r\n\r\n  // Pointer state for currently active rotating pointer\r\n  rotating: PointerState | null;\r\n  // Pointer state for currently active sliding pointer\r\n  sliding: PointerState | null;\r\n  // Whether we pressed two pointers at the same time\r\n  dualPress: boolean;\r\n  // Cumulative scroll movement\r\n  scroll: THREE.Vector3;\r\n\r\n  // Current rotation velocity\r\n  rotateVelocity: THREE.Vector3;\r\n  // Current movement velocity\r\n  moveVelocity: THREE.Vector3;\r\n\r\n  constructor({\r\n    // The HTML canvas element to attach pointer events to\r\n    canvas,\r\n    // Speed of rotation (default DEFAULT_ROTATE_SPEED)\r\n    rotateSpeed,\r\n    // Speed of sliding when dragging with right/middle mouse button or two fingers\r\n    // (default DEFAULT_SLIDE_SPEED)\r\n    slideSpeed,\r\n    // Speed of movement when using mouse scroll wheel (default DEFAULT_SCROLL_SPEED)\r\n    scrollSpeed,\r\n    // Swap the direction of rotation and sliding (default: false)\r\n    swapRotateSlide,\r\n    // Reverse the direction of rotation (default: false)\r\n    reverseRotate,\r\n    // Reverse the direction of sliding (default: false)\r\n    reverseSlide,\r\n    // Reverse the direction of swipe gestures (default: false)\r\n    reverseSwipe,\r\n    // Reverse the direction of scroll wheel movement (default: false)\r\n    reverseScroll,\r\n    // Inertia factor for movement (default: DEFAULT_MOVE_INERTIA)\r\n    moveInertia,\r\n    // Inertia factor for rotation (default: DEFAULT_ROTATE_INERTIA)\r\n    rotateInertia,\r\n    // Pointer rolling scale factor (default: DEFAULT_POINTER_ROLL_SCALE)\r\n    pointerRollScale,\r\n    // Callback for double press events (default: () => {})\r\n    doublePress,\r\n  }: {\r\n    canvas: HTMLCanvasElement;\r\n    rotateSpeed?: number;\r\n    slideSpeed?: number;\r\n    scrollSpeed?: number;\r\n    swapRotateSlide?: boolean;\r\n    reverseRotate?: boolean;\r\n    reverseSlide?: boolean;\r\n    reverseSwipe?: boolean;\r\n    reverseScroll?: boolean;\r\n    moveInertia?: number;\r\n    rotateInertia?: number;\r\n    pointerRollScale?: number;\r\n    doublePress?: ({\r\n      position,\r\n      intervalMs,\r\n    }: { position: THREE.Vector2; intervalMs: number }) => void;\r\n  }) {\r\n    this.canvas = canvas;\r\n    this.rotateSpeed = rotateSpeed ?? DEFAULT_ROTATE_SPEED;\r\n    this.slideSpeed = slideSpeed ?? DEFAULT_SLIDE_SPEED;\r\n    this.scrollSpeed = scrollSpeed ?? DEFAULT_SCROLL_SPEED;\r\n    this.swapRotateSlide = swapRotateSlide ?? false;\r\n    this.reverseRotate = reverseRotate ?? false;\r\n    this.reverseSlide = reverseSlide ?? false;\r\n    this.reverseSwipe = reverseSwipe ?? false;\r\n    this.reverseScroll = reverseScroll ?? false;\r\n    this.moveInertia = moveInertia ?? DEFAULT_MOVE_INERTIA;\r\n    this.rotateInertia = rotateInertia ?? DEFAULT_ROTATE_INERTIA;\r\n    this.pointerRollScale = pointerRollScale ?? DEFAULT_POINTER_ROLL_SCALE;\r\n\r\n    this.doublePress = doublePress ?? (() => {});\r\n    this.doublePressLimitMs = DOUBLE_PRESS_LIMIT_MS;\r\n    this.doublePressDistance = DOUBLE_PRESS_DISTANCE;\r\n    this.lastUp = null;\r\n\r\n    this.rotating = null;\r\n    this.sliding = null;\r\n    this.dualPress = false;\r\n    this.scroll = new THREE.Vector3();\r\n\r\n    this.rotateVelocity = new THREE.Vector3();\r\n    this.moveVelocity = new THREE.Vector3();\r\n\r\n    canvas.addEventListener(\"pointerdown\", (event: PointerEvent) => {\r\n      const position = this.getPointerPosition(event);\r\n      const initial = position.clone();\r\n      const last = position.clone();\r\n\r\n      // Determine if we're starting a rotation pointer action\r\n      const isRotate =\r\n        (!this.swapRotateSlide &&\r\n          !this.rotating &&\r\n          (event.pointerType !== \"mouse\" || event.button === 0)) ||\r\n        (this.swapRotateSlide &&\r\n          this.sliding &&\r\n          !this.rotating &&\r\n          (event.pointerType !== \"mouse\" || event.button === 1));\r\n      // const isRotate =\r\n      //   !this.rotating && (event.pointerType !== \"mouse\" || event.button === 0);\r\n      const { pointerId, timeStamp } = event;\r\n\r\n      if (isRotate) {\r\n        this.rotating = { initial, last, position, pointerId, timeStamp };\r\n        // Capture the pointer so events continue to be delivered even if it leaves the canvas.\r\n        canvas.setPointerCapture(event.pointerId);\r\n\r\n        this.dualPress = false;\r\n      } else if (!this.sliding) {\r\n        // If it's not a rotation action and we're not yet sliding, the next\r\n        // pointer activates a sliding action\r\n        const button = event.pointerType === \"mouse\" ? event.button : undefined;\r\n        this.sliding = {\r\n          initial,\r\n          last,\r\n          position,\r\n          pointerId,\r\n          button,\r\n          timeStamp,\r\n        };\r\n        // Capture the pointer so events continue to be delivered even if it leaves the canvas.\r\n        canvas.setPointerCapture(event.pointerId);\r\n\r\n        // Check if we pressed both pointers at roughly the same time\r\n        this.dualPress =\r\n          this.rotating != null &&\r\n          timeStamp - this.rotating.timeStamp < DUAL_PRESS_MS;\r\n      }\r\n    });\r\n\r\n    const pointerUp = (event: PointerEvent) => {\r\n      if (this.rotating?.pointerId === event.pointerId) {\r\n        this.rotating = null;\r\n        canvas.releasePointerCapture(event.pointerId);\r\n        if (this.dualPress && this.sliding) {\r\n          canvas.releasePointerCapture(this.sliding.pointerId);\r\n          this.sliding = null;\r\n        }\r\n      } else if (this.sliding?.pointerId === event.pointerId) {\r\n        this.sliding = null;\r\n        canvas.releasePointerCapture(event.pointerId);\r\n        if (this.dualPress && this.rotating) {\r\n          canvas.releasePointerCapture(this.rotating.pointerId);\r\n          this.rotating = null;\r\n        }\r\n      }\r\n\r\n      const position = this.getPointerPosition(event);\r\n      const lastUp = this.lastUp;\r\n      this.lastUp = { position, time: event.timeStamp };\r\n      if (lastUp) {\r\n        const distance = lastUp.position.distanceTo(position);\r\n        if (distance < this.doublePressDistance) {\r\n          const intervalMs = event.timeStamp - lastUp.time;\r\n          if (intervalMs < this.doublePressLimitMs) {\r\n            // We pressed and release twice within the time and distance limits\r\n            this.lastUp = null;\r\n            this.doublePress({ position, intervalMs });\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    document.addEventListener(\"pointerup\", pointerUp);\r\n    document.addEventListener(\"pointercancel\", pointerUp);\r\n\r\n    document.addEventListener(\"pointermove\", (event: PointerEvent) => {\r\n      if (this.rotating?.pointerId === event.pointerId) {\r\n        this.rotating.position = this.getPointerPosition(event);\r\n      } else if (this.sliding?.pointerId === event.pointerId) {\r\n        this.sliding.position = this.getPointerPosition(event);\r\n      }\r\n    });\r\n\r\n    canvas.addEventListener(\"contextmenu\", (event: MouseEvent) => {\r\n      // Prevent context menu appearing on right click\r\n      event.preventDefault();\r\n    });\r\n\r\n    canvas.addEventListener(\"wheel\", (event: WheelEvent) => {\r\n      this.scroll.add(\r\n        new THREE.Vector3(event.deltaX, event.deltaY, event.deltaZ),\r\n      );\r\n      event.preventDefault();\r\n    });\r\n  }\r\n\r\n  getPointerPosition(event: PointerEvent): THREE.Vector2 {\r\n    const rect = this.canvas.getBoundingClientRect();\r\n    return new THREE.Vector2(\r\n      event.clientX - rect.left,\r\n      event.clientY - rect.top,\r\n    );\r\n  }\r\n\r\n  update(deltaTime: number, control: THREE.Object3D) {\r\n    if (!this.enable) {\r\n      return;\r\n    }\r\n\r\n    if (this.dualPress && this.rotating && this.sliding) {\r\n      // We pressed both pointers at the same time, either pinching or sliding\r\n      const motion = [\r\n        this.rotating.position.clone().sub(this.rotating.last),\r\n        this.sliding.position.clone().sub(this.sliding.last),\r\n      ];\r\n      const coincidence = motion[0].dot(motion[1]);\r\n\r\n      if (coincidence >= 0.2) {\r\n        // Similar directions so slide the camera on the XY plane\r\n        const totalMotion = motion[0].clone().add(motion[1]);\r\n        const slide = new THREE.Vector3(totalMotion.x, -totalMotion.y, 0);\r\n        slide.multiplyScalar(this.slideSpeed * (this.reverseSwipe ? 1 : -1));\r\n        slide.applyQuaternion(control.quaternion);\r\n        control.position.add(slide);\r\n        this.moveVelocity = slide.clone().multiplyScalar(1 / deltaTime);\r\n      } else if (coincidence <= -0.2) {\r\n        // Opposite directions so either pinch or roll motion\r\n        const deltaDir = this.sliding.last.clone().sub(this.rotating.last);\r\n        const deltaDist = deltaDir.length();\r\n        deltaDir.multiplyScalar(1 / deltaDist).normalize();\r\n\r\n        const orthoDir = new THREE.Vector2(-deltaDir.y, deltaDir.x);\r\n        const motionDir = [motion[0].dot(deltaDir), motion[1].dot(deltaDir)];\r\n        const motionOrtho = [motion[0].dot(orthoDir), motion[1].dot(orthoDir)];\r\n\r\n        // Pinching motion\r\n        const midpoint = this.rotating.last\r\n          .clone()\r\n          .add(this.sliding.last)\r\n          .multiplyScalar(0.5);\r\n        let midpointDir = new THREE.Vector3();\r\n        if (control instanceof THREE.Camera) {\r\n          const ndcMidpoint = new THREE.Vector2(\r\n            (midpoint.x / this.canvas.clientWidth) * 2 - 1,\r\n            -(midpoint.y / this.canvas.clientHeight) * 2 + 1,\r\n          );\r\n          const raycaster = new THREE.Raycaster();\r\n          raycaster.setFromCamera(ndcMidpoint, control);\r\n          midpointDir = raycaster.ray.direction;\r\n        }\r\n        const pinchOut = motionDir[1] - motionDir[0];\r\n        const slide = midpointDir.multiplyScalar(pinchOut * this.slideSpeed);\r\n        control.position.add(slide);\r\n        this.moveVelocity = slide.clone().multiplyScalar(1 / deltaTime);\r\n\r\n        // Rolling motion\r\n        // Calculate angle of orthogonal motion change over distance deltaDist/2\r\n        // motionOrtho[0] and 1 are already in float distance\r\n        const angles = [\r\n          Math.atan(motionOrtho[0] / (-0.5 * deltaDist)),\r\n          Math.atan(motionOrtho[1] / (0.5 * deltaDist)),\r\n        ];\r\n        const rotate = 0.5 * (angles[0] + angles[1]) * this.pointerRollScale;\r\n        const eulers = new THREE.Euler().setFromQuaternion(\r\n          control.quaternion,\r\n          \"YXZ\",\r\n        );\r\n        eulers.z = Math.max(\r\n          -Math.PI,\r\n          Math.min(Math.PI, eulers.z + 0.5 * rotate),\r\n        );\r\n        control.quaternion.setFromEuler(eulers);\r\n      }\r\n\r\n      this.rotating.last.copy(this.rotating.position);\r\n      this.sliding.last.copy(this.sliding.position);\r\n    } else {\r\n      // Didn't press both pointers at the same time, so we're in rotating\r\n      // or FPS mode\r\n      const rotate = new THREE.Vector3();\r\n      if (this.rotating && !this.dualPress) {\r\n        const delta = this.rotating.position.clone().sub(this.rotating.last);\r\n        this.rotating.last.copy(this.rotating.position);\r\n        rotate.set(delta.x, delta.y, 0);\r\n        rotate.multiplyScalar(this.rotateSpeed * (this.reverseRotate ? -1 : 1));\r\n        // Update rotation velocity from last delta\r\n        this.rotateVelocity = rotate.clone().multiplyScalar(1 / deltaTime);\r\n      } else {\r\n        // Continue to rotate with inertia\r\n        this.rotateVelocity.multiplyScalar(\r\n          Math.exp(-deltaTime / this.rotateInertia),\r\n        );\r\n        rotate.addScaledVector(this.rotateVelocity, deltaTime);\r\n      }\r\n\r\n      // Apply rotation in Euler angles space\r\n      const eulers = new THREE.Euler().setFromQuaternion(\r\n        control.quaternion,\r\n        \"YXZ\",\r\n      );\r\n      eulers.y -= rotate.x;\r\n      eulers.x = Math.max(\r\n        -Math.PI / 2,\r\n        Math.min(Math.PI / 2, eulers.x - rotate.y),\r\n      );\r\n      eulers.z *= Math.exp(-DEFAULT_ROLL_SPRING * deltaTime);\r\n      control.quaternion.setFromEuler(eulers);\r\n\r\n      if (this.sliding && !this.dualPress) {\r\n        const delta = this.sliding.position.clone().sub(this.sliding.last);\r\n        this.sliding.last.copy(this.sliding.position);\r\n\r\n        // Slide on plane depending on center/right mouse button\r\n        const slide =\r\n          this.sliding.button !== 2\r\n            ? new THREE.Vector3(delta.x, 0, delta.y)\r\n            : new THREE.Vector3(delta.x, -delta.y, 0);\r\n        slide.multiplyScalar(this.slideSpeed * (this.reverseSlide ? -1 : 1));\r\n\r\n        slide.applyQuaternion(control.quaternion);\r\n        control.position.add(slide);\r\n        // Update movement velocity from last delta\r\n        this.moveVelocity = slide.clone().multiplyScalar(1 / deltaTime);\r\n      } else {\r\n        // Continue to move with inertia\r\n        this.moveVelocity.multiplyScalar(\r\n          Math.exp(-deltaTime / this.moveInertia),\r\n        );\r\n        control.position.addScaledVector(this.moveVelocity, deltaTime);\r\n      }\r\n    }\r\n\r\n    const scroll = this.scroll.multiplyScalar(this.scrollSpeed);\r\n    scroll.set(scroll.x, scroll.z, scroll.y);\r\n    if (this.reverseScroll) {\r\n      scroll.multiplyScalar(-1);\r\n    }\r\n    scroll.applyQuaternion(control.quaternion);\r\n    control.position.add(scroll);\r\n    this.scroll.set(0, 0, 0);\r\n  }\r\n}\r\n"],"names":["_camera","OrthographicCamera","FullscreenTriangleGeometry","BufferGeometry","Float32BufferAttribute","_geometry","FullScreenQuad","material","Mesh","renderer","value","u8","u16","i32","fleb","fdeb","clim","freb","eb","start","b","i","r","j","_a","fl","revfl","_b","fd","rev","x","hMap","cd","mb","l","le","co","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","max","a","bits","d","p","o","bits16","shft","slc","s","ec","err","ind","msg","nt","e","inflt","dat","st","buf","dict","sl","dl","noBuf","resize","noSt","cbuf","bl","nbuf","final","pos","bt","lm","dm","lbt","dbt","tbts","type","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","n","lt","dt","t","lms","dms","lpos","sym","add","dsym","end","shift","dend","et","b2","b4","b8","gzs","flg","zs","Inflate","opts","cb","bts","chunk","inflateSync","data","Gunzip","td","tds","dutf8","strFromU8","latin1","slzh","zh","z","fnl","fn","es","bs","z64e","sc","su","off","unzipSync","files","ze","fltr","c_2","no","wasm","cachedTextDecoder","cachedUint8ArrayMemory0","getUint8ArrayMemory0","getStringFromWasm0","ptr","len","raycast_splats","origin_x","origin_y","origin_z","dir_x","dir_y","dir_z","near","far","num_splats","packed_splats","raycast_ellipsoid","ln_scale_min","ln_scale_max","__wbg_load","module","imports","bytes","instance","__wbg_get_imports","arg0","arg1","arg2","table","offset","__wbg_finalize_init","__wbg_init","module_or_path","LN_SCALE_MIN","LN_SCALE_MAX","SCALE_MIN","SCALE_MAX","LN_SCALE_ZERO","SCALE_ZERO","SPLAT_TEX_WIDTH_BITS","SPLAT_TEX_HEIGHT_BITS","SPLAT_TEX_DEPTH_BITS","SPLAT_TEX_LAYER_BITS","SPLAT_TEX_WIDTH","SPLAT_TEX_HEIGHT","SPLAT_TEX_DEPTH","SPLAT_TEX_MIN_HEIGHT","SPLAT_TEX_WIDTH_MASK","SPLAT_TEX_HEIGHT_MASK","SPLAT_TEX_DEPTH_MASK","WASM_SPLAT_SORT","USE_COMPILED_PARSER_FUNCTION","isBoolType","isScalarType","isIntType","isUintType","isFloatType","isMatFloatType","isAllFloatType","isVector2Type","isVector3Type","isVector4Type","isVectorType","isMat2","isMat3","isMat4","vectorElementType","vectorDim","sameSizeVec","sameSizeUvec","sameSizeIvec","typeLiteral","numberAsInt","numberAsUint","numberAsFloat","valType","val","DynoValue","DynoOutput","dyno","key","DynoLiteral","literal","dynoLiteral","DynoConst","THREE","arg","_","dynoConst","literalZero","typeString","literalOne","literalNegOne","DEFAULT_INDENT","Compilation","indent","Dyno","inTypes","outTypes","inputs","update","globals","statements","generate","outputs","compile","result","declares","name","uniforms","global","dynoDeclare","line","DynoBlock","construct","args","blockInputs","blockOutputs","options","returned","ordering","nodeOuts","visit","node","outKey","outName","outs","input","root","steps","source","newSteps","literalOutputs","step","index","dynoBlock","count","typeStr","unindentLines","seenNonEmpty","lines","trimmedLine","regex","unindent","UnaryOp","outTypeFunc","outType","BinaryOp","TrinaryOp","Gsplat","TPackedSplats","numPackedSplats","packedSplats","NumPackedSplats","readPackedSplat","ReadPackedSplat","readPackedSplatRange","base","ReadPackedSplatRange","splitGsplat","gsplat","SplitGsplat","combineGsplat","flags","center","scales","quaternion","rgba","rgb","opacity","y","g","CombineGsplat","gsplatNormal","GsplatNormal","transformGsplat","scale","rotate","translate","recolor","TransformGsplat","defineGsplat","definePackedSplats","defineReadPackedSplat","active","outGsplat","defineGsplatNormal","outputPackedSplat","rgbMinMaxLnScaleMinMax","OutputPackedSplat","outputRgba8","rgba8","OutputRgba8","output","uniform","DynoUniform","dynoBool","DynoBool","dynoUint","DynoUint","dynoInt","DynoInt","dynoFloat","DynoFloat","dynoBvec2","DynoBvec2","dynoUvec2","DynoUvec2","dynoIvec2","DynoIvec2","dynoVec2","DynoVec2","dynoBvec3","DynoBvec3","dynoUvec3","DynoUvec3","dynoIvec3","DynoIvec3","dynoVec3","DynoVec3","dynoBvec4","DynoBvec4","dynoUvec4","DynoUvec4","dynoIvec4","DynoIvec4","dynoVec4","DynoVec4","dynoMat2","DynoMat2","dynoMat2x2","DynoMat2x2","dynoMat2x3","DynoMat2x3","dynoMat2x4","DynoMat2x4","dynoMat3","DynoMat3","dynoMat3x2","DynoMat3x2","dynoMat3x3","DynoMat3x3","dynoMat3x4","DynoMat3x4","dynoMat4","DynoMat4","dynoMat4x2","DynoMat4x2","dynoMat4x3","DynoMat4x3","dynoMat4x4","DynoMat4x4","dynoUsampler2D","DynoUsampler2D","dynoIsampler2D","DynoIsampler2D","dynoSampler2D","DynoSampler2D","dynoUsampler2DArray","DynoUsampler2DArray","dynoIsampler2DArray","DynoIsampler2DArray","dynoSampler2DArray","DynoSampler2DArray","dynoUsampler3D","DynoUsampler3D","dynoIsampler3D","DynoIsampler3D","dynoSampler3D","DynoSampler3D","dynoUsamplerCube","DynoUsamplerCube","dynoIsamplerCube","DynoIsamplerCube","dynoSamplerCube","DynoSamplerCube","dynoSampler2DShadow","DynoSampler2DShadow","dynoSampler2DArrayShadow","DynoSampler2DArrayShadow","dynoSamplerCubeShadow","DynoSamplerCubeShadow","allGlobals","f32buffer","u32buffer","supportsFloat16Array","f16buffer","u16buffer","normalize","vec","norm","acc","floatBitsToUint","f","uintBitsToFloat","u","toHalf","toHalfNative","toHalfJS","fromHalf","fromHalfNative","fromHalfJS","sign","exp","frac","halfSign","newExp","subFrac","halfFrac","h","f32bits","mant","newFrac","floatToUint8","floatToSint8","Uint8ToFloat","Sint8ToFloat","DataCache","asyncFetch","maxItems","item","mapObject","obj","entries","mapFilterObject","getArrayBuffers","ctx","buffers","seen","traverse","newArray","initFunction","FreeList","allocate","dispose","valid","setPackedSplat","scaleX","scaleY","scaleZ","quatX","quatY","quatZ","quatW","encoding","rgbMin","rgbRange","uR","uG","uB","uA","uQuat","encodeQuatOctXy88R8","tempQuaternion","uQuatX","uQuatY","uQuatZ","lnScaleMin","lnScaleScale","uScaleX","uScaleY","uScaleZ","uCenterX","uCenterY","uCenterZ","i4","setPackedSplatCenter","setPackedSplatScales","setPackedSplatQuat","setPackedSplatRgba","setPackedSplatRgb","setPackedSplatOpacity","packedCenter","packedScales","packedQuaternion","packedColor","packedFields","unpackSplat","word0","word1","word2","word3","uScalesX","uScalesY","uScalesZ","decodeQuatOctXy88R8","getTextureSize","numSplats","width","height","depth","maxSplats","computeMaxSplats","isMobile","isAndroid","isOculus","flipPixels","pixels","tempLine","topOffset","bottomOffset","pixelsToPngUrl","canvas","imageData","cloneClock","clock","newClock","omitUndefined","IDENT_VERTEX_SHADER","averagePositions","positions","sum","position","averageQuaternions","quaternions","coinciDist","matrix1","matrix2","origin1","origin2","direction1","direction2","distance","coincidence","withinDist","maxDistance","withinCoinciDist","minCoincidence","coorientDist","rotate1","rotate2","coorient","withinCoorientDist","minCoorient","epsilonSign","epsilon","encodeQuatXyz888","q","negQuat","iQuatX","iQuatY","iQuatZ","decodeQuatXyz888","encoded","out","dotSelf","tempNormalizedQuaternion","tempAxis","qnorm","theta","xyz_norm","axis","p_x","p_y","tmp","u_f","v_f","quantU","quantV","angleInt","f_x","f_y","f_z","halfTheta","w","encodeQuatEulerXyz888","qNorm","sinr_cosp","cosr_cosp","roll","sinp","pitch","siny_cosp","cosy_cosp","yaw","normRoll","normPitch","normYaw","rollQ","pitchQ","decodeQuatEulerXyz888","yawQ","cr","sr","cp","sp","cy","sy","packSint8Bytes","b0","b1","b3","clampedB0","clampedB1","clampedB2","clampedB3","encodeSh1Rgb","sh1Array","sh1Rgb","sh1Min","sh1Max","sh1Mid","sh1Scale","bitStart","bitEnd","wordStart","bitOffset","firstWord","secondWord","encodeSh2Rgb","sh2Array","sh2Rgb","sh2Min","sh2Max","sh2Mid","sh2Scale","encodeSh3Rgb","sh3Array","sh3Rgb","sh3Min","sh3Max","sh3Mid","sh3Scale","decompressPartialGzip","fileBytes","numBytes","chunks","totalBytes","gunzip","allBytes","CHUNK_SIZE","GunzipReader","chunkBytes","ds","decompressionStream","readerDone","outOffset","DynoProgram","graph","template","getMaterial","updater","DynoProgramTemplate","programMaterial","program","addOutputType","operation","error","subOutputType","mulOutputType","divOutputType","imodOutputType","modOutputType","negOutputType","absOutputType","signOutputType","floorOutputType","ceilOutputType","truncOutputType","roundOutputType","fractOutputType","powOutputType","expOutputType","exp2OutputType","logOutputType","log2OutputType","sqrOutputType","sqrtOutputType","inversesqrtOutputType","minOutputType","maxOutputType","clampOutputType","_c","mixOutputType","stepOutputType","smoothstepOutputType","isNanOutputType","isInfOutputType","Add","sub","Sub","mul","Mul","div","Div","imod","IMod","mod","Mod","modf","Modf","neg","Neg","abs","Abs","Sign","floor","Floor","ceil","Ceil","trunc","Trunc","round","Round","fract","Fract","pow","Pow","Exp","exp2","Exp2","log","Log","log2","Log2","sqr","Sqr","sqrt","Sqrt","inversesqrt","InverseSqrt","min","Min","Max","clamp","Clamp","mix","Mix","edge","Step","smoothstep","edge0","edge1","Smoothstep","isNan","IsNan","isInf","IsInf","and","And","or","Or","xor","Xor","not","Not","lessThan","LessThan","lessThanEqual","LessThanEqual","greaterThan","GreaterThan","greaterThanEqual","GreaterThanEqual","equal","Equal","notEqual","NotEqual","any","Any","all","All","select","cond","Select","compXor","CompXor","aType","bType","compareOutputType","equalOutputType","notEqualOutputType","cType","operator","compXorOutputType","operands","bool","Bool","int","Int","uint","Uint","float","Float","bvec2","BVec2","bvec3","BVec3","bvec4","BVec4","ivec2","IVec2","ivec3","IVec3","ivec4","IVec4","uvec2","UVec2","uvec3","UVec3","uvec4","UVec4","vec2","Vec2","vec3","Vec3","vec4","Vec4","mat2","Mat2","mat3","Mat3","mat4","Mat4","floatBitsToInt","FloatBitsToInt","FloatBitsToUint","intBitsToFloat","IntBitsToFloat","UintBitsToFloat","packSnorm2x16","PackSnorm2x16","unpackSnorm2x16","UnpackSnorm2x16","packUnorm2x16","PackUnorm2x16","unpackUnorm2x16","UnpackUnorm2x16","packHalf2x16","PackHalf2x16","unpackHalf2x16","UnpackHalf2x16","uintToRgba8","UintToRgba8","SimpleCast","length","Length","Distance","dot","Dot","cross","Cross","Normalize","faceforward","FaceForward","reflectVec","incident","normal","ReflectVec","refractVec","eta","RefractVec","split","vector","Split","combine","vectorType","Combine","projectH","ProjectH","extendVec","ExtendVec","swizzle","Swizzle","compMult","CompMult","outer","Outer","transpose","Transpose","determinant","Determinant","inverse","Inverse","projectHOutputType","extendVecOutputType","outerOutputType","transposeOutputType","splitOutTypes","vType","elType","dim","y2","swizzleOutputType","remapIndex","from","to","DynoRemapIndex","pcgMix","PcgMix","pcgNext","state","PcgNext","pcgHash","PcgHash","hash","Hash","hash2","Hash2","hash3","Hash3","hash4","Hash4","hashFloat","HashFloat","hashVec2","HashVec2","hashVec3","HashVec3","hashVec4","HashVec4","normalizedDepth","zNear","zFar","NormalizedDepth","toUint","tempType","toUvec","word","words","transformPos","TransformPosition","transformDir","dir","TransformDir","transformQuat","TransformQuaternion","dynoIf","dynoSwitch","dynoFor","comment","arrayIndex","arrayLength","textureSize","texture","lod","TextureSize","coord","bias","Texture","texelFetch","TexelFetch","textureType","textureSizeType","textureCoordType","textureReturnType","radians","degrees","Radians","Degrees","sin","Sin","cos","Cos","tan","Tan","asin","Asin","acos","Acos","atan","Atan","atan2","Atan2","sinh","Sinh","cosh","Cosh","tanh","Tanh","asinh","Asinh","acosh","Acosh","atanh","Atanh","computeVec4_default","_Readback","buffer","newBuffer","ctor","capacity","reader","computeVec4Template","layerSize","baseIndex","layer","layerBase","layerYEnd","readback","roundedCount","readbackUint8","promises","readbackSize","subReadback","promise","renderState","Readback","_RgbaArray","TRgbaArray","defineRgbaArray","dynoSplats","dynoBase","dynoCount","emptyArray","DynoPackedSplats","RgbaArray","readRgbaArray","SplatEditSdfType","sdfTypeToNumber","SplatEditRgbaBlendMode","rgbaBlendModeToNumber","mode","SplatEditSdf","invert","color","displace","radius","_SplatEdit","rgbaBlendMode","sdfSmooth","softEdge","sdfs","sdf","SplatEdit","SplatEdits","maxSdfs","maxEdits","SdfArray","defineSdfArray","defineEdit","dynoUpdated","updated","tempFloat32","editIndex","sdfFirst","sdfCount","sdfIndex","sdfType","sizes","values","nValues","vBase","edits","total","edit","sdfUpdated","applyGsplatRgbaDisplaceEdits","sdfArray","numEdits","rgbaDisplaceEdits","SplatModifier","modifier","generator","modified","SplatTransformer","transform","newScale","object","SplatGenerator","constructed","_SplatMesh","viewToWorld","worldToView","viewToObject","time","deltaTime","context","globalEdits","PackedSplats","DEFAULT_SPLAT_ENCODING","maybePromise","createRendererDetectionMesh","url","fileType","fileName","constructSplats","splatEncoding","packedSplatsOptions","init_wasm","callback","centers_only","minVec","maxVec","corners","signs","_index","_opacity","_color","sh1Texture","sh2Texture","sh3Texture","rescaleSh","sNorm","minMax","mid","viewCenterInObject","viewDir","sh1Snorm","evaluateSH1","sh2Snorm","evaluateSH2","sh3Snorm","evaluateSH3","recolorRgba","viewToObjectMatrix","newRecolor","editsSdfs","editResult","raycaster","intersects","ray","worldToMesh","worldToMeshRot","origin","direction","distances","point","sh1","newSh1","sh2","newSh2","sh3","newSh3","SplatMesh","defineEvaluateSH1","defineEvaluateSH2","defineEvaluateSH3","EMPTY_GEOMETRY","EMPTY_MATERIAL","mesh","scene","hasSparkRenderer","SparkRenderer","PLY_PROPERTY_TYPES","_PlyReader","decoder","controller","headerTerminator","done","endHeader","headerLen","curElement","lineIndex","fields","elementCallback","elementName","element","properties","createEmptyItem","parseFn","createParseFn","splatCallback","shCallback","isSuperSplat","ssChunks","numSh","sh1Props","sh2Props","sh3Props","prepareSh","num_f_rest","NUM_SH_TO_NUM_F_REST","k","ssShCallback","sh","initSuperSplat","min_x","min_y","min_z","max_x","max_y","max_z","min_scale_x","min_scale_y","min_scale_z","max_scale_x","max_scale_y","max_scale_z","min_r","min_g","min_b","max_r","max_g","max_b","decodeSuperSplat","getNumSh","packed_position","packed_rotation","packed_scale","packed_color","SQRT2","r0","r1","r2","rr","rOrder","scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","f_dc_0","f_dc_1","f_dc_2","red","green","blue","alpha","hasScales","hasRots","alphaDiv","FIELD_SCALE","redDiv","greenDiv","blueDiv","op","SH_C0","parsers","rgbaOffset","isVertex","propertyName","property","PARSE_FIELD","FIELD_BYTES","component","SET_FIELD","parser","PlyReader","littleEndian","NUM_F_REST_TO_NUM_SH","F_REST_REGEX","safeToCompile","createCompiledParserFn","createDynamicParserFn","UNSAFE_EVAL_ALLOWED","PROPERTY_NAME_REGEX","parserSrc","fRestMatch","fRestIndex","list","currentOffset","parserIndex","SplatWorker","BundledWorker","event","id","resolve","reject","handler","maxWorkers","numWorkers","freeWorkers","workerQueue","allocWorker","worker","freeWorker","waiter","withWorker","SplatLoader","Loader","manager","FileLoader","onLoad","onProgress","onError","resolvedURL","headers","credentials","request","fetchWithProgress","progresses","updateProgresses","lengthComputable","loaded","extraFiles","pcSogsJson","tryPcSogs","prop","file","fileUrl","progressIndex","progress","decoded","unpackSplats","response","contentLength","SplatFileType","getSplatFileType","view","header","tryPcSogsZip","getFileExtension","pathOrUrl","noTrailing","lastSlash","filename","lastDot","getSplatFileTypeFromPath","extension","isPcSogs","text","json","isVersion2","metaFilename","unzipped","splatFileType","ply","packedArray","extra","SplatData","targetSplats","newCenters","newScales","newQuaternions","newOpacities","newColors","computeUvec4_default","_PackedSplats","_d","loader","unpacked","targetSize","currentSize","level","wordsPerSplat","splatCounts","mapping","rounded","computeUvec4Template","nextBase","layerYStart","_f","_e","_h","_g","_j","_i","SplatGeometry","activeSplats","QUAD_VERTICES","QUAD_INDICES","_SparkViewpoint","doubleBuffer","superXY","autoUpdate","camera","forceOrigin","originToWorld","accumulator","target","newCam","byteSize","subWidth","subHeight","subSize","superPixels","super2","row","superCol","superRow","sx","superIndex","pixelIndex","needsSort","displayed","mappingVersion","latestView","doubleSortReader","sort32Reader","dynoSortRadial","dynoOrigin","dynoDirection","dynoDepthBias","dynoSort360","sort32","halfMaxSplats","worldToOrigin","viewToOrigin","sortReader","rpcName","oldOrdering","sortParams","index2","gsplat0","metric0","computeSortMetric","gsplat1","metric1","combined","metric","SparkViewpoint","defineComputeSortMetric","sortRadial","sortOrigin","sortDirection","sortDepthBias","sort360","SplatAccumulator","generators","forceUpdate","map","record","version","current","modGenerator","other","otherNode","otherBase","otherCount","splatDefines_default","splatFragment_default","splatVertex_default","shaders","getShaders","splatDefines","splatVertex","splatFragment","MAX_ACCUMULATORS","_SparkRenderer","premultipliedAlpha","frame","isNewFrame","viewpoint","cameras","averageOriginToWorlds","renderSize","baseLayer","typedCamera","enable","multiply","accumToWorld","worldToCamera","geometry","activeMapping","visibleGenerators","visibleGenHash","originUpdate","needsUpdate","originChanged","genOrder","gIndex","lastGen","_version","_seq","newGenerators","hasCorrespondence","ancestor","worldCenter","size","hideObjects","objectVisibility","visible","envMap","originToWorlds","matrix","decodeAntiSplat","initNumSplats","f32","i8","KSPLAT_COMPRESSION","KSPLAT_SH_DEGREE_TO_COMPONENTS","decodeKsplat","headerOffset","versionMajor","versionMinor","maxSectionCount","compressionLevel","minSphericalHarmonicsCoeff","maxSphericalHarmonicsCoeff","sectionBase","section","getSh","splatOffset","sphericalHarmonicsOffsetBytes","sectionSplatCount","sectionMaxSplatCount","bucketSize","bucketCount","bucketBlockSize","bucketStorageSizeBytes","compressionScaleRange","fullBucketCount","fullBucketSplats","partiallyFilledBucketCount","bucketsMetaDataSizeBytes","bucketsStorageSizeBytes","sphericalHarmonicsDegree","shComponents","bytesPerCenter","bytesPerScale","bytesPerRotation","bytesPerColor","bytesPerSphericalHarmonicsComponent","scaleOffsetBytes","rotationOffsetBytes","colorOffsetBytes","bytesPerSplat","splatDataStorageSizeBytes","storageSizeBytes","sh1Index","sh2Index","sh3Index","compressionScaleFactor","bucketsBase","dataBase","bucketArray","partiallyFilledBucketLengths","partialBucketIndex","partialBucketBase","bucketIndex","bucketLength","SpzReader","centerCallback","alphaCallback","rgbCallback","scalesCallback","quatCallback","centerBytes","centerUint16","i3","fixed","i9","rgbBytes","scalesBytes","maxValue","quatBytes","combinedValues","valueMask","largestIndex","remainingValues","sumSquares","square","shBytes","SH_DEGREE_TO_VECS","SPZ_MAGIC","SPZ_VERSION","FLAG_ANTIALIASED","SpzWriter","shDegree","fractionalBits","flagAntiAlias","splatSize","bufferSize","xRounded","xInt","yRounded","yInt","zRounded","zInt","quat","iLargest","negate","comp","negbit","mag","quantized","shVecs","base1","base2","base3","compressed","transcodeSpz","splats","clipXyz","maxSh","opacityThreshold","transformScales","transformQuaternion","withinClip","clip","withinOpacity","lastIndex","spz","centers","SplatSkinning","GsplatSkinning","defineGsplatSkinning","applyGsplatSkinning","boneIndex","i16","origQuat","origPos","relQuat","relPos","dual","splatIndex","boneIndices","weights","defineApplyGsplatSkinning","skinning","constructGrid","extents","stepSize","pointRadius","pointShadowScale","pointColor","constructAxes","axisRadius","axisShadowScale","origins","constructSpherePoints","maxDepth","filter","pointThickness","pointsHash","addPoint","recurse","p0","p1","p2","p01","p12","p20","points","textSplats","font","fontSize","dotRadius","textAlign","lineHeight","objectScale","metrics","fontHeight","minLeft","maxRight","minTop","maxBottom","originLeft","originTop","imageSplats","subXY","forEachSplat","img","destWidth","destHeight","push","maybeOpacity","staticBox","box","cells","dotScale","dynoX","dynoY","dynoTime","cellX","cellY","cellZ","cell","intTime","random","transformer","DEFAULT_SNOW","DEFAULT_RAIN","snowBox","minY","density","anisoScale","minScale","maxScale","fallDirection","fallVelocity","wanderScale","wanderVariance","color1","color2","onFrame","volume","dynoMinScale","dynoMaxScale","dynoAnisoScale","dynoFallDirection","dynoFallVelocity","dynoWanderScale","dynoWanderVariance","dynoColor1","dynoColor2","dynoOpacity","globalOffset","dynoMin","dynoMax","dynoMinY","snow","randomW","intensity","hue","random2","perturb","timeOffset","modulo","centerY","fallDelta","makeNormalColorModifier","splatToView","viewGsplat","viewCenter","viewNormal","splatDot","sameDir","setWorldNormalColor","makeDepthColorModifier","minDepth","reverse","setDepthColor","dynoMinDepth","dynoMaxDepth","dynoReverse","_VRButton","sessionInit","navigatorXr","xr","button","showEnterVR","currentSession","onSessionStarted","session","onSessionEnded","sessionOptions","disableButton","showWebXRNotFound","showVRNotAllowed","exception","stylizeElement","supported","VRButton","DEFAULT_MOVE_INERTIA","DEFAULT_ROTATE_INERTIA","TOUCH_BIAS","JointEnum","JOINT_IDS","NUM_JOINTS","JOINT_INDEX","JOINT_RADIUS","JOINT_SEGMENTS","JOINT_SEGMENT_STEPS","JOINT_TIPS","FINGER_TIPS","Hand","HANDS","XrHands","xrFrame","xrSession","referenceSpace","inputSource","hand","jointId","jointSpace","jointPose","orientation","Vector3","Quaternion","Color","CYCLE","handedness","xrHand","segment","segmentSplats","lastSegment","jointA","jointB","radiusA","radiusB","handA","handB","last","hA","hB","jA","jB","HandMovement","xrHands","control","moveInertia","rotateInertia","grip","lastMid","delta","angle","lastAngle","closestAngle","rotateVelocity","blend","negPivot","Matrix4","DEFAULT_MOVEMENT_SPEED","DEFAULT_ROLL_SPEED","DEFAULT_ROTATE_SPEED","DEFAULT_SLIDE_SPEED","DEFAULT_SCROLL_SPEED","DEFAULT_STICK_THRESHOLD","DEFAULT_FPS_ROTATE_SPEED","DEFAULT_POINTER_ROLL_SCALE","DUAL_PRESS_MS","DOUBLE_PRESS_LIMIT_MS","DOUBLE_PRESS_DISTANCE","WASD_KEYCODE_MOVE","ARROW_KEYCODE_MOVE","QE_KEYCODE_ROTATE","ARROW_KEYCODE_ROTATE","SparkControls","FpsMovement","PointerControls","moveSpeed","rollSpeed","stickThreshold","rotateSpeed","keycodeMoveMapping","keycodeRotateMapping","gamepadMapping","capsMultiplier","shiftMultiplier","ctrlMultiplier","sticks","gamepad","gamepadButtons","xrSources","stick","keycode","rot","eulers","moveVector","move","speedMultiplier","slideSpeed","scrollSpeed","swapRotateSlide","reverseRotate","reverseSlide","reverseSwipe","reverseScroll","pointerRollScale","doublePress","initial","isRotate","pointerId","timeStamp","pointerUp","lastUp","intervalMs","rect","motion","totalMotion","slide","deltaDir","deltaDist","orthoDir","motionDir","motionOrtho","midpoint","midpointDir","ndcMidpoint","pinchOut","angles","scroll"],"mappings":"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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAAC,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAAC,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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","x_google_ignoreList":[0,1]}