<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spark • Gravity Bounce Effect</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      width: 100%;
      background-color: black;
      overflow: hidden;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      outline: none;
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas" tabindex="0"></canvas>
  <script type="importmap">
    {
      "imports": {
        "three": "/examples/js/vendor/three/build/three.module.js",
        "three/addons/": "/examples/js/vendor/three/examples/jsm/",
        "lil-gui": "/examples/js/vendor/lil-gui/dist/lil-gui.esm.js",
        "@sparkjsdev/spark": "/dist/spark.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from "three";
    import { SplatMesh, SparkRenderer, dyno, SparkControls, textSplats } from "@sparkjsdev/spark";
    import { GUI } from "lil-gui";
    import { getAssetFileURL } from "/examples/js/get-asset-url.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

    // Setup canvas and renderer
    const canvas = document.getElementById("canvas");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(new THREE.Color(0x111111), 1);

    // Setup scene
    const scene = new THREE.Scene();
    
    // Setup Spark renderer
    const spark = new SparkRenderer({ renderer });
    scene.add(spark);

    // Setup camera
    const camera = new THREE.PerspectiveCamera(
      60, 
      window.innerWidth / window.innerHeight, 
      0.1, 
      1000
    );
    camera.position.set(0, 2.5, 7);
    camera.lookAt(0, 1, 0);

    // Setup controls
    const controls = new SparkControls({ canvas: renderer.domElement });
    controls.fpsMovement.moveSpeed = 3.0;

    // Setup lighting for the table
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6); // soft white light
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    directionalLight.position.set(5, 10, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.camera.left = -10;
    directionalLight.shadow.camera.right = 10;
    directionalLight.shadow.camera.top = 10;
    directionalLight.shadow.camera.bottom = -10;
    scene.add(directionalLight);

    // Enable shadows in renderer
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Animation time
    const animationTime = dyno.dynoFloat(0.0);
    const dropStartTime = dyno.dynoFloat(0.0);  // Time when drop animation started
    
    // Transition state management
    const transitionState = {
      isTransitioning: false,
      transitionTime: 0.0,
      transitionDuration: 3.0, // Total duration for one complete transition
      birthDuration: 0.5, // How long birth effect takes (much faster!)
      cycleDuration: 1.0, // Fixed transition timing
    };
    
    // Effect parameters
    const effectParams = {
      dropProgress: 0.0,        // 0 = normal, 1 = dropped and bouncing
      gravity: 9.8,             // gravity strength
      bounceDamping: 0.4,       // bounce damping (0-1)
      floorLevel: 0.0,          // floor Y position
      randomFactor: 1.0,        // randomness in drop timing
      reformSpeed: 2.0,         // speed of reformation
      // cycleDuration removed - using transitionState.cycleDuration instead
      isDropped: false,         // state: dropped or intact
      spaceToDisassemble: true, // enable spacebar to drop
      dropTime: 0.0,           // actual time since drop started
      friction: 0.98,          // air friction coefficient (0-1, closer to 1 = less friction)
      shrinkSpeed: 3.0,         // particle lifetime (inverted: 5.0 - 3.0 = 2.0 actual shrink speed)
      explosionStrength: 4.5,   // initial upward explosion intensity
      isReforming: false,       // state: reforming back to original
      reformTime: 0.0,          // time since reform started
      reformDuration: 2.0       // how long reform animation takes
    };

    // Dynamic uniforms
    const uDropProgress = dyno.dynoFloat(effectParams.dropProgress);
    const uGravity = dyno.dynoFloat(effectParams.gravity);
    const uBounceDamping = dyno.dynoFloat(effectParams.bounceDamping);
    const uFloorLevel = dyno.dynoFloat(effectParams.floorLevel);
    const uRandomFactor = dyno.dynoFloat(effectParams.randomFactor);
    const uReformSpeed = dyno.dynoFloat(effectParams.reformSpeed);
    const uCycleDuration = dyno.dynoFloat(transitionState.cycleDuration);
    const uDropTime = dyno.dynoFloat(effectParams.dropTime);
    const uFriction = dyno.dynoFloat(effectParams.friction);
    const uShrinkSpeed = dyno.dynoFloat(5.0 - effectParams.shrinkSpeed); // Inverted logic
    const uExplosionStrength = dyno.dynoFloat(effectParams.explosionStrength);
    const uIsReforming = dyno.dynoFloat(0.0);
    const uReformTime = dyno.dynoFloat(0.0);
    const uReformDuration = dyno.dynoFloat(effectParams.reformDuration);

    // Birth effect uniforms
    const uIsBirthing = dyno.dynoFloat(0.0);
    const uBirthTime = dyno.dynoFloat(0.0);
    const uBirthDuration = dyno.dynoFloat(transitionState.birthDuration);

    // Create death effect dynoshader (explosion/dispersal)
    function createDeathDynoshader() {
      return dyno.dynoBlock(
        { gsplat: dyno.Gsplat },
        { gsplat: dyno.Gsplat },
        ({ gsplat }) => {
          const physicsShader = new dyno.Dyno({
            inTypes: { 
              gsplat: dyno.Gsplat, 
              time: "float",
              dropTime: "float",
              dropProgress: "float",
              gravity: "float",
              bounceDamping: "float",
              floorLevel: "float",
              randomFactor: "float",
              reformSpeed: "float",
              cycleDuration: "float",
              friction: "float",
              shrinkSpeed: "float",
              explosionStrength: "float",
              isReforming: "float",
              reformTime: "float",
              reformDuration: "float"
            },
            outTypes: { gsplat: dyno.Gsplat },
            globals: () => [dyno.unindent(`
              // Función para rotar en 2D
              mat2 rot(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat2(c, -s, s, c);
              }
              // Simple hash function for per-splat randomness
              float hash(vec3 p) {
                return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
              }
              
              // Smooth step function for easing
              float smoothstep3(float edge0, float edge1, float x) {
                float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
                return t * t * (3.0 - 2.0 * t);
              }
              
              // Physics simulation with smooth analytical approach
              vec3 simulatePhysics(vec3 originalPos, float dropTime, float progress, float gravity, float damping, float floorLevel, float randomOffset, float friction, float explosionStrength) {
                if (progress <= 0.0) return originalPos;
                
                // Add per-particle variation to break uniformity
                float timeVariation = hash(originalPos + vec3(42.0)) * 0.2 - 0.1; // -0.1 to +0.1
                float adjustedTime = max(0.0, dropTime + timeVariation);
                
                // Initial explosion velocity with more variation
                vec3 initialVelocity = vec3(
                  (hash(originalPos + vec3(1.0)) - 0.5) * explosionStrength * (0.3 + hash(originalPos + vec3(10.0)) * 0.4),  // varied X
                  abs(hash(originalPos + vec3(3.0))) * explosionStrength * (0.8 + hash(originalPos + vec3(20.0)) * 0.4) + 0.5, // varied Y
                  (hash(originalPos + vec3(2.0)) - 0.5) * explosionStrength * (0.3 + hash(originalPos + vec3(30.0)) * 0.4)   // varied Z
                );
                
                // Smooth analytical physics without discrete steps
                float t = adjustedTime;
                
                // Apply friction decay smoothly
                float frictionDecay = pow(friction, t * 60.0);
                vec3 currentVelocity = initialVelocity * frictionDecay;
                
                // Analytical position calculation
                vec3 position = originalPos;
                position.x += initialVelocity.x * (1.0 - frictionDecay) / (1.0 - friction) / 60.0;
                position.z += initialVelocity.z * (1.0 - frictionDecay) / (1.0 - friction) / 60.0;
                position.y += initialVelocity.y * t - 0.5 * gravity * t * t;
                
                // Enhanced floor collision with bouncing
                if (position.y <= floorLevel) {
                  // Calculate bounce height based on damping
                  float bounceTime = t;
                  float bounceCount = floor(bounceTime * 3.0); // Bounce frequency
                  float timeSinceBounce = bounceTime - bounceCount / 3.0;
                  
                  // Bounce height decreases with each bounce
                  float bounceHeight = initialVelocity.y * pow(damping, bounceCount) * max(0.0, 1.0 - timeSinceBounce * 3.0);
                  
                  if (bounceHeight > 0.1) {
                    // Still bouncing
                    position.y = floorLevel + abs(sin(timeSinceBounce * 3.14159 * 3.0)) * bounceHeight;
                  } else {
                    // Settled on floor
                  position.y = floorLevel;
                    // Add some scatter when finally settled
                    float scatterFactor = hash(originalPos + vec3(50.0)) * 0.2;
                  position.x += (hash(originalPos + vec3(60.0)) - 0.5) * scatterFactor;
                  position.z += (hash(originalPos + vec3(70.0)) - 0.5) * scatterFactor;
                  }
                }
                
                return position;
              }
              
              // Elegant reform animation with smooth easing
              vec3 elegantReform(vec3 currentPos, vec3 originalPos, float reformTime, float duration) {
                if (reformTime <= 0.0) return currentPos;
                if (reformTime >= duration) return originalPos;
                
                // Simple linear progress for now to debug
                float progress = reformTime / duration;
                
                return mix(currentPos, originalPos, progress);
              }
              
              // Scale reform animation
              vec3 reformScale(vec3 currentScale, vec3 originalScale, float reformTime, float duration) {
                if (reformTime <= 0.0) return currentScale;
                if (reformTime >= duration) return originalScale;
                
                float progress = reformTime / duration;
                float easeOut = 1.0 - pow(1.0 - progress, 2.0); // ease-out quadratic
                
                return mix(currentScale, originalScale, easeOut);
              }
            `)],
            statements: ({ inputs, outputs }) => dyno.unindentLines(`
              ${outputs.gsplat} = ${inputs.gsplat};
              
              vec3 originalPos = ${inputs.gsplat}.center;
              vec3 originalScale = ${inputs.gsplat}.scales;
              
              // Calculate physics position if dropped
              vec3 physicsPos = originalPos;
              vec3 currentScale = originalScale;
              
              if (${inputs.dropProgress} > 0.0) {
                // Calculate per-splat random offset based on position
                float randomOffset = hash(originalPos) * ${inputs.randomFactor};
                
                // Always calculate physics position to know current state
                physicsPos = simulatePhysics(
                  originalPos, 
                  ${inputs.dropTime}, 
                  ${inputs.dropProgress}, 
                  ${inputs.gravity}, 
                  ${inputs.bounceDamping}, 
                  ${inputs.floorLevel}, 
                  randomOffset,
                  ${inputs.friction},
                  ${inputs.explosionStrength}
                );
                
                // Apply rotation only when not reforming
//                if (${inputs.isReforming} < 0.5) {
                  //physicsPos.xz *= rot(${inputs.time} * 0.3);
//                }
                
                // Uniform circular shrinking of splat scales while dropped
                float factor = exp(-${inputs.dropTime} * ${inputs.shrinkSpeed});
                currentScale = mix(originalScale, vec3(0.005), 1.0 - factor);
              }
              
              // Apply elegant reform animation if reforming
              vec3 finalPos = physicsPos;
              vec3 finalScale = currentScale;
              
              if (${inputs.isReforming} > 0.5) {
                // Simple reform without offset for debugging
                finalPos = elegantReform(physicsPos, originalPos, ${inputs.reformTime}, ${inputs.reformDuration});
                finalScale = reformScale(currentScale, originalScale, ${inputs.reformTime}, ${inputs.reformDuration});
              }
              
              ${outputs.gsplat}.center = finalPos;
              ${outputs.gsplat}.scales = finalScale;
              
              // Optional: Fade effect during fall (disabled to prevent disappearing)
              // float fallDistance = abs(finalPos.y - originalPos.y);
              // float alpha = ${inputs.gsplat}.rgba.a * (1.0 - clamp(fallDistance * 0.1, 0.0, 0.3));
              // ${outputs.gsplat}.rgba.a = alpha;
            `),
          });
          
          gsplat = physicsShader.apply({ 
            gsplat, 
            time: animationTime,
            dropTime: uDropTime,
            dropProgress: uDropProgress,
            gravity: uGravity,
            bounceDamping: uBounceDamping,
            floorLevel: uFloorLevel,
            randomFactor: uRandomFactor,
            reformSpeed: uReformSpeed,
            cycleDuration: uCycleDuration,
            friction: uFriction,
            shrinkSpeed: uShrinkSpeed,
            explosionStrength: uExplosionStrength,
            isReforming: uIsReforming,
            reformTime: uReformTime,
            reformDuration: uReformDuration
          }).gsplat;
          
          return { gsplat };
        }
      );
    }

    // Create birth effect dynoshader (emergence from origin)
    function createBirthDynoshader() {
      return dyno.dynoBlock(
        { gsplat: dyno.Gsplat },
        { gsplat: dyno.Gsplat },
        ({ gsplat }) => {
          const birthShader = new dyno.Dyno({
            inTypes: { 
              gsplat: dyno.Gsplat, 
              time: "float",
              isBirthing: "float",
              birthTime: "float",
              birthDuration: "float"
            },
            outTypes: { gsplat: dyno.Gsplat },
            globals: () => [dyno.unindent(`
              // Simple hash function for per-splat randomness
              float hash(vec3 p) {
                return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
              }
              
              // Smooth step function for easing
              float smoothstep3(float edge0, float edge1, float x) {
                float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
                return t * t * (3.0 - 2.0 * t);
              }
            `)],
            statements: ({ inputs, outputs }) => dyno.unindentLines(`
              ${outputs.gsplat} = ${inputs.gsplat};
              
              vec3 originalPos = ${inputs.gsplat}.center;
              vec3 originalScale = ${inputs.gsplat}.scales;
              
              // Birth effect: grow from origin to final position
              if (${inputs.isBirthing} > 0.5 && ${inputs.birthTime} < ${inputs.birthDuration}) {
                // Calculate birth progress (0 to 1)
                float progress = ${inputs.birthTime} / ${inputs.birthDuration};
                
                // Reduced timing variation for more synchronized birth
                float birthOffset = hash(originalPos) * 0.1; // 0-0.1 second offset (reduced)
                float adjustedProgress = clamp((progress - birthOffset / ${inputs.birthDuration}) / (1.0 - birthOffset / ${inputs.birthDuration}), 0.0, 1.0);
                
                // Accelerated easing for faster growth
                float easeProgress = adjustedProgress * adjustedProgress * (3.0 - 2.0 * adjustedProgress);
                easeProgress = pow(easeProgress, 0.6); // Power curve for faster acceleration
                
                // Position: interpolate from origin to final position
                vec3 birthPos = mix(vec3(0.0, 0.0, 0.0), originalPos, easeProgress);
                
                // Scale: grow from 0 to original size
                vec3 birthScale = mix(vec3(0.0, 0.0, 0.0), originalScale, easeProgress);
                
                // Reduced randomness for cleaner, faster effect
                float randFactor = hash(originalPos + vec3(42.0)) * 0.05;
                birthPos += (hash(originalPos + vec3(10.0, 20.0, 30.0)) - 0.5) * randFactor * (1.0 - easeProgress);
                
                ${outputs.gsplat}.center = birthPos;
                ${outputs.gsplat}.scales = birthScale;
                
                // Fade in alpha faster
                float alpha = ${inputs.gsplat}.rgba.a * easeProgress;
                ${outputs.gsplat}.rgba.a = alpha;
              }
            `),
          });
          
          gsplat = birthShader.apply({ 
            gsplat, 
            time: animationTime,
            isBirthing: uIsBirthing,
            birthTime: uBirthTime,
            birthDuration: uBirthDuration
          }).gsplat;
          
          return { gsplat };
        }
      );
    }

    let splatMeshes = {}; // Store multiple splat meshes
    let currentSplatName = 'penguin'; // Track which splat is currently active
    let nextSplatName = 'cat'; // Track which splat will be born next
    let tableMeshRef = null;
    let totalTime = 0; // Timer for auto-transitions
    
    // Transition control parameters
    const transitionParams = {
      autoTransition: false,
      currentSplat: currentSplatName,
      manualTransition: () => {
        if (!transitionState.isTransitioning) {
          startTransition();
          totalTime = 0; // Reset cycle timer
        }
      }
    };

    // Load and setup multiple splats
    async function loadSplats() {
      const splatNames = ['penguin.spz', 'cat.spz', 'woobles.spz'];
      const loadPromises = [];
      
      for (const splatName of splatNames) {
        const loadPromise = (async () => {
          try {
            const splatURL = await getAssetFileURL(splatName);
        const splatMesh = new SplatMesh({ url: splatURL });
        
            // Get splat name key
            const nameKey = splatName.replace('.spz', '');
            
            // All splats start with death shader (they can switch dynamically)
            splatMesh.worldModifier = createDeathDynoshader();
        splatMesh.updateGenerator();
        
        // Position the splat
        splatMesh.position.set(0, 0, 0);
        splatMesh.rotation.set(Math.PI, 0, 0);
        
        // Scale: woobles is bigger
        if (nameKey === 'woobles') {
          splatMesh.scale.set(1.7, 2.0, 1.7);
        } else {
        splatMesh.scale.set(1, 1, 1);
        }
            
            // Hide by default, show only the current one
            splatMesh.visible = (nameKey === currentSplatName);
        
        scene.add(splatMesh);
            splatMeshes[nameKey] = splatMesh;
        
            console.log(`${nameKey} splat loaded:`, splatURL);
        return splatMesh;
      } catch (error) {
            console.error(`Error loading ${splatName}:`, error);
            return null;
          }
        })();
        
        loadPromises.push(loadPromise);
      }
      
      await Promise.all(loadPromises);
      console.log("All splats loaded:", Object.keys(splatMeshes));
      return splatMeshes;
    }

    // Function to switch between splats
    function switchToSplat(splatName) {
      // Hide all splats
      Object.values(splatMeshes).forEach(mesh => {
        if (mesh) mesh.visible = false;
      });
      
      // Show the requested splat
      if (splatMeshes[splatName]) {
        splatMeshes[splatName].visible = true;
        currentSplatName = splatName;
        console.log(`Switched to ${splatName}`);
      } else {
        console.warn(`Splat ${splatName} not found`);
      }
    }

    // Get current active splat mesh
    function getCurrentSplatMesh() {
      return splatMeshes[currentSplatName];
    }

    // Get next splat name in sequence
    function getNextSplatName(current) {
      const splatOrder = ['penguin', 'cat', 'woobles'];
      const currentIndex = splatOrder.indexOf(current);
      return splatOrder[(currentIndex + 1) % splatOrder.length];
    }


    // Start explosion (death effect)
    function startExplosion() {
      if (transitionState.isTransitioning) return;
      
      transitionState.isTransitioning = true;
      transitionState.transitionTime = 0.0;
      
      console.log(`Explosion started: ${currentSplatName}`);
      
      // Show only the current splat; hide all others to avoid overlaps
      Object.entries(splatMeshes).forEach(([name, mesh]) => {
        if (mesh) mesh.visible = (name === currentSplatName);
      });

      // Ensure the current splat uses the death shader so it responds to drop uniforms
      if (splatMeshes[currentSplatName]) {
        splatMeshes[currentSplatName].worldModifier = createDeathDynoshader();
        splatMeshes[currentSplatName].updateGenerator();
      }

      // Reset and start death effect on current splat
      effectParams.isDropped = true;
      effectParams.dropProgress = 1.0;
      effectParams.dropTime = 0.0;
      effectParams.isReforming = false;
      uDropProgress.value = 1.0;
      uDropTime.value = 0.0;
      uIsReforming.value = 0.0;
    }

    // Manual transition function
    function startTransition() {
      // Start explosion and birth simultaneously
      startExplosion();
      
      // Start birth effect on next splat
      nextSplatName = getNextSplatName(currentSplatName);
      console.log(`Starting transition: ${currentSplatName} → ${nextSplatName}`);
      
      if (splatMeshes[nextSplatName]) {
        // Hide other non-participating splats for this cycle
        Object.entries(splatMeshes).forEach(([name, mesh]) => {
          if (!mesh) return;
          if (name !== currentSplatName && name !== nextSplatName) {
            mesh.visible = false;
          }
        });

        // Switch its shader to birth mode
        splatMeshes[nextSplatName].worldModifier = createBirthDynoshader();
        splatMeshes[nextSplatName].updateGenerator();
        
        // Make it visible and start birth
        splatMeshes[nextSplatName].visible = true;
        uIsBirthing.value = 1.0;
        uBirthTime.value = 0.0;
        
        console.log(`Birth started for: ${nextSplatName}`);
      }
    }

    // Complete transition
    function completeTransition() {
      // Keep the old splat visible so settled particles remain until next cycle
      // Don't reset death effect - keep particles on table until next explosion

      // Complete birth effect (stop birthing)
      uIsBirthing.value = 0.0;
      uBirthTime.value = 0.0;
      // Do NOT reset global drop state here; do NOT switch new splat to death shader yet
      
      // Update current splat
      currentSplatName = nextSplatName;
      transitionState.isTransitioning = false;
      transitionState.transitionTime = 0.0;
      
      // Update GUI
      transitionParams.currentSplat = currentSplatName;
      
      console.log(`Transition complete. New active splat: ${currentSplatName}`);
    }

    // Load and setup table
    async function loadTable() {
      try {
        const tableURL = await getAssetFileURL("table.glb");
        const loader = new GLTFLoader();
        
        return new Promise((resolve, reject) => {
          loader.load(tableURL, (gltf) => {
            const tableModel = gltf.scene;
            
            // Position the table below the splat
            tableModel.position.set(0, -0.5, 0);
            tableModel.scale.set(3.5, 3.5, 3.5);
            tableModel.rotation.set(0, 0, 0);
            
            // Add shadows if needed
            tableModel.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
            
            scene.add(tableModel);
            tableMeshRef = tableModel;
            
            console.log("Table loaded:", tableURL);
            resolve(tableModel);
          }, undefined, (error) => {
            console.error("Error loading table:", error);
            reject(error);
          });
        });
      } catch (error) {
        console.error("Error loading table:", error);
      }
    }

    // Add instructional text
    function addInstructionalText() {
      const instructionsText = textSplats({
        text: "WASD + mouse to move\nSPACEBAR: Explosion!",
        font: "Arial",
        fontSize: 24,
        color: new THREE.Color(0xFFFFFF), // White
        textAlign: "center",
        lineHeight: 1.3
      });
      
      // Scale and position the text above the table, much closer to camera
      instructionsText.scale.setScalar(0.15 / 24);
      instructionsText.position.set(0, 0.2, 2.5); // Above table, much closer to camera
      instructionsText.rotation.set(0, 0, 0);
      
      scene.add(instructionsText);
      console.log("Instructions text added");
    }

    // Handle window resize
    function handleResize() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }

    window.addEventListener('resize', handleResize);

    // Spacebar to force next cycle (works anytime, cancels current animation)
    function handleSpacebarPress() {
      console.log("Spacebar pressed - forcing next cycle!");
      
      // If currently transitioning, complete it immediately
      if (transitionState.isTransitioning) {
        console.log("Canceling current transition");
        completeTransition();
      }
      
      // Force start new transition
      startTransition();
      totalTime = 0; // Reset auto timer
    }


    // Add keyboard event listener
    window.addEventListener('keydown', (event) => {
      if (event.code === 'Space') {
        event.preventDefault(); // Prevent page scroll
        handleSpacebarPress();
      }
    });

    // Animation loop
    let lastTime = 0;
    renderer.setAnimationLoop((timeMs) => {
      const t = timeMs / 1000.0;
      const dt = t - (lastTime || t);
      lastTime = t;
      totalTime += dt;

      // Update animation time
      animationTime.value = t;
      
      // Auto-transition system
      if (transitionParams.autoTransition) {
        // Check if it's time for transition
        if (!transitionState.isTransitioning && totalTime >= transitionState.cycleDuration) {
          console.log(`Auto transition trigger: totalTime=${totalTime.toFixed(2)}, cycleDuration=${transitionState.cycleDuration}`);
          startTransition();
          totalTime = 0;
        }
      }
      
      // Update transition if currently transitioning
      if (transitionState.isTransitioning) {
        // Update transition time
        transitionState.transitionTime += dt;
        
        // Update birth time
        uBirthTime.value = transitionState.transitionTime;
        
        // Check if transition is complete
        if (transitionState.transitionTime >= transitionState.transitionDuration) {
          completeTransition();
        }
      }
      
      // Update drop time only when dropped
      if (effectParams.isDropped && !effectParams.isReforming) {
        effectParams.dropTime += dt;
        uDropTime.value = effectParams.dropTime;
      }
      
      // Update reform time and complete reform when done
      if (effectParams.isReforming) {
        effectParams.reformTime += dt;
        uReformTime.value = effectParams.reformTime;
        
        // Debug log
        if (Math.floor(effectParams.reformTime * 10) % 5 === 0) {
          console.log(`Reforming: time=${effectParams.reformTime.toFixed(2)}, duration=${effectParams.reformDuration}, progress=${(effectParams.reformTime/effectParams.reformDuration*100).toFixed(1)}%`);
        }
        
        // Complete reform when animation is done
        if (effectParams.reformTime >= effectParams.reformDuration) {
          effectParams.isDropped = false;
          effectParams.dropProgress = 0.0;
          effectParams.isReforming = false;
          effectParams.reformTime = 0.0;
          effectParams.dropTime = 0.0;
          uDropProgress.value = 0.0;
          uIsReforming.value = 0.0;
          uReformTime.value = 0.0;
          uDropTime.value = 0.0;
          console.log("Reform complete!");
        }
      }
      
      // Force update when uniforms change
      if (transitionState.isTransitioning) {
        // Update both dying and birthing splats during transition
        if (splatMeshes[currentSplatName]) {
          splatMeshes[currentSplatName].updateVersion();
        }
        if (splatMeshes[nextSplatName]) {
          splatMeshes[nextSplatName].updateVersion();
        }
      } else {
        // Update only current splat when not transitioning
        const currentMesh = getCurrentSplatMesh();
        if (currentMesh) {
          currentMesh.updateVersion();
        }
      }

      controls.update(camera);
      renderer.render(scene, camera);
    });

    // GUI for effect parameters
    const gui = new GUI();
    
    
    // All controls directly in GUI (no folders)
    // gui.add(effectParams, 'friction').min(0.90).max(0.999).step(0.001).name('Friction').onChange((v) => {
    //   uFriction.value = v;
    // });
    // gui.add(effectParams, 'shrinkSpeed').min(0.0).max(4.0).step(0.1).name('Particle Lifetime').onChange((v) => {
    //   uShrinkSpeed.value = 5.0 - v; // Inverse logic: higher lifetime = slower shrinking
    // });
    gui.add(effectParams, 'explosionStrength').min(0.0).max(10.0).step(0.1).name('Explosion Strength').onChange((v) => {
      uExplosionStrength.value = v;
    });
    
    // Transition controls
    gui.add(transitionParams, 'autoTransition').name('Auto Transition').onChange((value) => {
      if (value) {
        totalTime = 0; // Reset timer when re-enabling
      }
    });
    
    // Controls
    gui.add(effectParams, 'spaceToDisassemble').name('Spacebar to Next Cycle');

    // Initialize
    Promise.all([
      loadSplats(),
      loadTable()
    ]).then(() => {
      addInstructionalText();
      console.log("All assets loaded!");
    }).catch((error) => {
      console.error("Error loading assets:", error);
    });

  </script>
</body>
</html>